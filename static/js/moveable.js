/*
Copyright (c) 2019 Daybrush
name: moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/moveable
version: 0.44.2
*/
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Moveable = e() }(this, function () { "use strict"; var s = function (t, e) { return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }; function u(t, e) { function n() { this.constructor = t } s(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) } var c = function () { return (c = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }).apply(this, arguments) }; function M(e, n) { return function (t) { t && (e[n] = t) } } function f(e, n, r) { return function (t) { t && (e[n][r] = t) } } function l(n, r) { return function (t) { var e = t.prototype; n.forEach(function (t) { r(e, t) }) } } var y = function () { function t() { this.keys = [], this.values = [] } var e = t.prototype; return e.get = function (t) { return this.values[this.keys.indexOf(t)] }, e.set = function (t, e) { var n = this.keys, r = this.values, i = n.indexOf(t), i = -1 === i ? n.length : i; n[i] = t, r[i] = e }, t }(), E = function () { function t() { this.object = {} } var e = t.prototype; return e.get = function (t) { return this.object[t] }, e.set = function (t, e) { this.object[t] = e }, t }(), S = "function" == typeof Map, h = function () { function t() { } var e = t.prototype; return e.connect = function (t, e) { this.prev = t, this.next = e, t && (t.next = this), e && (e.prev = this) }, e.disconnect = function () { var t = this.prev, e = this.next; t && (t.next = e), e && (e.prev = t) }, e.getIndex = function () { for (var t = this, e = -1; t;)t = t.prev, ++e; return e }, t }(); var D = function () { function t(t, e, n, r, i, o, a, s) { this.prevList = t, this.list = e, this.added = n, this.removed = r, this.changed = i, this.maintained = o, this.changedBeforeAdded = a, this.fixed = s } var e = t.prototype; return Object.defineProperty(e, "ordered", { get: function () { return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered }, enumerable: !0, configurable: !0 }), Object.defineProperty(e, "pureChanged", { get: function () { return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged }, enumerable: !0, configurable: !0 }), e.caculateOrdered = function () { t = this.changedBeforeAdded, n = this.fixed, i = [], o = [], t.forEach(function (t) { var e = t[0], t = t[1], n = new h; i[e] = n, o[t] = n }), i.forEach(function (t, e) { t.connect(i[e - 1]) }); var n, i, o, t = t.filter(function (t, e) { return !n[e] }).map(function (t, e) { var n = t[0], t = t[1]; if (n === t) return [0, 0]; var n = i[n], t = o[t - 1], r = n.getIndex(); return n.disconnect(), t ? n.connect(t, t.next) : n.connect(void 0, i[0]), [r, n.getIndex()] }), a = this.changed, s = []; this.cacheOrdered = t.filter(function (t, e) { var n = t[0], t = t[1], e = a[e], r = e[0], e = e[1]; if (n !== t) return s.push([r, e]), !0 }), this.cachePureChanged = s }, t }(); function O(t, e, n) { var r = S ? Map : n ? E : y, n = n || function (t) { return t }, i = [], o = [], a = [], s = t.map(n), n = e.map(n), u = new r, c = new r, l = [], f = [], p = {}, d = [], h = 0, g = 0; return s.forEach(function (t, e) { u.set(t, e) }), n.forEach(function (t, e) { c.set(t, e) }), s.forEach(function (t, e) { t = c.get(t); void 0 === t ? (++g, o.push(e)) : p[t] = g }), n.forEach(function (t, e) { t = u.get(t); void 0 === t ? (i.push(e), ++h) : (a.push([t, e]), g = p[e] || 0, l.push([t - g, e - h]), f.push(e === t), t !== e && d.push([t, e])) }), o.reverse(), new D(t, e, i, o, d, a, l, f) } var g = function () { function t(t, e) { void 0 === t && (t = []), this.findKeyCallback = e, this.list = [].slice.call(t) } return t.prototype.update = function (t) { var t = [].slice.call(t), e = O(this.list, t, this.findKeyCallback); return this.list = t, e }, t }(), _ = "function", R = "object", P = "string", q = "number", L = "undefined", H = typeof window !== L, V = [{ open: "(", close: ")" }, { open: '"', close: '"' }, { open: "'", close: "'" }, { open: '\\"', close: '\\"' }, { open: "\\'", close: "\\'" }], k = 1e-7, U = { cm: function (t) { return 96 * t / 2.54 }, mm: function (t) { return 96 * t / 254 }, in: function (t) { return 96 * t }, pt: function (t) { return 96 * t / 72 }, pc: function (t) { return 96 * t / 6 }, "%": function (t, e) { return t * e / 100 }, vw: function (t, e) { return t / 100 * (e = void 0 === e ? window.innerWidth : e) }, vh: function (t, e) { return t / 100 * (e = void 0 === e ? window.innerHeight : e) }, vmax: function (t, e) { return t / 100 * (e = void 0 === e ? Math.max(window.innerWidth, window.innerHeight) : e) }, vmin: function (t, e) { return t / 100 * (e = void 0 === e ? Math.min(window.innerWidth, window.innerHeight) : e) } }; function $(t, e, n, r) { return (t * r + e * n) / (n + r) } function it(t) { return typeof t === L } function ot(t) { return t && typeof t === R } function w(t) { return Array.isArray(t) } function x(t) { return typeof t === P } function at(t) { return typeof t === q } function st(t) { return typeof t === _ } function ut(t, e, n, r, i) { if (ct(t, e, n)) return n; for (var o, a = t, s = e, u = r, c = i, l = n + 1; l < u; ++l) { var f = function (t) { var e, n, r = s[t].trim(); return r !== a.close || ct(a, s, t) ? (e = t, -1 === (e = (n = bt(c, function (t) { return t.open === r })) ? ut(n, s, t, u, c) : e) ? (o = t, "break") : void (o = t = e)) : { value: t } }(l); if (l = o, "object" == typeof f) return f.value; if ("break" === f) break } return -1 } function ct(t, e, n) { if (!t.ignore) return null; e = e.slice(Math.max(n - 3, 0), n + 3).join(""); return new RegExp(t.ignore).exec(e) } function lt(o, t) { var t = x(t) ? { separator: t } : t, e = t.separator, a = void 0 === e ? "," : e, s = t.isSeparateFirst, u = t.isSeparateOnlyOpenClose, e = t.isSeparateOpenClose, c = void 0 === e ? u : e, e = t.openCloseCharacters, l = void 0 === e ? V : e, t = l.map(function (t) { var e = t.open, t = t.close; return e === t ? e : e + "|" + t }).join("|"), e = new RegExp("(\\s*" + a + "\\s*|" + t + "|\\s+)", "g"), f = o.split(e).filter(Boolean), p = f.length, d = [], h = []; function g() { return h.length && (d.push(h.join("")), h = []) } for (var v, n = function (t) { var e = f[t].trim(), n = t, r = bt(l, function (t) { return t.open === e }), i = bt(l, function (t) { return t.close === e }); if (r) { if (-1 !== (n = ut(r, f, t, p, l)) && c) return g() && s ? (v = t, "break") : (d.push(f.slice(t, n + 1).join("")), t = n, s ? (v = t, "break") : (v = t, "continue")) } else { if (i && !ct(i, f, t)) return (r = function () { for (var t = 0, e = 0, n = arguments.length; e < n; e++)t += arguments[e].length; for (var r = Array(t), i = 0, e = 0; e < n; e++)for (var o = arguments[e], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(l)).splice(l.indexOf(i), 1), { value: lt(o, { separator: a, isSeparateFirst: s, isSeparateOnlyOpenClose: u, isSeparateOpenClose: c, openCloseCharacters: r }) }; if (i = e, !(("" !== (r = a) && " " != r || "" !== i && " " != i) && i !== r || u)) return g(), s ? (v = t, "break") : (v = t, "continue") } h.push(f.slice(t, (n = -1 === n ? p - 1 : n) + 1).join("")), v = t = n }, r = 0; r < p; ++r) { var i = n(r), r = v; if ("object" == typeof i) return i.value; if ("break" === i) break } return h.length && d.push(h.join("")), d } function ft(t) { return lt(t, "") } function pt(t) { return lt(t, ",") } function dt(t) { t = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(t); return !t || t.length < 4 ? {} : { prefix: t[1], value: t[2], suffix: t[3] } } function ht(t) { t = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(t); if (!t) return { prefix: "", unit: "", value: NaN }; var e = t[1], n = t[2]; return { prefix: e, unit: t[3], value: parseFloat(n) } } function gt(t, r) { return void 0 === r && (r = "-"), t.replace(/([a-z])([A-Z])/g, function (t, e, n) { return "" + e + r + n.toLowerCase() }) } function vt() { return Date.now ? Date.now() : (new Date).getTime() } function mt(t, e, n) { void 0 === n && (n = -1); for (var r = t.length, i = 0; i < r; ++i)if (e(t[i], i, t)) return i; return n } function bt(t, e, n) { e = mt(t, e); return -1 < e ? t[e] : n } var xt = function () { var n = vt(), t = H && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame); return t ? t.bind(window) : function (t) { var e = vt(); return window.setTimeout(function () { t(e - n) }, 1e3 / 60) } }(), yt = function () { var t = H && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame); return t ? t.bind(window) : function (t) { clearTimeout(t) } }(); function Et(t) { return Object.keys(t) } function Z(t, e) { var t = ht(t), n = t.value, t = t.unit; if (ot(e)) { var r = e[t]; if (r) { if (st(r)) return r(n); if (U[t]) return U[t](n, r) } } else if ("%" === t) return n * e / 100; return U[t] ? U[t](n) : n } function St(t, e, n) { return Math.max(e, Math.min(t, n)) } function Ct(t, r, i, e) { return void 0 === e && (e = t[0] / t[1]), [[I(r[0], k), I(r[0] / e, k)], [I(r[1] * e, k), I(r[1], k)]].filter(function (t) { return t.every(function (t, e) { var e = r[e], n = I(e, k); return i ? t <= e || t <= n : e <= t || n <= t }) })[0] || t } function Mt(t) { for (var e = t.length, n = 0, r = e - 1; 0 <= r; --r)n += t[r]; return e ? n / e : 0 } function N(t, e) { var n = e[0] - t[0], e = e[1] - t[1], t = Math.atan2(e, n); return 0 <= t ? t : t + 2 * Math.PI } function Dt(t) { n = t; var n, e = [0, 1].map(function (e) { return Mt(n.map(function (t) { return t[e] })) }), r = N(e, t[0]), e = N(e, t[1]); return r < e && e - r < Math.PI || e < r && e - r < -Math.PI ? 1 : -1 } function wt(t, e) { return Math.sqrt(Math.pow((e ? e[0] : 0) - t[0], 2) + Math.pow((e ? e[1] : 0) - t[1], 2)) } function I(t, e) { if (!e) return t; var n = 1 / e; return Math.round(t / e) / n } function _t(n, r) { n.forEach(function (t, e) { n[e] = I(n[e], r) }) } function T(t, e) { return t.classList ? t.classList.contains(e) : !!t.className.match(new RegExp("(\\s|^)" + e + "(\\s|$)")) } function Rt(t, e) { t.classList ? t.classList.add(e) : t.className += " " + e } function Ot(t, e) { t.classList ? t.classList.remove(e) : (e = new RegExp("(\\s|^)" + e + "(\\s|$)"), t.className = t.className.replace(e, " ")) } function v(t, e, n, r) { t.addEventListener(e, n, r) } function m(t, e, n, r) { t.removeEventListener(e, n, r) } var Pt = function (t, e) { return (Pt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }; function Tt(t, e) { function n() { this.constructor = t } Pt(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) } var Gt = function () { return (Gt = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }).apply(this, arguments) }; function zt(t, e) { var n = {}; for (i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n } function Bt(t, e) { if (t === e) return !1; for (var n in t) if (!(n in e)) return !0; for (var n in e) if (t[n] !== e[n]) return !0; return !1 } function kt(n, r) { var i = Object.keys(n), e = Object.keys(r), t = O(i, e, function (t) { return t }), o = {}, a = {}, s = {}; return t.added.forEach(function (t) { t = e[t]; o[t] = r[t] }), t.removed.forEach(function (t) { t = i[t]; a[t] = n[t] }), t.maintained.forEach(function (t) { var t = t[0], t = i[t], e = [n[t], r[t]]; n[t] !== r[t] && (s[t] = e) }), { added: o, removed: a, changed: s } } function At(t) { t.forEach(function (t) { t() }) } function Ft(t) { var e = 0; return t.map(function (t) { return null == t ? "$compat" + ++e : "" + t }) } function Nt(t, e, n, r) { return x(t) || at(t) ? new Wt("text_" + t, e, n, r, null, {}) : new ("string" == typeof t.type ? qt : t.type.prototype.render ? $t : Vt)(t.type, e, n, r, t.ref, t.props) } function It(t) { var e = t.className, t = zt(t, ["className"]); return null != e && (t.class = e), delete t.style, delete t.children, t } function jt(t, e) { if (!e) return t; for (var n in e) it(t[n]) && (t[n] = e[n]); return t } function C(t, e) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; var e = e || {}, i = e.key, o = e.ref, e = zt(e, ["key", "ref"]); return { type: t, key: i, ref: o, props: Gt(Gt({}, e), { children: function e(t) { var n = []; return t.forEach(function (t) { n = n.concat(w(t) ? e(t) : t) }), n }(n).filter(function (t) { return null != t && !1 !== t }) }) } } var Yt = function () { function t(t, e, n, r, i, o) { void 0 === o && (o = {}), this.type = t, this.key = e, this.index = n, this.container = r, this.ref = i, this.props = o, this._providers = [] } var e = t.prototype; return e._should = function (t, e) { return !0 }, e._update = function (t, e, n, r) { if (this.base && !x(e) && !r && !this._should(e.props, n)) return !1; this.original = e, this._setState(n); r = this.props; return x(e) || (this.props = e.props, this.ref = e.ref), this._render(t, this.base ? r : {}, n), !0 }, e._mounted = function () { var t = this.ref; t && t(this.base) }, e._setState = function (t) { }, e._updated = function () { var t = this.ref; t && t(this.base) }, e._destroy = function () { var t = this.ref; t && t(null) }, t }(); function Xt(t) { var e, n = {}, r = {}; for (e in t) 0 === e.indexOf("on") ? r[e.replace("on", "").toLowerCase()] = t[e] : n[e] = t[e]; return { attributes: n, events: r } } var Wt = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } Tt(e, t); var n = e.prototype; return n._render = function (t) { var e = this, n = !this.base; return n && (this.base = document.createTextNode(this.type.replace("text_", ""))), t.push(function () { n ? e._mounted() : e._updated() }), !0 }, n._unmount = function () { this.base.parentNode.removeChild(this.base) }, e }(Yt), qt = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.events = {}, t._isSVG = !1, t } Tt(t, e); var n = t.prototype; return n.addEventListener = function (t, e) { var n = this.events; n[t] = function (t) { t.nativeEvent = t, e(t) }, this.base.addEventListener(t, n[t]) }, n.removeEventListener = function (t) { var e = this.events; this.base.removeEventListener(t, e[t]), delete e[t] }, n._should = function (t) { return Bt(this.props, t) }, n._render = function (t, e) { var n, r = this, i = !this.base, o = (i && (o = this._hasSVG(), this._isSVG = o, (s = this.props.portalContainer) || (a = this.type, s = o ? document.createElementNS("http://www.w3.org/2000/svg", a) : document.createElement(a)), this.base = s), Qt(this, this._providers, this.props.children, t, null), this.base), a = Xt(e), s = a.attributes, a = a.events, u = Xt(this.props), c = u.attributes, u = u.events, s = It(s), c = It(c), l = o, f = (s = kt(s, c)).added, c = s.removed, p = s.changed; for (n in f) l.setAttribute(n, f[n]); for (n in p) l.setAttribute(n, p[n][1]); for (n in c) l.removeAttribute(n); var d, c = a, h = this, g = (c = kt(c, a = u)).added, a = c.removed, v = c.changed; for (d in a) h.removeEventListener(d); for (d in g) h.addEventListener(d, g[d]); for (d in v) h.removeEventListener(d), h.addEventListener(d, v[d][1]); for (d in a) h.removeEventListener(d); var m, u = e.style || {}, c = this.props.style || {}, e = o, b = e.style, x = (e = kt(u, c)).added, u = e.removed, y = e.changed; for (m in x) { var E = gt(m, "-"); b.setProperty ? b.setProperty(E, x[m]) : b[E] = x[m] } for (m in y) { E = gt(m, "-"); b.setProperty ? b.setProperty(E, y[m][1]) : b[E] = y[m][1] } for (m in u) { E = gt(m, "-"); b.removeProperty ? b.removeProperty(E) : b[E] = "" } return t.push(function () { i ? r._mounted() : r._updated() }), !0 }, n._unmount = function () { var t, e = this.events, n = this.base; for (t in e) n.removeEventListener(t, e[t]); this._providers.forEach(function (t) { t._unmount() }), this.events = {}, this.props.portalContainer || n.parentNode.removeChild(n) }, n._hasSVG = function () { if (this._isSVG || "svg" === this.type) return !0; var t = Lt(this.container); return t && "ownerSVGElement" in t }, t }(Yt); function Lt(t) { if (!t) return null; var e = t.base; return e instanceof Node ? e : Lt(t.container) } function Ht(t) { if (!t) return null; if (t instanceof Node) return t; t = t.$_provider._providers; return t.length ? Ht(t[0].base) : null } var Vt = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } Tt(e, t); var n = e.prototype; return n._render = function (t) { var e = this.type(this.props); return Qt(this, this._providers, e ? [e] : [], t), !0 }, n._unmount = function () { this._providers.forEach(function (t) { t._unmount() }) }, e }(Yt), Ut = function (n) { function t(t) { var e = n.call(this, "container", "container", 0, null) || this; return e.base = t, e } Tt(t, n); var e = t.prototype; return e._render = function () { return !0 }, e._unmount = function () { }, t }(Yt), $t = function (a) { function t(t, e, n, r, i, o) { return a.call(this, t, e, n, r, i, jt(o = void 0 === o ? {} : o, t.defaultProps)) || this } Tt(t, a); var e = t.prototype; return e._should = function (t, e) { return this.base.shouldComponentUpdate(jt(t, this.type.defaultProps), e || this.base.state) }, e._render = function (t, e) { var n = this, r = (this.props = jt(this.props, this.type.defaultProps), !this.base), i = (r ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props, this.base), o = i.state, a = i.render(); a && a.props && !a.props.children.length && (a.props.children = this.props.children), Qt(this, this._providers, a ? [a] : [], t), t.push(function () { r ? (n._mounted(), i.componentDidMount()) : (n._updated(), i.componentDidUpdate(e, o)) }) }, e._setState = function (t) { var e = this.base; e && t && (e.state = t) }, e._unmount = function () { this._providers.forEach(function (t) { t._unmount() }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount() }, t }(Yt), Yt = function () { function t(t) { this.props = t = void 0 === t ? {} : t, this.state = {}, this.$_timer = 0, this.$_state = {} } var e = t.prototype; return e.shouldComponentUpdate = function (t, e) { return !0 }, e.render = function () { return null }, e.setState = function (t, e, n) { var r = this; this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = Gt(Gt({}, this.$_state), t), n ? this.$_setState(e, n) : this.$_timer = setTimeout(function () { r.$_timer = 0, r.$_setState(e, n) }) }, e.forceUpdate = function (t) { this.setState({}, t, !0) }, e.componentDidMount = function () { }, e.componentDidUpdate = function (t, e) { }, e.componentWillUnmount = function () { }, e.$_setState = function (t, e) { var n = [], r = this.$_provider; Qt(r.container, [r], [r.original], n, Gt(Gt({}, this.state), this.$_state), e) && (t && n.push(t), At(n)) }, t }(), Zt = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return Tt(e, t), e.prototype.shouldComponentUpdate = function (t, e) { return Bt(this.props, t) || Bt(this.state, e) }, e }(Yt), Kt = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } Tt(e, t); var n = e.prototype; return n.componentDidMount = function () { var t = this.props, e = t.element, t = t.container; this._portalProvider = new Ut(t), te(e, t, this._portalProvider) }, n.componentDidUpdate = function () { var t = this.props; te(t.element, t.container, this._portalProvider) }, n.componentWillUnmount = function () { te(null, this.props.container, this._portalProvider), this._portalProvider = null }, e }(Zt); function Jt(r, i, o) { var a = o.map(function (t) { return x(t) ? null : t.key }), t = O(Ft(i.map(function (t) { return t.key })), Ft(a), function (t) { return t }), e = (t.removed.forEach(function (t) { i.splice(t, 1)[0]._unmount() }), t.ordered.forEach(function (t) { var e = t[0], t = t[1], e = i.splice(e, 1)[0], e = (i.splice(t, 0, e), Ht(e.base)), t = Ht(i[t + 1] && i[t + 1].base); e && e.parentNode.insertBefore(e, t) }), t.added.forEach(function (t) { i.splice(t, 0, Nt(o[t], a[t], t, r)) }), t.maintained.filter(function (t) { t[0]; var t = t[1], e = o[t], n = i[t]; return (x(e) ? "text_" + e : e.type) !== n.type ? (n._unmount(), i.splice(t, 1, Nt(e, a[t], t, r)), !0) : (n.index = t, !1) })); return function () { for (var t = 0, e = 0, n = arguments.length; e < n; e++)t += arguments[e].length; for (var r = Array(t), i = 0, e = 0; e < n; e++)for (var o = arguments[e], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(t.added, e.map(function (t) { return t[0], t[1] })) } function Qt(n, r, i, o, a, s) { var t = Jt(n, r, i), e = r.filter(function (t, e) { return t._update(o, i[e], a, s) }), u = Lt(n); return u && t.reverse().forEach(function (t) { var t = r[t], e = Ht(t.base); e && u !== e && !e.parentNode && (t = function (t, e) { for (var n = t._providers, r = n.length, i = e.index + 1; i < r; ++i) { var o = Ht(n[i].base); if (o) return o } return null }(n, t), u.insertBefore(e, t)) }), 0 < e.length } function te(t, e, n) { var r, i, o = !!(n = void 0 === n ? e.__REACT_COMPAT__ : n); n = n || new Ut(e), t = t ? [t] : [], i = [], Qt(n, n._providers, t, i, r), At(i), o || (e.__REACT_COMPAT__ = n) } function ee(t, e, n) { var r = e.__REACT_COMPAT__; t && !r && (e.innerHTML = ""), te(t, e, r), n && n() } function ne(t, e) { for (var n = t.length, r = 0; r < n; ++r)if (e(t[r], r)) return !0; return !1 } function re(t, e) { for (var n = t.length, r = 0; r < n; ++r)if (e(t[r], r)) return t[r]; return null } function ie(t) { if (void 0 === t) { if ("undefined" == typeof navigator || !navigator) return ""; t = navigator.userAgent || "" } return t.toLowerCase() } function oe(t, e) { try { return new RegExp(t, "g").exec(e) } catch (t) { return null } } function ae(t) { return t.replace(/_/g, ".") } function se(t, n) { var r = null, i = "-1"; return ne(t, function (t) { var e = oe("(" + t.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", n); if (e && !t.brand) return r = t, i = e[3] || "-1", t.versionAlias ? i = t.versionAlias : t.versionTest && (e = t.versionTest.toLowerCase(), i = ((e = oe("(" + e + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", n)) ? e[3] : "") || i), i = ae(i), 1 }), { preset: r, version: i } } function ue(t, n) { var r = { brand: "", version: "-1" }; return ne(t, function (t) { var e = ce(n, t); return e && (r.brand = t.id, r.version = t.versionAlias || e.version, "-1" !== r.version) }), r } function ce(t, e) { return re(t, function (t) { t = t.brand; return oe("" + e.test, t.toLowerCase()) }) } var t = [{ test: "phantomjs", id: "phantomjs" }, { test: "whale", id: "whale" }, { test: "edgios|edge|edg", id: "edge" }, { test: "msie|trident|windows phone", id: "ie", versionTest: "iemobile|msie|rv" }, { test: "miuibrowser", id: "miui browser" }, { test: "samsungbrowser", id: "samsung internet" }, { test: "samsung", id: "samsung internet", versionTest: "version" }, { test: "chrome|crios", id: "chrome" }, { test: "firefox|fxios", id: "firefox" }, { test: "android", id: "android browser", versionTest: "version" }, { test: "safari|iphone|ipad|ipod", id: "safari", versionTest: "version" }], le = [{ test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)", id: "chrome", versionTest: "chrome" }, { test: "chromium", id: "chrome" }, { test: "whale", id: "chrome", versionAlias: "-1", brand: !0 }], fe = [{ test: "applewebkit", id: "webkit", versionTest: "applewebkit|safari" }], pe = [{ test: "(?=(iphone|ipad))(?!(.*version))", id: "webview" }, { test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))", id: "webview" }, { test: "webview", id: "webview" }], e = [{ test: "windows phone", id: "windows phone" }, { test: "windows 2000", id: "window", versionAlias: "5.0" }, { test: "windows nt", id: "window" }, { test: "win32|windows", id: "window" }, { test: "iphone|ipad|ipod", id: "ios", versionTest: "iphone os|cpu os" }, { test: "macos|macintel|mac os x", id: "mac" }, { test: "android|linux armv81", id: "android" }, { test: "tizen", id: "tizen" }, { test: "webos|web0s", id: "webos" }]; function de(t) { return !!se(pe, t).preset } function he(t, e, n) { void 0 === n && (n = Math.sqrt(t.length)); for (var r = t.slice(), i = 0; i < n; ++i)r[i * n + e - 1] = 0, r[(e - 1) * n + i] = 0; return r[(e - 1) * (n + 1)] = 1, r } function ge(t, e) { void 0 === e && (e = Math.sqrt(t.length)); for (var n = t.slice(), r = W(e), i = 0; i < e; ++i) { var o = e * i + i; if (!I(n[o], k)) for (var a = i + 1; a < e; ++a)if (n[e * i + a]) { v = g = h = d = p = f = l = c = u = s = void 0; for (var s = n, u = r, c = i, l = a, f = e, p = 0; p < f; ++p) { var d = c + p * f, h = l + p * f, g = s[d], v = u[d]; s[d] = s[h], s[h] = g, u[d] = u[h], u[h] = v } break } if (!I(n[o], k)) return []; C = S = E = y = x = b = m = void 0; for (var m = n, b = r, x = i, y = e, E = n[o], S = 0; S < y; ++S) { var C = x + S * y; m[C] /= E, b[C] /= E } for (a = 0; a < e; ++a) { var M = a, D = n[a + i * e]; if (I(D, k) && i !== a) { B = z = G = T = P = O = R = _ = w = void 0; for (var w = n, _ = r, R = M, O = i, P = e, T = -D, G = 0; G < P; ++G) { var z = R + G * P, B = O + G * P; w[z] += w[B] * T, _[z] += _[B] * T } } } } return r } function ve(t, e) { for (var n = [], r = t[(e = void 0 === e ? Math.sqrt(t.length) : e) * e - 1], i = 0; i < e - 1; ++i)n[i] = t[e * (e - 1) + i] / r; return n[e - 1] = 0, n } function me(t, e) { for (var n = t.slice(), r = t.length; r < e - 1; ++r)n[r] = 0; return n[e - 1] = 1, n } function be(t, e, n) { if ((e = void 0 === e ? Math.sqrt(t.length) : e) === n) return t; for (var r = W(n), i = Math.min(e, n), o = 0; o < i - 1; ++o) { for (var a = 0; a < i - 1; ++a)r[o * n + a] = t[o * e + a]; r[(o + 1) * n - 1] = t[(o + 1) * e - 1], r[(n - 1) * n + o] = t[(e - 1) * e + o] } return r[n * n - 1] = t[e * e - 1], r } function xe(e) { for (var t = [], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; var r = W(e); return t.forEach(function (t) { r = K(r, t, e) }), r } function K(t, e, n) { void 0 === n && (n = Math.sqrt(t.length)); var r = [], i = t.length / n, o = e.length / i; if (!i) return e; if (!o) return t; for (var a = 0; a < n; ++a)for (var s = 0; s < o; ++s)for (var u = r[s * n + a] = 0; u < i; ++u)r[s * n + a] += t[u * n + a] * e[s * i + u]; return r } function J(t, e) { for (var n = Math.min(t.length, e.length), r = t.slice(), i = 0; i < n; ++i)r[i] = r[i] + e[i]; return r } function z(t, e) { for (var n = Math.min(t.length, e.length), r = t.slice(), i = 0; i < n; ++i)r[i] = r[i] - e[i]; return r } function ye(t, e) { return (e = void 0 === e ? 9 === t.length : e) ? [t[0], t[1], t[3], t[4], t[6], t[7]] : t } function G(t, e, n) { var t = K(t, e, n = void 0 === n ? e.length : n), r = t[n - 1]; return t.map(function (t) { return t / r }) } function Ee(t, e) { return K(t, [1, 0, 0, 0, 0, Math.cos(e), Math.sin(e), 0, 0, -Math.sin(e), Math.cos(e), 0, 0, 0, 0, 1], 4) } function Se(t, e) { return K(t, [Math.cos(e), 0, -Math.sin(e), 0, 0, 1, 0, 0, Math.sin(e), 0, Math.cos(e), 0, 0, 0, 0, 1], 4) } function Ce(t, e) { return K(t, Re(e, 4)) } function Me(t, e) { var n = e[0], r = e[1], e = e[2]; return K(t, [void 0 === n ? 1 : n, 0, 0, 0, 0, void 0 === r ? 1 : r, 0, 0, 0, 0, void 0 === e ? 1 : e, 0, 0, 0, 0, 1], 4) } function De(t, e) { return G(Re(e, 3), me(t, 3)) } function we(t, e) { var n = e[0], r = e[1], e = e[2]; return K(t, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, void 0 === n ? 0 : n, void 0 === r ? 0 : r, void 0 === e ? 0 : e, 1], 4) } function _e(t, e) { return K(t, e, 4) } function Re(t, e) { var n = Math.cos(t), t = Math.sin(t), r = W(e); return r[0] = n, r[1] = t, r[e] = -t, r[e + 1] = n, r } function W(t) { for (var e = t * t, n = [], r = 0; r < e; ++r)n[r] = r % (t + 1) ? 0 : 1; return n } function Oe(t, e) { for (var n = W(e), r = Math.min(t.length, e - 1), i = 0; i < r; ++i)n[(e + 1) * i] = t[i]; return n } function Pe(t, e) { for (var n = W(e), r = Math.min(t.length, e - 1), i = 0; i < r; ++i)n[e * (e - 1) + i] = t[i]; return n } function Te(t, e, n, r, i, o, a, s) { var u = t[0], t = t[1], c = e[0], e = e[1], l = n[0], n = n[1], f = r[0], r = r[1], p = i[0], i = i[1], d = o[0], o = o[1], h = a[0], a = a[1], g = s[0], s = s[1], u = ge([u, 0, c, 0, l, 0, f, 0, t, 0, e, 0, n, 0, r, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, u, 0, c, 0, l, 0, f, 0, t, 0, e, 0, n, 0, r, 0, 1, 0, 1, 0, 1, 0, 1, -p * u, -i * u, -d * c, -o * c, -h * l, -a * l, -g * f, -s * f, -p * t, -i * t, -d * e, -o * e, -h * n, -a * n, -g * r, -s * r], 8); if (!u.length) return []; c = K(u, [p, i, d, o, h, a, g, s], 8); return c[8] = 1, be(function (t, e) { void 0 === e && (e = Math.sqrt(t.length)); for (var n = [], r = 0; r < e; ++r)for (var i = 0; i < e; ++i)n[i * e + r] = t[e * r + i]; return n }(c), 3, 4) } function Ge(t) { return ze(Be(t)) } function ze(t) { var n = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; return t.forEach(function (t) { var e = t.matrixFunction, t = t.functionValue; e && (n = e(n, t)) }), n } function Be(t) { return (w(t) ? t : ft(t)).map(function (t) { var e, n, r, t = dt(t), i = t.prefix, t = t.value, o = null, a = i, s = ""; return "translate" === i || "translateX" === i || "translate3d" === i ? (o = we, s = [(r = pt(t).map(function (t) { return parseFloat(t) }))[0], void 0 === (e = r[1]) ? 0 : e, void 0 === (e = r[2]) ? 0 : e]) : "translateY" === i ? (o = we, s = [0, parseFloat(t), 0]) : "translateZ" === i ? (o = we, s = [0, 0, parseFloat(t)]) : "scale" === i || "scale3d" === i ? (o = Me, s = [n = (r = pt(t).map(function (t) { return parseFloat(t) }))[0], void 0 === (e = r[1]) ? n : e, void 0 === (e = r[2]) ? 1 : e]) : "scaleX" === i ? (o = Me, s = [n = parseFloat(t), 1, 1]) : "scaleY" === i ? (o = Me, s = [1, parseFloat(t), 1]) : "scaleZ" === i ? (o = Me, s = [1, 1, parseFloat(t)]) : "rotate" === i || "rotateZ" === i || "rotateX" === i || "rotateY" === i ? (e = (r = ht(t)).unit, n = r.value, "rotate" === i || "rotateZ" === i ? (a = "rotateZ", o = Ce) : "rotateX" === i ? o = Ee : "rotateY" === i && (o = Se), s = "rad" === e ? n : n * Math.PI / 180) : "matrix3d" === i ? (o = _e, s = pt(t).map(function (t) { return parseFloat(t) })) : "matrix" === i ? (o = _e, s = [(r = pt(t).map(function (t) { return parseFloat(t) }))[0], r[1], 0, 0, r[2], r[3], 0, 0, 0, 0, 1, 0, r[4], r[5], 0, 1]) : a = "", { name: i, functionName: a, value: t, matrixFunction: o, functionValue: s } }) } var ke = function (t, e) { return (ke = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }; var Ae, Fe = "function" == typeof Map ? void 0 : (Ae = 0, function (t) { return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++Ae) }), Ne = function (e) { function t() { this.constructor = n } var n, r; function i(t) { return e.call(this, t = void 0 === t ? [] : t, Fe) || this } return ke(n = i, r = e), n.prototype = null === r ? Object.create(r) : (t.prototype = r.prototype, new t), i }(g); function p(t) { return I(t, k) } function Ie(n) { return n.length < 3 ? 0 : Math.abs(function (t) { for (var e = 0, n = t.length - 1; 0 <= n; --n)e += t[n]; return e }(n.map(function (t, e) { e = n[e + 1] || n[0]; return t[0] * e[1] - e[0] * t[1] }))) / 2 } function je(t, e) { var n = e.width, r = e.height, i = e.left, o = e.top, e = Ye(t), a = e.minX, s = e.minY, u = e.maxX, e = e.maxY, c = n / (u - a), l = r / (e - s); return t.map(function (t) { return [i + (t[0] - a) * c, o + (t[1] - s) * l] }) } function Ye(t) { var e = t.map(function (t) { return t[0] }), t = t.map(function (t) { return t[1] }); return { minX: Math.min.apply(Math, e), minY: Math.min.apply(Math, t), maxX: Math.max.apply(Math, e), maxY: Math.max.apply(Math, t) } } function Xe(i, t, e) { var r = i[0], o = i[1], n = Ye(t), a = n.minX, n = n.maxX, s = [[a, o], [n, o]], u = We(s[0], s[1]), a = He(t), c = []; if (a.forEach(function (t) { var n, e = We(t[0], t[1]), r = t[0]; n = e, u.every(function (t, e) { return 0 === p(t - n[e]) }) ? c.push({ pos: i, line: t, type: "line" }) : Le(qe(u, e), [s, t]).forEach(function (n) { t.some(function (t) { return e = n, !p((t = t)[0] - e[0]) && !p(t[1] - e[1]); var e }) ? c.push({ pos: n, line: t, type: "point" }) : 0 !== p(r[1] - o) && c.push({ pos: n, line: t, type: "intersection" }) }) }), !e && bt(c, function (t) { return t[0] === r })) return !0; var l = 0, f = {}; return c.forEach(function (t) { var e = t.pos, n = t.type, t = t.line; e[0] > r || ("intersection" === n ? ++l : "line" !== n && "point" === n && (n = bt(t, function (t) { return t[1] !== o }), t = f[e[0]], n = n[1] > o ? 1 : -1, t ? t !== n && ++l : f[e[0]] = n)) }), l % 2 == 1 } function We(t, e) { var n = t[0], t = t[1], r = e[0] - n, e = e[1] - t, i = (Math.abs(r) < k && (r = 0), Math.abs(e) < k && (e = 0), 0), o = 0, a = 0; return r ? a = e ? (o = 1, -(i = -e / r) * n - t) : (o = 1, -t) : e && (i = -1, a = n), [i, o, a] } function qe(t, e) { var n, r, i = t[0], o = t[1], t = t[2], a = e[0], s = e[1], e = e[2], u = 0 === i && 0 === a, c = 0 === o && 0 === s; return u && c ? [] : u ? (u = -t / o) != -e / s ? [] : [[-1 / 0, u], [1 / 0, u]] : c ? (u = -t / i) != -e / a ? [] : [[u, -1 / 0], [u, 1 / 0]] : (0 === i ? [[n = -(s * (r = -t / o) + e) / a, r]] : 0 === a ? [[n = -(o * (r = -e / s) + t) / i, r]] : 0 === o ? [[n = -t / i, r = -(a * n + e) / s]] : 0 === s ? [[n = -e / a, r = -(i * n + t) / o]] : [[n = (o * e - s * t) / (s * i - o * a), r = -(i * n + t) / o]]).map(function (t) { return [t[0], t[1]] }) } function Le(t, e) { var r = e.map(function (e) { return [0, 1].map(function (t) { return [Math.min(e[0][t], e[1][t]), Math.max(e[0][t], e[1][t])] }) }), e = []; if (2 === t.length) { var n = t[0], i = n[0], n = n[1]; if (p(i - t[1][0])) { if (!p(n - t[1][1])) { var o = Math.max.apply(Math, r.map(function (t) { return t[0][0] })), a = Math.min.apply(Math, r.map(function (t) { return t[0][1] })); if (0 < p(o - a)) return []; e = [[o, n], [a, n]] } } else { o = Math.max.apply(Math, r.map(function (t) { return t[1][0] })), a = Math.min.apply(Math, r.map(function (t) { return t[1][1] })); if (0 < p(o - a)) return []; e = [[i, o], [i, a]] } } return (e = e.length ? e : t.filter(function (t) { var e = t[0], n = t[1]; return r.every(function (t) { return 0 <= p(e - t[0][0]) && 0 <= p(t[0][1] - e) && 0 <= p(n - t[1][0]) && 0 <= p(t[1][1] - n) }) })).map(function (t) { return [p(t[0]), p(t[1])] }) } function He(n) { return function () { for (var t = 0, e = 0, n = arguments.length; e < n; e++)t += arguments[e].length; for (var r = Array(t), i = 0, e = 0; e < n; e++)for (var o = arguments[e], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(n.slice(1), [n[0]]).map(function (t, e) { return [n[e], t] }) } function Ve(t, e) { var i, a, s, u, c, l, n; return e = e, i = (t = t).slice(), a = e.slice(), -1 === Dt(i) && i.reverse(), -1 === Dt(a) && a.reverse(), s = He(i), u = He(a), t = s.map(function (t) { return We(t[0], t[1]) }), c = u.map(function (t) { return We(t[0], t[1]) }), l = [], t.forEach(function (n, r) { var i = s[r], o = []; c.forEach(function (t, e) { t = Le(qe(n, t), [i, u[e]]); o.push.apply(o, t.map(function (t) { return { index1: r, index2: e, pos: t, type: "intersection" } })) }), o.sort(function (t, e) { return wt(i[0], t.pos) - wt(i[0], e.pos) }), l.push.apply(l, o), Xe(i[1], a) && l.push({ index1: r, index2: -1, pos: i[1], type: "inside" }) }), u.forEach(function (t, n) { var r, e; Xe(t[1], i) && (r = !1, -1 === (e = mt(l, function (t) { if (t.index2 !== n) return !!r; r = !0 })) && (r = !1, e = mt(l, function (t) { var e = t.index1, t = t.index2; if (-1 !== e || t + 1 !== n) return !!r; r = !0 })), -1 === e ? l.push({ index1: -1, index2: n, pos: t[1], type: "inside" }) : l.splice(e, 0, { index1: -1, index2: n, pos: t[1], type: "inside" })) }), n = {}, l.filter(function (t) { t = t.pos, t = t[0] + "x" + t[1]; return !n[t] && (n[t] = !0) }).map(function (t) { return t.pos }) } var Ue = function () { return (Ue = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }).apply(this, arguments) }; var $e = function () { function t() { this._events = {} } var e = t.prototype; return e.on = function (t, e) { if (ot(t)) for (var n in t) this.on(n, t[n]); else this._addEvent(t, e, {}); return this }, e.off = function (t, e) { if (t) if (ot(t)) for (var n in t) this.off(n); else { var r, i; e ? (r = this._events[t]) && -1 < (i = mt(r, function (t) { return t.listener === e })) && r.splice(i, 1) : this._events[t] = [] } else this._events = {}; return this }, e.once = function (e, t) { var n = this; return t && this._addEvent(e, t, { once: !0 }), new Promise(function (t) { n._addEvent(e, t, { once: !0 }) }) }, e.emit = function (e, n) { var r = this, t = (void 0 === n && (n = {}), this._events[e]); if (!e || !t) return !0; var i = !1; return n.eventType = e, n.stop = function () { i = !0 }, n.currentTarget = this, function () { for (var t = 0, e = 0, n = arguments.length; e < n; e++)t += arguments[e].length; for (var r = Array(t), i = 0, e = 0; e < n; e++)for (var o = arguments[e], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(t).forEach(function (t) { t.listener(n), t.once && r.off(e, t.listener) }), !i }, e.trigger = function (t, e) { return this.emit(t, e = void 0 === e ? {} : e) }, e._addEvent = function (t, e, n) { var r = this._events; r[t] = r[t] || [], r[t].push(Ue({ listener: e }, n)) }, t }(), Ze = function (t, e) { return (Ze = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }; var Ke = function () { return (Ke = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }).apply(this, arguments) }; function Je(t) { t = t.container; return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop] } function Qe(t, e) { return t.addEventListener("scroll", e), function () { t.removeEventListener("scroll", e) } } function tn(t) { return t ? x(t) ? document.querySelector(t) : st(t) ? t() : t instanceof Element ? t : "current" in t ? t.current : "value" in t ? t.value : void 0 : null } var en = function (t) { function e() { this.constructor = n } var n; function r() { var n = null !== t && t.apply(this, arguments) || this; return n._startRect = null, n._startPos = [], n._prevTime = 0, n._timer = 0, n._prevScrollPos = [0, 0], n._isWait = !1, n._flag = !1, n._currentOptions = null, n._lock = !1, n._unregister = null, n._onScroll = function () { var e = n._currentOptions; !n._lock && e && n.emit("scrollDrag", { next: function (t) { n.checkScroll({ container: e.container, inputEvent: t }) } }) }, n } Ze(n = r, i = t), n.prototype = null === i ? Object.create(i) : (e.prototype = i.prototype, new e); var i = r.prototype; return i.dragStart = function (t, e) { var n, r, i, o, a = tn(e.container); a ? (o = i = r = n = 0, o = a === document.body ? (i = window.innerWidth, window.innerHeight) : (n = (a = a.getBoundingClientRect()).top, r = a.left, i = a.width, a.height), this._flag = !0, this._startPos = [t.clientX, t.clientY], this._startRect = { top: n, left: r, width: i, height: o }, this._prevScrollPos = this._getScrollPosition([0, 0], e), this._currentOptions = e, this._registerScrollEvent(e)) : this._flag = !1 }, i.drag = function (t, e) { var n, r, i, o, a, s; if (clearTimeout(this._timer), this._flag) return n = t.clientX, r = t.clientY, i = e.threshold, i = void 0 === i ? 0 : i, o = this._startRect, a = this._startPos, this._currentOptions = e, s = [0, 0], o.top > r - i ? (a[1] > o.top || r < a[1]) && (s[1] = -1) : o.top + o.height < r + i && (a[1] < o.top + o.height || r > a[1]) && (s[1] = 1), o.left > n - i ? (a[0] > o.left || n < a[0]) && (s[0] = -1) : o.left + o.width < n + i && (a[0] < o.left + o.width || n > a[0]) && (s[0] = 1), !(!s[0] && !s[1]) && this._continueDrag(Ke(Ke({}, e), { direction: s, inputEvent: t, isDrag: !0 })) }, i.checkScroll = function (t) { var e = this; if (this._isWait) return !1; var n = t.prevScrollPos, n = void 0 === n ? this._prevScrollPos : n, r = t.direction, i = t.throttleTime, i = void 0 === i ? 0 : i, o = t.inputEvent, a = t.isDrag, s = this._getScrollPosition(r || [0, 0], t), u = s[0] - n[0], n = s[1] - n[1], r = r || [u ? Math.abs(u) / u : 0, n ? Math.abs(n) / n : 0]; return this._prevScrollPos = s, this._lock = !1, !(!u && !n) && (this.emit("move", { offsetX: r[0] ? u : 0, offsetY: r[1] ? n : 0, inputEvent: o }), i && a && (clearTimeout(this._timer), this._timer = window.setTimeout(function () { e._continueDrag(t) }, i)), !0) }, i.dragEnd = function () { this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent() }, i._getScrollPosition = function (t, e) { var n = e.container, e = e.getScrollPosition; return (void 0 === e ? Je : e)({ container: tn(n), direction: t }) }, i._continueDrag = function (t) { var e = this, n = t.container, r = t.direction, i = t.throttleTime, o = t.useScroll, a = t.isDrag, s = t.inputEvent; if (!(!this._flag || a && this._isWait)) { var u = vt(), i = Math.max(i + this._prevTime - u, 0); if (0 < i) return clearTimeout(this._timer), this._timer = window.setTimeout(function () { e._continueDrag(t) }, i), !1; this._prevTime = u; i = this._getScrollPosition(r, t), u = (this._prevScrollPos = i, a && (this._isWait = !0), o || (this._lock = !0), { container: tn(n), direction: r, inputEvent: s }); return null != (a = t.requestScroll) && a.call(t, u), this.emit("scroll", u), this._isWait = !1, o || this.checkScroll(Ke(Ke({}, t), { prevScrollPos: i, direction: r, inputEvent: s })) } }, i._registerScrollEvent = function (t) { this._unregisterScrollEvent(); var e, n = t.checkScrollEvent; n && (e = !0 === n ? Qe : n, t = tn(t.container), !0 !== n || t !== document.body && t !== document.documentElement ? this._unregister = e(t, this._onScroll) : this._unregister = Qe(window, this._onScroll)) }, i._unregisterScrollEvent = function () { var t; null != (t = this._unregister) && t.call(this), this._unregister = null }, r }($e), nn = function (t, e) { return (nn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }; var b = function () { return (b = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }).apply(this, arguments) }; function rn(t) { return 180 * (e = [t[0].clientX, t[0].clientY], t = [t[1].clientX, t[1].clientY], n = t[0] - e[0], t = t[1] - e[1], (0 <= (e = Math.atan2(t, n)) ? e : e + 2 * Math.PI) / Math.PI); var e, n } function on(t) { if (!t) return []; if (t.touches) { for (var e = t.touches, n = Math.min(e.length, 2), r = [], i = 0; i < n; ++i)r.push(un(e[i])); return r } return [un(t)] } function an(t, e, n) { var r = n.length, t = cn(t, r), i = t.clientX, o = t.clientY, a = t.originalClientX, t = t.originalClientY, e = cn(e, r), s = e.clientX, e = e.clientY, n = cn(n, r); return { clientX: a, clientY: t, deltaX: i - s, deltaY: o - e, distX: i - n.clientX, distY: o - n.clientY } } function sn(t) { return Math.sqrt(Math.pow(t[0].clientX - t[1].clientX, 2) + Math.pow(t[0].clientY - t[1].clientY, 2)) } function un(t) { return { clientX: t.clientX, clientY: t.clientY } } function cn(t, e) { void 0 === e && (e = t.length); for (var n = { clientX: 0, clientY: 0, originalClientX: 0, originalClientY: 0 }, r = 0; r < e; ++r) { var i = t[r]; n.originalClientX += "originalClientX" in i ? i.originalClientX : i.clientX, n.originalClientY += "originalClientY" in i ? i.originalClientY : i.clientY, n.clientX += i.clientX, n.clientY += i.clientY } return e ? { clientX: n.clientX / e, clientY: n.clientY / e, originalClientX: n.originalClientX / e, originalClientY: n.originalClientY / e } : n } var ln = function () { function t(t) { this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = t, this.prevClients = t, this.length = t.length } return t.prototype.getAngle = function (t) { return rn(t = void 0 === t ? this.prevClients : t) }, t.prototype.getRotation = function (t) { return rn(t = void 0 === t ? this.prevClients : t) - rn(this.startClients) }, t.prototype.getPosition = function (t, e) { var n = an((t = void 0 === t ? this.prevClients : t) || this.prevClients, this.prevClients, this.startClients), r = n.deltaX, i = n.deltaY; return this.movement += Math.sqrt(r * r + i * i), this.prevClients = t, n }, t.prototype.getPositions = function (n) { void 0 === n && (n = this.prevClients); var r = this.prevClients; return this.startClients.map(function (t, e) { return an([n[e]], [r[e]], [t]) }) }, t.prototype.getMovement = function (t) { var e = this.movement; if (!t) return e; var t = cn(t, this.length), n = cn(this.prevClients, this.length), r = t.clientX - n.clientX, t = t.clientY - n.clientY; return Math.sqrt(r * r + t * t) + e }, t.prototype.getDistance = function (t) { return sn(t = void 0 === t ? this.prevClients : t) }, t.prototype.getScale = function (t) { return sn(t = void 0 === t ? this.prevClients : t) / sn(this.startClients) }, t.prototype.move = function (e, n) { this.startClients.forEach(function (t) { t.clientX -= e, t.clientY -= n }), this.prevClients.forEach(function (t) { t.clientX -= e, t.clientY -= n }) }, t }(), fn = ["textarea", "input"], pn = function (o) { function t() { this.constructor = e } var e, n; function r(t, e) { void 0 === e && (e = {}); var n, g = o.call(this) || this, t = (g.options = {}, g.flag = !1, g.pinchFlag = !1, g.data = {}, g.isDrag = !1, g.isPinch = !1, g.isMouse = !1, g.isTouch = !1, g.clientStores = [], g.targets = [], g.prevTime = 0, g.doubleFlag = !1, g._dragFlag = !1, g._isTrusted = !1, g._isMouseEvent = !1, g._isSecondaryButton = !1, g._preventMouseEvent = !1, g._prevInputEvent = null, g.onDragStart = function (t, e) { if (void 0 === e && (e = !0), g.flag || !1 !== t.cancelable) { var n = g.options, r = n.container, i = n.pinchOutside, o = n.preventWheelClick, a = n.preventRightClick, s = n.preventDefault, u = n.checkInput, c = n.preventClickEventOnDragStart, l = n.preventClickEventOnDrag, n = n.preventClickEventByCondition, f = g.isTouch, p = !g.flag; if (g._isSecondaryButton = 3 === t.which || 2 === t.button, o && (2 === t.which || 1 === t.button) || a && (3 === t.which || 2 === t.button)) return g.stop(), !1; if (p) { o = document.activeElement, a = t.target; if (a) { var d = a.tagName.toLowerCase(), d = -1 < fn.indexOf(d), h = a.isContentEditable; if (d || h) { if (u || o === a) return !1; if (o && h && o.isContentEditable && o.contains(a)) return !1 } else (s || "touchstart" === t.type) && o && (d = o.tagName.toLowerCase(), (o.isContentEditable || -1 < fn.indexOf(d)) && o.blur()); (c || l || n) && v(window, "click", g._onClick, !0) } g.clientStores = [new ln(on(t))], g.flag = !0, g.isDrag = !1, g._isTrusted = e, g._dragFlag = !0, g._prevInputEvent = t, g.data = {}, g.doubleFlag = vt() - g.prevTime < 200, g._isMouseEvent = (u = t) && (-1 < u.type.indexOf("mouse") || "button" in u), !g._isMouseEvent && g._preventMouseEvent && (g._preventMouseEvent = !1), !1 === (g._preventMouseEvent || g.emit("dragStart", b(b({ data: g.data, datas: g.data, inputEvent: t, isMouseEvent: g._isMouseEvent, isSecondaryButton: g._isSecondaryButton, isTrusted: e, isDouble: g.doubleFlag }, g.getCurrentStore().getPosition()), { preventDefault: function () { t.preventDefault() }, preventDrag: function () { g._dragFlag = !1 } }))) && g.stop(), g._isMouseEvent && g.flag && s && t.preventDefault() } if (!g.flag) return !1; h = 0; p ? (g._attchDragEvent(), f && i && (h = setTimeout(function () { v(r, "touchstart", g.onDragStart, { passive: !1 }) }))) : f && i && m(r, "touchstart", g.onDragStart), g.flag && ((a = t).touches && 2 <= a.touches.length) && (clearTimeout(h), p && t.touches.length !== t.changedTouches.length || g.pinchFlag || g.onPinchStart(t)) } }, g.onDrag = function (t, e) { if (g.flag) { var n = g.options.preventDefault, n = (!g._isMouseEvent && n && t.preventDefault(), on(g._prevInputEvent = t)), r = g.moveClients(n, t, !1); if (g._dragFlag) { if (g.pinchFlag || r.deltaX || r.deltaY) if (!1 === (g._preventMouseEvent || g.emit("drag", b(b({}, r), { isScroll: !!e, inputEvent: t })))) return void g.stop(); g.pinchFlag && g.onPinch(t, n) } g.getCurrentStore().getPosition(n, !0) } }, g.onDragEnd = function (t) { var e, n, r, i, o, a; g.flag && (a = (r = g.options).pinchOutside, e = r.container, o = r.preventClickEventOnDrag, i = r.preventClickEventOnDragStart, r = r.preventClickEventByCondition, n = g.isDrag, (o || i || r) && requestAnimationFrame(function () { g._allowClickEvent() }), r || i || !o || n || g._allowClickEvent(), g.isTouch && a && m(e, "touchstart", g.onDragStart), g.pinchFlag && g.onPinchEnd(t), 0 !== (r = null != t && t.touches ? on(t) : []).length && g.options.keepDragging ? g._addStore(new ln(r)) : g.flag = !1, i = g._getPosition(), o = vt(), a = !n && g.doubleFlag, g._prevInputEvent = null, g.prevTime = n || a ? 0 : o, g.flag || (g._dettachDragEvent(), g._preventMouseEvent || g.emit("dragEnd", b({ data: g.data, datas: g.data, isDouble: a, isDrag: n, isClick: !n, isMouseEvent: g._isMouseEvent, isSecondaryButton: g._isSecondaryButton, inputEvent: t, isTrusted: g._isTrusted }, i)), g.clientStores = [], g._isMouseEvent || (g._preventMouseEvent = !0, requestAnimationFrame(function () { requestAnimationFrame(function () { g._preventMouseEvent = !1 }) })))) }, g.onBlur = function () { g.onDragEnd() }, g._allowClickEvent = function () { m(window, "click", g._onClick, !0) }, g._onClick = function (t) { g._allowClickEvent(), g._preventMouseEvent = !1; var e = g.options.preventClickEventByCondition; null != e && e(t) || (t.stopPropagation(), t.preventDefault()) }, g._onContextMenu = function (t) { g.options.preventRightClick ? g.onDragEnd(t) : t.preventDefault() }, g._passCallback = function () { }, [].concat(t)), e = (g.options = b({ checkInput: !1, container: 1 < t.length ? window : t[0], preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, e), g.options), r = e.container, i = e.events, e = e.checkWindowBlur; return g.isTouch = -1 < i.indexOf("touch"), g.isMouse = -1 < i.indexOf("mouse"), g.targets = t, g.isMouse && (t.forEach(function (t) { v(t, "mousedown", g.onDragStart), v(t, "mousemove", g._passCallback) }), v(r, "contextmenu", g._onContextMenu)), e && v(window, "blur", g.onBlur), g.isTouch && (n = { passive: !1 }, t.forEach(function (t) { v(t, "touchstart", g.onDragStart, n), v(t, "touchmove", g._passCallback, n) })), g } return nn(e = r, n = o), e.prototype = null === n ? Object.create(n) : (t.prototype = n.prototype, new t), r.prototype.stop = function () { this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent() }, r.prototype.getMovement = function (t) { return this.getCurrentStore().getMovement(t) + this.clientStores.slice(1).reduce(function (t, e) { return t + e.movement }, 0) }, r.prototype.isDragging = function () { return this.isDrag }, r.prototype.isFlag = function () { return this.flag }, r.prototype.isPinchFlag = function () { return this.pinchFlag }, r.prototype.isDoubleFlag = function () { return this.doubleFlag }, r.prototype.isPinching = function () { return this.isPinch }, r.prototype.scrollBy = function (t, e, n, r) { void 0 === r && (r = !0), this.flag && (this.clientStores[0].move(t, e), r && this.onDrag(n, !0)) }, r.prototype.move = function (t, e) { var n = t[0], r = t[1], t = this.getCurrentStore().prevClients; return this.moveClients(t.map(function (t) { var e = t.clientX, t = t.clientY; return { clientX: e + n, clientY: t + r, originalClientX: e, originalClientY: t } }), e, !0) }, r.prototype.triggerDragStart = function (t) { this.onDragStart(t, !1) }, r.prototype.setEventData = function (t) { var e, n = this.data; for (e in t) n[e] = t[e]; return this }, r.prototype.setEventDatas = function (t) { return this.setEventData(t) }, r.prototype.getCurrentEvent = function (t) { return void 0 === t && (t = this._prevInputEvent), b(b({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: t }) }, r.prototype.getEventData = function () { return this.data }, r.prototype.getEventDatas = function () { return this.data }, r.prototype.unset = function () { var e = this, t = this.targets, n = this.options.container; this.off(), m(window, "blur", this.onBlur), this.isMouse && (t.forEach(function (t) { m(t, "mousedown", e.onDragStart) }), m(n, "contextmenu", this._onContextMenu)), this.isTouch && (t.forEach(function (t) { m(t, "touchstart", e.onDragStart) }), m(n, "touchstart", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent() }, r.prototype.onPinchStart = function (t) { var e = this.options.pinchThreshold; this.isDrag && this.getMovement() > e || (e = new ln(on(t)), this.pinchFlag = !0, this._addStore(e), !1 === this.emit("pinchStart", b(b({ data: this.data, datas: this.data, angle: e.getAngle(), touches: this.getCurrentStore().getPositions() }, e.getPosition()), { inputEvent: t, isTrusted: this._isTrusted })) && (this.pinchFlag = !1)) }, r.prototype.onPinch = function (t, e) { var n; !this.flag || !this.pinchFlag || e.length < 2 || (n = this.getCurrentStore(), this.isPinch = !0, this.emit("pinch", b(b({ data: this.data, datas: this.data, movement: this.getMovement(e), angle: n.getAngle(e), rotation: n.getRotation(e), touches: n.getPositions(e), scale: n.getScale(e), distance: n.getDistance(e) }, n.getPosition(e)), { inputEvent: t, isTrusted: this._isTrusted }))) }, r.prototype.onPinchEnd = function (t) { var e, n; this.pinchFlag && (e = this.isPinch, this.isPinch = !1, this.pinchFlag = !1, n = this.getCurrentStore(), this.emit("pinchEnd", b(b({ data: this.data, datas: this.data, isPinch: e, touches: n.getPositions() }, n.getPosition()), { inputEvent: t }))) }, r.prototype.getCurrentStore = function () { return this.clientStores[0] }, r.prototype.moveClients = function (t, e, n) { var n = this._getPosition(t, n), r = this.isDrag, i = ((n.deltaX || n.deltaY) && (this.isDrag = !0), !1); return !r && this.isDrag && (i = !0), b(b({ data: this.data, datas: this.data }, n), { movement: this.getMovement(t), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: e, isTrusted: this._isTrusted, isFirstDrag: i }) }, r.prototype._addStore = function (t) { this.clientStores.splice(0, 0, t) }, r.prototype._getPosition = function (t, e) { var t = this.getCurrentStore().getPosition(t, e), e = this.clientStores.slice(1).reduce(function (t, e) { e = e.getPosition(); return t.distX += e.distX, t.distY += e.distY, t }, t), n = e.distX, e = e.distY; return b(b({}, t), { distX: n, distY: e }) }, r.prototype._attchDragEvent = function () { var t = this.options.container, e = { passive: !1 }; this.isMouse && (v(t, "mousemove", this.onDrag), v(t, "mouseup", this.onDragEnd)), this.isTouch && (v(t, "touchmove", this.onDrag, e), v(t, "touchend", this.onDragEnd, e), v(t, "touchcancel", this.onDragEnd, e)) }, r.prototype._dettachDragEvent = function () { var t = this.options.container; this.isMouse && (m(t, "mousemove", this.onDrag), m(t, "mouseup", this.onDragEnd)), this.isTouch && (m(t, "touchstart", this.onDragStart), m(t, "touchmove", this.onDrag), m(t, "touchend", this.onDragEnd), m(t, "touchcancel", this.onDragEnd)) }, r }($e); var dn = function (t) { for (var e = 5381, n = t.length; n;)e = 33 * e ^ t.charCodeAt(--n); return e >>> 0 }; function hn(t, e, n, r) { var i, o = document.createElement("style"); return o.setAttribute("type", "text/css"), o.setAttribute("data-styled-id", t), n.nonce && o.setAttribute("nonce", n.nonce), o.innerHTML = (i = t, t = e, n.original ? t : t.replace(/([^};{\s}][^};{]*|^\s*){/gm, function (t, e) { e = e.trim(); return (e ? pt(e) : [""]).map(function (t) { t = t.trim(); return 0 === t.indexOf("@") ? t : -1 < t.indexOf(":global") ? t.replace(/\:global/g, "") : -1 < t.indexOf(":host") ? "" + t.replace(/\:host/g, "." + i) : t ? "." + i + " " + t : "." + i }).join(", ") + " {" })), (r || document.head || document.body).appendChild(o), o } function gn(i) { var o, a = "rCS" + dn(i).toString(36), s = 0; return { className: a, inject: function (t, e) { void 0 === e && (e = {}); var n, r = function (t) { if (t && t.getRootNode) { t = t.getRootNode(); if (11 === t.nodeType) return t } }(t), t = 0 === s; return (r || t) && (n = hn(a, i, e, r)), t && (o = n), r || ++s, { destroy: function () { r ? (r.removeChild(n), n = null) : (0 < s && --s, 0 === s && o && (o.parentNode.removeChild(o), o = null)) } } } } } var vn = function (t, e) { return (vn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }; function mn(t, e) { function n() { this.constructor = t } vn(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) } var bn = function () { return (bn = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }).apply(this, arguments) }; var xn = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.injectResult = null, t.tag = "div", t } mn(t, e); var n = t.prototype; return n.render = function () { var t = this.props, e = t.className, e = void 0 === e ? "" : e, n = (t.cspNonce, t.portalContainer), t = function (t, e) { var n = {}; for (i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }(t, ["className", "cspNonce", "portalContainer"]), r = this.injector.className, i = this.tag, o = {}; return -1 < "simple-1.1.0".indexOf("simple") && n && (o = { portalContainer: n }), C(i, bn({ ref: M(this, "element"), "data-styled-id": r, className: e + " " + r }, o, t)) }, n.componentDidMount = function () { this.injectResult = this.injector.inject(this.element, { nonce: this.props.cspNonce }) }, n.componentWillUnmount = function () { this.injectResult.destroy(), this.injectResult = null }, n.getElement = function () { return this.element }, t }(Yt); function yn(n, t) { var r = gn(t); return function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.injector = r, t.tag = n, t } return mn(t, e), t }(xn) } var En = function (t, e) { return (En = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]) })(t, e) }; function Sn(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null"); function n() { this.constructor = t } En(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) } var Q = function () { return (Q = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }).apply(this, arguments) }; function tt(t, e, n) { if (n || 2 === arguments.length) for (var r, i = 0, o = e.length; i < o; i++)!r && i in e || ((r = r || Array.prototype.slice.call(e, 0, i))[i] = e[i]); return t.concat(r || Array.prototype.slice.call(e)) } function Cn(t, e) { var n; return Q({ events: {}, props: ((n = {})[t] = Boolean, n), name: t }, e) } var Mn = ["n", "w", "s", "e"], Dn = ["n", "w", "s", "e", "nw", "ne", "sw", "se"]; var wn, n, _n, r, Rn, i, o, e = void 0 === Tn && function () { var t; if ("undefined" != typeof navigator && navigator && navigator.userAgentData) return (t = (t = navigator.userAgentData).brands || t.uaList) && t.length }() ? (wn = ((i = navigator.userAgentData).uaList || i.brands).slice(), n = a && a.fullVersionList, _n = i.mobile || !1, r = wn[0], Rn = (a && a.platform || i.platform || navigator.platform).toLowerCase(), i = { name: r.brand, version: r.version, majorVersion: -1, webkit: !1, webkitVersion: "-1", chromium: !1, chromiumVersion: "-1", webview: !!ue(pe, wn).brand || de(ie()) }, r = { name: "unknown", version: "-1", majorVersion: -1 }, i.webkit = !i.chromium && ne(fe, function (t) { return ce(wn, t) }), o = ue(le, wn), i.chromium = !!o.brand, i.chromiumVersion = o.version, i.chromium || (o = ue(fe, wn), i.webkit = !!o.brand, i.webkitVersion = o.version), o = re(e, function (t) { return new RegExp("" + t.test, "g").exec(Rn) }), r.name = o ? o.id : "", a && (r.version = a.platformVersion), n && n.length ? (o = ue(t, n), i.name = o.brand || i.name, i.version = o.version || i.version) : (n = ue(t, wn), i.name = n.brand || i.name, i.version = n.brand && a ? a.uaFullVersion : n.version), i.webkit && (r.name = _n ? "ios" : "mac"), "ios" === r.name && i.webview && (i.version = "-1"), r.version = ae(r.version), i.version = ae(i.version), r.majorVersion = parseInt(r.version, 10), i.majorVersion = parseInt(i.version, 10), { browser: i, os: r, isMobile: _n, isHints: !0 }) : (o = ie(o = Tn), a = !!/mobi/g.exec(o), n = { name: "unknown", version: "-1", majorVersion: -1, webview: de(o), chromium: !1, chromiumVersion: "-1", webkit: !1, webkitVersion: "-1" }, i = { name: "unknown", version: "-1", majorVersion: -1 }, _n = (r = se(t, o)).preset, r = r.version, g = (Tn = se(e, o)).preset, Tn = Tn.version, t = se(le, o), n.chromium = !!t.preset, n.chromiumVersion = t.version, n.chromium || (t = se(fe, o), n.webkit = !!t.preset, n.webkitVersion = t.version), g && (i.name = g.id, i.version = Tn, i.majorVersion = parseInt(Tn, 10)), _n && (n.name = _n.id, n.version = r, n.webview && "ios" === i.name && "safari" !== n.name && (n.webview = !1)), n.majorVersion = parseInt(n.version, 10), { browser: n, os: i, isMobile: a, isHints: !1 }), On = e.browser.webkit, Pn = On && (le = "undefined" == typeof window ? { userAgent: "" } : window.navigator, !!(le = /applewebkit\/([^\s]+)/g.exec(le.userAgent.toLowerCase())) && parseFloat(le[1]) < 605), fe = e.browser.name, t = parseInt(e.browser.version, 10), g = e.browser.chromium, Tn = parseInt(e.browser.chromiumVersion, 10) || 0, Gn = g && 109 <= Tn, zn = "firefox" === fe, Bn = 612 <= parseInt(e.browser.webkitVersion, 10) || 15 <= t, kn = "moveable-", a = Dn.map(function (t) { var e = "", n = "", r = "center", i = "center"; return -1 < t.indexOf("n") && (e = "top: -20px;", i = "bottom"), -1 < t.indexOf("s") && (e = "top: 0px;", i = "top"), -1 < t.indexOf("w") && (n = "left: -20px;", r = "right"), -1 < t.indexOf("e") && (n = "left: 0px;", r = "left"), '.around-control[data-direction*="'.concat(t, '"] {\n        ').concat(n).concat(e, "\n        transform-origin: ").concat(r, " ").concat(i, ";\n    }") }).join("\n"), An = "\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n    outline: 1px solid transparent;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.around-control {\n    position: absolute;\n    will-change: transform;\n    width: calc(var(--moveable-control-padding, 20) * 1px);\n    height: calc(var(--moveable-control-padding, 20) * 1px);\n    left: -10px;\n    top: -10px;\n    box-sizing: border-box;\n    background: transparent;\n    z-index: 8;\n    cursor: alias;\n    transform-origin: center center;\n}\n".concat(a, "\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.edge {\n    z-index: 1;\n    background: transparent;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n").concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (t) { return '\n.direction[data-rotation="'.concat(t, '"], :global .view-control-rotation').concat(t, " {\n\t").concat((n = t = t, e = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(32 * (e = 1), 'px" height="').concat(32 * e, 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(').concat(n, 'deg);transform-origin: 16px 16px"></path></svg>'), n = 45 * Math.round(t / 45) % 180, t = "ns-resize", 135 == n ? t = "nwse-resize" : 45 == n ? t = "nesw-resize" : 90 == n && (t = "ew-resize"), "cursor:".concat(t, ";cursor: url('").concat(e, "') 16 16, ").concat(t, ";")), "\n}\n"); var e, n }).join("\n"), '\n\n.line.direction:before {\n    content: "";\n    position: absolute;\n    width: 100%;\n    height: calc(var(--moveable-line-padding, 0) * 1px);\n    bottom: 0;\n    left: 0;\n}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n').concat(Pn ? ':global svg *:before {\n\tcontent:"";\n\ttransform-origin: inherit;\n}' : "", "\n"), Fn = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], Nn = 1e-4, A = 1e-7, In = Math.pow(10, 10), jn = -In, Yn = { n: [0, -1], e: [1, 0], s: [0, 1], w: [-1, 0], nw: [-1, -1], ne: [1, -1], sw: [-1, 1], se: [1, 1] }, Xn = { n: [0, 1], e: [1, 3], s: [3, 2], w: [2, 0], nw: [0], ne: [1], sw: [2], se: [3] }, Wn = { n: 0, s: 180, w: 270, e: 90, nw: 315, ne: 45, sw: 225, se: 135 }, qn = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate", "waitToChangeTarget", "updateSelectors", "getTargets", "stopDrag"]; function Ln(t, e, n, r, i, o) { var n = null != (a = null == (a = e.gestos[o = void 0 === o ? "draggable" : o]) ? void 0 : a.move(n, t.inputEvent)) ? a : {}, a = n.originalDatas || n.datas, a = a[o] || (a[o] = {}); return Q(Q({}, i ? ni(e, n) : n), { isPinch: !!r, parentEvent: !0, datas: a, originalDatas: t.originalDatas }) } var Hn = function () { function t(t) { var e; this.ableName = t = void 0 === t ? "draggable" : t, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = { draggable: {} }, this.datas = ((e = {})[t] = {}, e) } var e = t.prototype; return e.dragStart = function (t, e) { this.isDrag = !1, this.isFlag = !1; var n = e.originalDatas; return (this.datas = n)[this.ableName] || (n[this.ableName] = {}), Q(Q({}, this.move(t, e.inputEvent)), { type: "dragstart" }) }, e.drag = function (t, e) { return this.move([t[0] - this.prevX, t[1] - this.prevY], e) }, e.move = function (t, e) { var n, r, i, o = !1; return this.isFlag ? (n = this.isDrag, r = this.prevX + t[0], i = this.prevY + t[1], (t[0] || t[1]) && (this.isDrag = !0), !n && this.isDrag && (o = !0)) : (this.prevX = t[0], this.prevY = t[1], this.startX = t[0], this.startY = t[1], r = t[0], i = t[1], this.isFlag = !0), { type: "drag", clientX: this.prevX = r, clientY: this.prevY = i, inputEvent: e, isFirstDrag: o, isDrag: this.isDrag, distX: r - this.startX, distY: i - this.startY, deltaX: t[0], deltaY: t[1], datas: this.datas[this.ableName], originalDatas: this.datas, parentEvent: !0, parentGesto: this } }, t }(); function Vn(t, e) { var n = e.clientX, r = e.clientY, e = e.datas, t = t.state, i = t.moveableClientRect, o = t.rootMatrix, a = t.is3d, t = t.pos1, o = z(ei(o, [n - i.left, r - i.top], a ? 4 : 3), t), n = tr({ datas: e, distX: o[0], distY: o[1] }); return [n[0], n[1]] } function Un(t, e) { var e = e.datas, t = t.state, n = t.allMatrix, r = t.beforeMatrix, i = t.is3d, o = t.left, a = t.top, s = t.origin, u = t.offsetMatrix, c = t.targetMatrix, t = t.transformOrigin, l = i ? 4 : 3; e.is3d = i, e.matrix = n, e.targetMatrix = c, e.beforeMatrix = r, e.offsetMatrix = u, e.transformOrigin = t, e.inverseMatrix = ge(n, l), e.inverseBeforeMatrix = ge(r, l), e.absoluteOrigin = me(J([o, a], s), l), e.startDragBeforeDist = G(e.inverseBeforeMatrix, e.absoluteOrigin, l), e.startDragDist = G(e.inverseMatrix, e.absoluteOrigin, l) } function $n(t, e) { var n, r, i, o, a, s, u, c, l, f, p, d, h, g = t.datas, t = t.originalDatas.beforeRenderable, v = g.transformIndex, m = t.nextTransforms, b = m.length, x = t.nextTransformAppendedIndexes, y = 0, m = (-1 === v ? ("translate" === e ? y = 0 : "rotate" === e && (y = mt(m, function (t) { return t.match(/scale\(/g) })), -1 === y && (y = m.length), g.transformIndex = y) : y = bt(x, function (t) { return t.index === v && t.functionName === e }) ? v : v + x.filter(function (t) { return t.index < v }).length, n = y, r = (m = m).slice(0, n < 0 ? void 0 : n), i = m.slice(0, n < 0 ? void 0 : n + 1), o = m[n] || "", a = n < 0 ? [] : m.slice(n), n = n < 0 ? [] : m.slice(n + 1), s = Be(r), u = Be(i), c = Be([o]), l = Be(a), f = Be(n), E = ze(s), S = ze(u), p = ze(l), d = ze(f), h = K(E, p, 4), { transforms: m, beforeFunctionMatrix: E, beforeFunctionMatrix2: S, targetFunctionMatrix: ze(c), afterFunctionMatrix: p, afterFunctionMatrix2: d, allFunctionMatrix: h, beforeFunctions: s, beforeFunctions2: u, targetFunction: c[0], afterFunctions: l, afterFunctions2: f, beforeFunctionTexts: r, beforeFunctionTexts2: i, targetFunctionText: o, afterFunctionTexts: a, afterFunctionTexts2: n }), E = m.targetFunction, S = "rotate" === e ? "rotateZ" : e; g.beforeFunctionTexts = m.beforeFunctionTexts, g.afterFunctionTexts = m.afterFunctionTexts, g.beforeTransform = m.beforeFunctionMatrix, g.beforeTransform2 = m.beforeFunctionMatrix2, g.targetTansform = m.targetFunctionMatrix, g.afterTransform = m.afterFunctionMatrix, g.afterTransform2 = m.afterFunctionMatrix2, g.targetAllTransform = m.allFunctionMatrix, E.functionName === S ? (g.afterFunctionTexts.splice(0, 1), g.isAppendTransform = !1) : y < b && (g.isAppendTransform = !0, t.nextTransformAppendedIndexes = tt(tt([], x, !0), [{ functionName: e, index: y, isAppend: !0 }], !1)) } function Zn(t, e, n) { return "".concat(t.beforeFunctionTexts.join(" "), " ").concat(t.isAppendTransform ? n : e, " ").concat(t.afterFunctionTexts.join(" ")) } function Kn(t) { var e = t.datas, t = Qn({ datas: e, distX: t.distX, distY: t.distY }); return G(Jn(e, function (t, e) { for (var n = W(e), r = 0; r < e - 1; ++r)n[e * (e - 1) + r] = t[r] || 0; return n }([t[0], t[1]], 4)), me([0, 0, 0], 4), 4) } function Jn(t, e, n) { var r = t.beforeTransform, i = t.afterTransform, o = t.beforeTransform2, a = t.afterTransform2, t = t.targetAllTransform, e = n ? K(t, e, 4) : K(e, t, 4), t = K(ge(n ? o : r, 4), e, 4); return K(t, ge(n ? a : i, 4), 4) } function Qn(t) { var e = t.datas, n = t.distX, t = t.distY, r = e.inverseBeforeMatrix, i = e.is3d, o = e.startDragBeforeDist, i = i ? 4 : 3; return z(G(r, J(e.absoluteOrigin, [n, t]), i), o) } function tr(t, e) { var n = t.datas, r = t.distX, t = t.distY, i = n.inverseBeforeMatrix, o = n.inverseMatrix, a = n.is3d, s = n.startDragBeforeDist, u = n.startDragDist, a = a ? 4 : 3; return z(G(e ? i : o, J(n.absoluteOrigin, [r, t]), a), e ? s : u) } function er(t) { var e = []; return 0 <= t[1] && (0 <= t[0] && e.push(3), t[0] <= 0 && e.push(2)), t[1] <= 0 && (0 <= t[0] && e.push(1), t[0] <= 0 && e.push(0)), e } function j(t, e) { var n = (e[0] + 1) / 2, e = (e[1] + 1) / 2, r = [$(t[0][0], t[1][0], n, 1 - n), $(t[0][1], t[1][1], n, 1 - n)], t = [$(t[2][0], t[3][0], n, 1 - n), $(t[2][1], t[3][1], n, 1 - n)]; return [$(r[0], t[0], e, 1 - e), $(r[1], t[1], e, 1 - e)] } function nr(t, e, n, r) { return K(t, br(e, r, n), r) } function rr(n) { var r = sr(n); return { setTransform: function (t, e) { void 0 === e && (e = -1), r.startTransforms = w(t) ? t : ft(t), or(n, e) }, setTransformIndex: function (t) { or(n, t) } } } function ir(t, e) { or(t, mt(sr(t).startTransforms, function (t) { return 0 === t.indexOf("".concat(e, "(")) })) } function or(t, e) { var n = sr(t), t = t.datas; -1 !== (t.transformIndex = e) && (n = n.startTransforms[e]) && (e = Be([n]), t.startValue = e[0].functionValue) } function ar(t, e) { sr(t).nextTransforms = ft(e) } function sr(t) { return t.originalDatas.beforeRenderable } function ur(t) { return t.originalDatas.beforeRenderable.nextTransforms } function cr(t) { return ur(t).join(" ") } function lr(t) { return sr(t).nextStyle } function fr(t, e, n, r, i) { ar(i, e); t = X.drag(t, Ln(i, t.state, n, r, !1)), n = t ? t.transform : e; return Q(Q({ transform: e, drag: t }, et({ transform: n }, i)), { afterTransform: n }) } function pr(t, e, n, r, i) { var o = t.state, a = o.left, o = o.top, s = t.props.groupable; u = t.state, c = i, l = u.transformOrigin, f = u.offsetMatrix, u = u.is3d, p = i.beforeTransform, c = i.afterTransform, u = u ? 4 : 3; var u, c, l, f, p, i = s ? a : 0, a = s ? o : 0, s = z(r, hr(t, n, nr(f, be(K(K(p, Ge([e]), 4), c, 4), 4, u), l, u))); return z(s, [i, a]) } function dr(t, e, n) { return [t[0] / (e / 2) - 1, t[1] / (n / 2) - 1] } function hr(t, e, n) { void 0 === n && (n = t.state.allMatrix); var t = t.state, r = t.width, i = t.height, t = t.is3d; return F(n, [r / 2 * (1 + e[0]), i / 2 * (1 + e[1])], t ? 4 : 3) } function gr(t, e, n, r, i, o) { var a = t.props.groupable, t = t.state, s = t.transformOrigin, u = t.offsetMatrix, c = t.is3d, l = t.width, f = t.height, p = t.left, d = t.top, h = o.fixedDirection, o = o.nextTargetMatrix || t.targetMatrix, t = c ? 4 : 3; g = e, v = n, void 0 === (m = l) && (m = g), void 0 === (b = f) && (b = v), void 0 === (x = s) && (x = [0, 0]); var g, v, m, b, x, c = a ? p : 0, l = a ? d : 0, s = nr(u, o, (f = i) ? f.map(function (t, e) { var n = ht(t), r = n.value, n = n.unit, i = e ? b : m, o = e ? v : g; return "%" === t || isNaN(r) ? o * (i ? x[e] / i : 0) : "%" !== n ? r : o * r / 100 }) : x, t); return p = r, a = h, d = j(Rr(d = s, e, n, t), a), z([p[0] - d[0], p[1] - d[1]], [c, l]) } function vr(t, e) { return j(Y(t.state), e) } function B() { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return function (e) { for (var t = [], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; return t.map(function (t) { return t.split(" ").map(function (t) { return t ? "" + e + t : "" }).join(" ") }).join(" ") }.apply(void 0, tt([kn], t, !1)) } function mr(t) { t() } function br(t, e, n) { return xe(e, Pe(n, e), t, Pe(n.map(function (t) { return -t }), e)) } function xr(r) { return yr($r(r, ":before")).map(function (t, e) { var t = ht(t), n = t.value, t = t.unit; return n * (n = r, e = 0 === e, "%" === t ? _r(n.ownerSVGElement)[e ? "width" : "height"] / 100 : 1) }) } function yr(t) { t = t.transformOrigin; return t ? t.split(" ") : ["0", "0"] } function Er(t, e) { var n = (e = void 0 === e ? $r(t) : e).transform; if (n && "none" !== n) return e.transform; if ("transform" in t) { var r = t.transform.baseVal; if (!r) return ""; var i = r.length; if (!i) return ""; for (var o = [], a = 0; a < i; ++a)!function (t) { var e = r[t].matrix; o.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function (t) { return e[t] }).join(", "), ")")) }(a); return o.join(" ") } return "" } function Sr(t, e, n, r, i) { for (var o, a, s, u = t && t.ownerDocument ? t.ownerDocument : document, c = u.documentElement || u.body, l = !1, f = (s = !t || n ? t : (u = null == (u = null == t ? void 0 : t.assignedSlot) ? void 0 : u.parentElement, a = t.parentElement, u ? (l = !0, o = a, u) : a), !1), p = t === e || s === e, d = "relative", h = 1, g = parseFloat(null == (u = i) ? void 0 : u.zoom) || 1, v = null == i ? void 0 : i.position; s && s !== c;) { e === s && (p = !0); var m = $r(s), b = s.tagName.toLowerCase(), x = Er(s, m), y = m.willChange, E = parseFloat(m.zoom) || 1, d = m.position; if (r && 1 !== E) { h = E; break } if (!n && r && 1 !== g && v && "absolute" !== v || "svg" === b || "static" !== d || x && "none" !== x || "transform" === y) break; E = null == (m = null == t ? void 0 : t.assignedSlot) ? void 0 : m.parentNode, b = s.parentNode, x = (E && (l = !0, o = b), E || b); if (x && 11 === x.nodeType) { s = x.host, f = !0; break } s = x, d = "relative" } return { offsetZoom: h, hasSlot: l, parentSlotElement: o, isCustomElement: f, isStatic: "static" === d, isEnd: p || !s || s === c, offsetParent: s || c } } function Cr(t, e, n) { var r, i, o = t.tagName.toLowerCase(), a = t.offsetLeft, s = t.offsetTop, u = it(a), c = !u; return c || "svg" === o ? i = (r = yr(n).map(function (t) { return parseFloat(t) })).slice() : (i = (r = Pn ? xr(t) : yr(n).map(function (t) { return parseFloat(t) })).slice(), c = !0, a = (n = function (t, e, n) { if (!t.getBBox || !n && "g" === t.tagName.toLowerCase()) return [0, 0, 0, 0]; var n = t.getBBox(), t = _r(t.ownerSVGElement), r = n.x - t.x, n = n.y - t.y; return [r, n, e[0] - r, e[1] - n] }(t, r, t === e && "g" === e.tagName.toLowerCase()))[0], s = n[1], r[0] = n[2], r[1] = n[3]), { tagName: o, isSVG: u, hasOffset: c, offset: [a || 0, s || 0], origin: r, targetOrigin: i } } function Mr(t, e, n) { void 0 === n && (n = $r(t)); var t = $r(document.body), r = t.position; if (!(e || r && "static" !== r)) return [0, 0]; e = parseInt(t.marginLeft, 10), r = parseInt(t.marginTop, 10); return "absolute" === n.position && ("auto" === n.top && "auto" === n.bottom || (r = 0), "auto" === n.left && "auto" === n.right || (e = 0)), [e, r] } function Dr(t) { t.forEach(function (t) { var e = t.matrix; e && (t.matrix = be(e, 3, 4)) }) } function wr(t, e) { return void 0 === e && (e = 9 < t.length), "".concat(e ? "matrix3d" : "matrix", "(").concat(ye(t, !e).join(","), ")") } function _r(t) { var e = t.clientWidth, n = t.clientHeight; if (!t) return { x: 0, y: 0, width: 0, height: 0, clientWidth: e, clientHeight: n }; t = t.viewBox, t = t && t.baseVal || { x: 0, y: 0, width: 0, height: 0 }; return { x: t.x, y: t.y, width: t.width || e, height: t.height || n, clientWidth: e, clientHeight: n } } function F(t, e, n) { return G(t, me(e, n), n) } function Rr(e, t, n, r) { return [[0, 0], [t, 0], [0, n], [t, n]].map(function (t) { return F(e, t, r) }) } function Or(t) { var e = t.map(function (t) { return t[0] }), t = t.map(function (t) { return t[1] }), n = Math.min.apply(Math, e), r = Math.min.apply(Math, t), e = Math.max.apply(Math, e), t = Math.max.apply(Math, t); return { left: n, top: r, right: e, bottom: t, width: e - n, height: t - r } } function Pr(t, e, n, r) { return Or(Rr(t, e, n, r)) } function Tr(t, e, n, r) { var i = 16 === t.length ? 4 : 3, n = Rr(t, n, r, i), r = n[0], o = r[0], r = r[1], a = n[1], s = a[0], a = a[1], u = n[2], c = u[0], u = u[1], n = n[3], l = n[0], n = n[1], e = F(t, e, i), f = e[0], e = e[1], p = Math.min(o, s, c, l), d = Math.min(r, a, u, n); return { left: p, top: d, right: Math.max(o, s, c, l), bottom: Math.max(r, a, u, n), origin: [f - p || 0, e - d || 0], pos1: [o - p || 0, r - d || 0], pos2: [s - p || 0, a - d || 0], pos3: [c - p || 0, u - d || 0], pos4: [l - p || 0, n - d || 0], direction: Dt(Rr(t, 100, 100, i)) } } function Gr(t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) } function zr(t, e) { return Gr([e[0] - t[0], e[1] - t[1]]) } function Br(t, e, n, r) { void 0 === n && (n = 1), void 0 === r && (r = N(t, e)); e = zr(t, e); return { transform: "translateY(-50%) translate(".concat(t[0], "px, ").concat(t[1], "px) rotate(").concat(r, "rad) scaleY(").concat(n, ")"), width: "".concat(e, "px") } } function kr(t, e) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; var i = n.length, o = n.reduce(function (t, e) { return t + e[0] }, 0) / i, i = n.reduce(function (t, e) { return t + e[1] }, 0) / i; return { transform: "translateZ(0px) translate(".concat(o, "px, ").concat(i, "px) rotate(").concat(t, "rad) scale(").concat(e, ")") } } function Ar(t, e) { e = t[e]; return ot(e) ? Q(Q({}, t), e) : t } function Fr(t, e) { void 0 === e && (e = t ? $r(t) : null); var n, r, i, o, a, s, u, c, l, f = t && !it(t.offsetWidth), p = 0, d = 0, h = 0, g = 0, v = 0, m = 0, b = 0, x = 0, y = 0, E = 0, S = 0, C = 0, M = 1 / 0, D = 1 / 0, w = 1 / 0, _ = 1 / 0, R = 0, O = 0, P = !1; return t && (g = f || "svg" === t.tagName.toLowerCase() ? (f = t.style, n = "border-box" === e.boxSizing, o = parseFloat(e.borderLeftWidth) || 0, i = parseFloat(e.borderRightWidth) || 0, a = parseFloat(e.borderTopWidth) || 0, s = parseFloat(e.borderBottomWidth) || 0, o = (r = (parseFloat(e.paddingLeft) || 0) + (parseFloat(e.paddingRight) || 0)) + (o + i), a = (i = (parseFloat(e.paddingTop) || 0) + (parseFloat(e.paddingBottom) || 0)) + (a + s), s = e.position, c = u = 0, "clientLeft" in t && (l = null, (l = "absolute" === s ? Sr(t, document.body).offsetParent : t.parentElement) && (s = $r(l), u = parseFloat(s.width), c = parseFloat(s.height))), y = Math.max(r, Z(e.minWidth, u) || 0), E = Math.max(i, Z(e.minHeight, c) || 0), M = Z(e.maxWidth, u), D = Z(e.maxHeight, c), isNaN(M) && (M = 1 / 0), isNaN(D) && (D = 1 / 0), R = Z(f.width, 0) || 0, O = Z(f.height, 0) || 0, v = parseFloat(e.width) || 0, m = parseFloat(e.height) || 0, h = p = b = Math.abs(v - R) < 1 ? St(y, R || v, M) : v, g = d = x = Math.abs(m - O) < 1 ? St(E, O || m, D) : m, n ? (w = M, _ = D, S = y, C = E, b = p - o, x = d - a) : (w = M + o, _ = D + a, S = y + o, C = E + a, p = b + o, d = x + a), h = b + r, x + i) : (P = !0, v = p = (l = t.getBBox()).width, m = d = l.height, h = b = p, x = d)), { svg: P, offsetWidth: p, offsetHeight: d, clientWidth: h, clientHeight: g, contentWidth: b, contentHeight: x, inlineCSSWidth: R, inlineCSSHeight: O, cssWidth: v, cssHeight: m, minWidth: y, minHeight: E, maxWidth: M, maxHeight: D, minOffsetWidth: S, minOffsetHeight: C, maxOffsetWidth: w, maxOffsetHeight: _ } } function Nr(t, e) { return N(0 < e ? t[0] : t[1], 0 < e ? t[1] : t[0]) } function Ir() { return { left: 0, top: 0, width: 0, height: 0, right: 0, bottom: 0, clientLeft: 0, clientTop: 0, clientWidth: 0, clientHeight: 0, scrollWidth: 0, scrollHeight: 0 } } function jr(t, e) { var n = t === document.body || t === document.documentElement, r = { clientLeft: t.clientLeft, clientTop: t.clientTop, clientWidth: t.clientWidth, clientHeight: t.clientHeight, scrollWidth: t.scrollWidth, scrollHeight: t.scrollHeight, overflow: !1 }; return n && (r.clientHeight = Math.max(e.height, r.clientHeight), r.scrollHeight = Math.max(e.height, r.scrollHeight)), r.overflow = "visible" !== $r(t).overflow, Q(Q({}, e), r) } function Yr(t, e, n, r) { var i = t.left, o = t.right, a = t.top, t = t.bottom, s = e.top, e = e.left, e = { left: e + i, top: s + a, right: e + o, bottom: s + t, width: o - i, height: t - a }; return n && r ? jr(n, e) : e } function Xr(t, e) { var n = 0, r = 0, i = 0, o = 0, a = (t && (n = (a = t.getBoundingClientRect()).left, r = a.top, i = a.width, o = a.height), { left: n, top: r, width: i, height: o, right: n + i, bottom: r + o }); return t && e ? jr(t, a) : a } function Wr(t, e, n, r) { return t || (e ? [0, 0] : qr(n.target, r)) } function qr(t, e) { if (t) { var n = t.getAttribute("data-rotation") || "", t = t.getAttribute("data-direction"); if (e.deg = n, t) return e = [0, 0], -1 < t.indexOf("w") && (e[0] = -1), -1 < t.indexOf("e") && (e[0] = 1), -1 < t.indexOf("n") && (e[1] = -1), -1 < t.indexOf("s") && (e[1] = 1), e } } function Lr(t, e) { return [J(e, t[0]), J(e, t[1]), J(e, t[2]), J(e, t[3])] } function Y(t) { var e = t.left, n = t.top; return Lr([t.pos1, t.pos2, t.pos3, t.pos4], [e, n]) } function Hr(t, e) { var n; null != (n = t[e]) && n.unset(), t[e] = null } function et(e, t) { return t && ((t = sr(t)).nextStyle = Q(Q({}, t.nextStyle), e)), { style: e, cssText: Et(e).map(function (t) { return "".concat(gt(t, "-"), ": ").concat(e[t], ";") }).join("") } } function Vr(t, e, n) { var r = e.afterTransform || e.transform; return Q(Q({}, et(Q(Q(Q({}, t.style), e.style), { transform: r }), n)), { afterTransform: r, transform: t.transform }) } function nt(t, e, n, r) { var i = e.datas, n = (i.datas || (i.datas = {}), Q(Q({}, n), { target: t.state.target, clientX: e.clientX, clientY: e.clientY, inputEvent: e.inputEvent, currentTarget: t, moveable: t, datas: i.datas, isFirstDrag: !!e.isFirstDrag, isTrusted: !1 !== e.isTrusted, stopAble: function () { i.isEventStart = !1 }, stopDrag: function () { var t; null != (t = e.stop) && t.call(e) } })); return i.isStartEvent ? r || (i.lastEvent = n) : i.isStartEvent = !0, n } function d(t, e, n) { var r = e.datas, i = ("isDrag" in n ? n : e).isDrag; return r.datas || (r.datas = {}), Q(Q({ isDrag: i }, n), { moveable: t, target: t.state.target, clientX: e.clientX, clientY: e.clientY, inputEvent: e.inputEvent, currentTarget: t, lastEvent: r.lastEvent, isDouble: e.isDouble, datas: r.datas, isFirstDrag: !!e.isFirstDrag }) } function Ur(t, e, n) { t._emitter.on(e, n) } function rt(t, e, n, r) { return t.triggerEvent(e, n, r) } function $r(t, e) { return window.getComputedStyle(t, e) } function Zr(t, n, r) { var i = {}, o = {}; return t.filter(function (e) { var t = e.name; if (i[t] || !n.some(function (t) { return e[t] })) return !1; if (!r && e.ableGroup) { if (o[e.ableGroup]) return !1; o[e.ableGroup] = !0 } return i[t] = !0 }) } function Kr(t, e) { return t === e || null == t && null == e } function Jr(i, o) { var a = [], s = []; return i.forEach(function (t, e) { var e = o(t, e, i), n = s.indexOf(e), r = a[n] || []; -1 === n && (s.push(e), a.push(r)), r.push(t) }), a } function Qr(t) { return t.reduce(function (t, e) { return t.concat(e) }, []) } function ti() { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return t.sort(function (t, e) { return Math.abs(e) - Math.abs(t) }), t[0] } function ei(t, e, n) { return G(ge(t, n), me(e, n), n) } function ni(t, e) { var n = t.is3d, t = ei(t.rootMatrix, [e.distX, e.distY], n ? 4 : 3); return e.distX = t[0], e.distY = t[1], e } function ri(t, e, n, r, i) { return z(F(t, J(n, e), i), r) } function ii(t, e, n) { return n ? "".concat(t / e * 100, "%") : "".concat(t, "px") } function oi(t) { return Math.abs(t) <= A ? 0 : t } function ai(i) { return function (t) { if (!t.isDragging(i)) return ""; e = i, r = (t = t).targetGesto, t = t.controlGesto; var e, n, r = ((n = !(n = null != r && r.isFlag() ? r.getEventData()[e] : n) && null != t && t.isFlag() ? t.getEventData()[e] : n) || {}).deg; return r ? B("view-control-rotation".concat(r)) : "" } } function si(r, i) { return void 0 === i && (i = [r]), function (t, e) { if (e.isRequest) return !!i.some(function (t) { return e.requestAble === t }) && e.parentDirection; var n = e.inputEvent.target; return T(n, B("direction")) && (!r || T(n, B(r))) } } function ui(t) { var e, n = {}; for (e in t) n[t[e]] = e; return n } function ci(t, e) { return t ? t instanceof Element ? t : x(t) ? e ? document.querySelector(t) : t : st(t) ? t() : "current" in t ? t.current : t : null } function li(t, n) { return t ? ((e = t) && ot(e) && (!(e instanceof Element) && (w(e) || "length" in e)) ? [].slice.call(t) : [t]).reduce(function (t, e) { return x(e) && n ? tt(tt([], t, !0), [].slice.call(document.querySelectorAll(e)), !0) : (w(e) ? t.push(li(e, n)) : t.push(ci(e, n)), t) }, []) : []; var e } function fi(t, e) { var n = t.rootMatrix, t = t.is3d, n = ge(n, t ? 4 : 3); return (n = t ? n : be(n, 3, 4))[12] = 0, n[13] = 0, n[14] = 0, n = (t = G(t = n, [(n = e)[0], n[1] || 0, n[2] || 0, 1], 4))[3] || 1, [t[0] / n, t[1] / n, t[2] / n] } function pi(t, e, n, r, i) { var o, a, s = t[0], t = t[1], u = 0, c = 0; return i && s && t ? (i = N([0, 0], e), o = N([0, 0], r), a = Gr(e), i = Math.cos(i - o) * a, r[0] ? c = r[1] ? (o = 2 * r[0] * s, a = 2 * r[1] * t, s = Gr([o + e[0], a + e[1]]) - Gr([o, a]), t = N([0, 0], [n, 1]), u = Math.cos(t) * s, Math.sin(t) * s) : (u = i) / n : u = (c = i) * n) : (u = r[0] * e[0], c = r[1] * e[1]), [u, c] } function di(e, t, n, r) { var i, o, a = n.ratio, s = n.startOffsetWidth, u = n.startOffsetHeight, c = 0, l = 0, f = r.distX, p = r.distY, d = r.parentDistance, h = r.parentDist, r = r.parentScale, g = n.fixedDirection, v = [0, 1].map(function (t) { return Math.abs(e[t] - g[t]) }), m = [0, 1].map(function (t) { t = v[t]; return t = 0 !== t ? 2 / t : t }); return h ? (c = h[0], l = h[1], t && (c ? l = l || c / a : c = l * a)) : l = r ? (c = (r[0] - 1) * s, (r[1] - 1) * u) : d ? (c = d / (i = Gr([h = s * v[0], r = u * v[1]])) * h * m[0], d / i * r * m[1]) : (o = tr({ datas: n, distX: f, distY: p }), c = (h = pi([s, u], o = m.map(function (t, e) { return o[e] * t }), a, e, t))[0], h[1]), { distWidth: c, distHeight: l } } function hi(t, e, n) { var t = function t(e, n) { if (n) { if ("left" === e) return { x: "0%", y: "50%" }; if ("top" === e) return { x: "50%", y: "50%" }; if ("center" === e) return { x: "50%", y: "50%" }; if ("right" === e) return { x: "100%", y: "50%" }; if ("bottom" === e) return { x: "50%", y: "100%" }; var r = (n = e.split(" "))[0], n = n[1], r = t(r || ""), n = t(n || ""), r = Q(Q({}, r), n), n = { x: "50%", y: "50%" }; return r.x && (n.x = r.x), r.y && (n.y = r.y), r.value && (r.x && !r.y && (n.y = r.value), !r.x && r.y && (n.x = r.value)), n } return "left" === e ? { x: "0%" } : "right" === e ? { x: "100%" } : "top" === e ? { y: "0%" } : "bottom" === e ? { y: "100%" } : e ? "center" === e ? { value: "50%" } : { value: e } : {} }(t, !0), r = t.x, t = t.y; return [Z(r, e) || 0, Z(t, n) || 0] } le = Cn("pinchable", { events: { onPinchStart: "pinchStart", onPinch: "pinch", onPinchEnd: "pinchEnd", onPinchGroupStart: "pinchGroupStart", onPinchGroup: "pinchGroup", onPinchGroupEnd: "pinchGroupEnd" }, dragStart: function () { return !0 }, pinchStart: function (n, r) { var t = r.datas, e = r.targets, i = r.angle, o = r.originalDatas, a = n.props, s = a.pinchable, a = a.ables; if (!s) return !1; var u = "onPinch".concat(e ? "Group" : "", "Start"), c = "drag".concat(e ? "Group" : "", "ControlStart"), a = (!0 === s ? n.controlAbles : a.filter(function (t) { return -1 < s.indexOf(t.name) })).filter(function (t) { return t.canPinch && t[c] }), l = nt(n, r, {}), e = (e && (l.targets = e), rt(n, u, l)), u = (t.isPinch = !1 !== e, t.ables = a, t.isPinch); return !!u && (a.forEach(function (t) { var e; o[t.name] = o[t.name] || {}, t[c] && (e = Q(Q({}, r), { datas: o[t.name], parentRotate: i, isPinch: !0 }), t[c](n, e)) }), n.state.snapRenderInfo = { request: r.isRequest, direction: [0, 0] }, u) }, pinch: function (e, n) { var r, i, t = n.datas, o = n.scale, a = n.distance, s = n.originalDatas, u = n.inputEvent, c = n.targets, l = n.angle; if (t.isPinch) return r = a * (1 - 1 / o), a = nt(e, n, {}), c && (a.targets = c), o = "onPinch".concat(c ? "Group" : ""), rt(e, o, a), o = t.ables, i = "drag".concat(c ? "Group" : "", "Control"), o.forEach(function (t) { t[i] && t[i](e, Q(Q({}, n), { datas: s[t.name], inputEvent: u, parentDistance: r, parentRotate: l, isPinch: !0 })) }), a }, pinchEnd: function (e, n) { var t, r, i, o = n.datas, a = n.isPinch, s = n.inputEvent, u = n.targets, c = n.originalDatas; if (o.isPinch) return r = "onPinch".concat(u ? "Group" : "", "End"), t = d(e, n, { isDrag: a }), u && (t.targets = u), rt(e, r, t), r = o.ables, i = "drag".concat(u ? "Group" : "", "ControlEnd"), r.forEach(function (t) { t[i] && t[i](e, Q(Q({}, n), { isDrag: a, datas: c[t.name], inputEvent: s, isPinch: !0 })) }), a }, pinchGroupStart: function (t, e) { return this.pinchStart(t, Q(Q({}, e), { targets: t.props.targets })) }, pinchGroup: function (t, e) { return this.pinch(t, Q(Q({}, e), { targets: t.props.targets })) }, pinchGroupEnd: function (t, e) { return this.pinchEnd(t, Q(Q({}, e), { targets: t.props.targets })) } }); function gi(t, n, r) { var e = r.originalDatas, e = (e.groupable = e.groupable || {}, e.groupable), i = (e.childDatas = e.childDatas || [], e.childDatas); return t.moveables.map(function (t, e) { return i[e] = i[e] || {}, i[e][n] = i[e][n] || {}, Q(Q({}, r), { datas: i[e][n], originalDatas: i[e] }) }) } function vi(t, a, s, u, e, c, l) { var f = !!s.match(/Start$/g), p = !!s.match(/End$/g), d = e.isPinch, h = e.datas, e = gi(t, a.name, e), g = t.moveables, t = e.map(function (t, e) { var n = g[e], r = n.state, i = r.gestos, o = t; if (f) o = new Hn(l).dragStart(u, t); else { if (i[l] || (i[l] = h.childGestos[e]), !i[l]) return; o = Ln(t, r, u, d, c, l) } e = a[s](n, Q(Q({}, o), { parentFlag: !0 })); return p && (i[l] = null), e }); return f && (h.childGestos = g.map(function (t) { return t.state.gestos[l] })), t } function mi(t, i, o, e, a, s) { void 0 === a && (a = function (t, e) { return e }); var u = !!o.match(/End$/g), e = gi(t, i.name, e), c = t.moveables; return e.map(function (t, e) { var n = c[e], r = a(n, t), r = i[o](n, Q(Q({}, r), { parentFlag: !0 })); return r && s && s(n, t, r, e), u && (n.state.gestos = {}), r }) } var bi = ["left", "right", "center"], xi = ["top", "bottom", "middle"], yi = { start: "left", end: "right", center: "center" }, Ei = { start: "top", end: "bottom", center: "middle" }; function Si(t, e) { var n = t.props, r = n.snappable, i = n.bounds, o = n.innerBounds, a = n.verticalGuidelines, s = n.horizontalGuidelines, u = n.snapGridWidth, n = n.snapGridHeight, t = t.state, c = t.guidelines, t = t.enableSnap; return r && t && !(e && !0 !== r && r.indexOf(e) < 0) && !!(u || n || i || o || c && c.length || a && a.length || s && s.length) } function Ci(t) { return !1 === t ? {} : !0 !== t && t ? t : { left: !0, right: !0, top: !0, bottom: !0 } } function Mi(t, e) { var n = function (t, e) { var n, r = Ci(t), i = {}; for (n in r) n in e && r[n] && (i[n] = e[n]); return i }(t, e), t = xi.filter(function (t) { return t in n }), e = bi.filter(function (t) { return t in n }); return { horizontal: t.map(function (t) { return n[t] }), vertical: e.map(function (t) { return n[t] }) } } function Di(t, e, n, r) { r = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; for (var n = t.length - 1, r = 0; r < n; ++r) { var i = t[r]; if (!it(i)) return i } return t[n] }(r, t.props.snapThreshold, 5); return wi(t.state.guidelines, e, n, r) } function wi(t, e, n, r) { return { vertical: Oi(t, "vertical", e, r), horizontal: Oi(t, "horizontal", n, r) } } function _i(t, e, n) { e = Mi(t.props.snapDirections, e); return Di(t, e.vertical, e.horizontal, n) } function Ri(t) { var e = t.isSnap; if (!e) return { isSnap: !1, offset: 0, dist: -1, pos: 0, guideline: null }; var t = t.posInfos[0], n = t.guidelineInfos[0], r = n.offset, i = n.dist, n = n.guideline; return { isSnap: e, offset: r, dist: i, pos: t.pos, guideline: n } } function Oi(r, i, t, o) { if (!r || !r.length) return { isSnap: !1, index: -1, posInfos: [] }; var a = "vertical" === i ? 0 : 1, t = t.map(function (n, t) { var e = r.map(function (t) { var e = t.pos, e = n - e[a]; return { offset: e, dist: Math.abs(e), guideline: t } }).filter(function (t) { var e = t.guideline, t = t.dist; return !(e.type !== i || o < t) }).sort(function (t, e) { return t.dist - e.dist }); return { pos: n, index: t, guidelineInfos: e } }).filter(function (t) { return 0 < t.guidelineInfos.length }).sort(function (t, e) { return t.guidelineInfos[0].dist - e.guidelineInfos[0].dist }), e = 0 < t.length; return { isSnap: e, index: e ? t[0].index : -1, posInfos: t } } function Pi(t, e, n, r) { void 0 === r && (r = 1); var i, o = []; if (n[0] && n[1]) o = [n, [-n[0], n[1]], [n[0], -n[1]]].map(function (t) { return j(e, t) }); else if (n[0] || n[1]) t.props.keepRatio ? o = [[-1, -1], [-1, 1], [1, -1], [1, 1], n].map(function (t) { return j(e, t) }) : (i = e, 1 < (o = er(n).map(function (t) { return i[t] })).length && o.push([(o[0][0] + o[1][0]) / 2, (o[0][1] + o[1][1]) / 2])); else for (var a = [e[0], e[1], e[3], e[2], e[0]], s = 0; s < 4; ++s)o.push(a[s]), o.push([(a[s][0] + a[s + 1][0]) / 2, (a[s][1] + a[s + 1][1]) / 2]); return Di(t, o.map(function (t) { return t[0] }), o.map(function (t) { return t[1] }), r) } function Ti(t, e) { var n = Math.abs(t.offset), r = Math.abs(e.offset); return t.isBound && e.isBound ? r - n : t.isBound ? -1 : e.isBound ? 1 : t.isSnap && e.isSnap ? r - n : t.isSnap ? -1 : e.isSnap || n < A ? 1 : r < A ? -1 : n - r } function Gi(t, a) { return t.slice().sort(function (t, e) { var n = t.sign[a], r = e.sign[a], i = t.offset[a], o = e.offset[a]; return n ? r ? Ti({ isBound: t.isBound, isSnap: t.isSnap, offset: i }, { isBound: e.isBound, isSnap: e.isSnap, offset: o }) : -1 : 1 })[0] } function zi(t, e) { var n = Mt([e[0][0], e[1][0]]), e = Mt([e[0][1], e[1][1]]); return { vertical: n <= t[0], horizontal: e <= t[1] } } function Bi(t, e) { var n, r = e[0], e = e[1], i = e[0] - r[0], e = e[1] - r[1]; return Math.abs(i) < A && (i = 0), Math.abs(e) < A && (e = 0), e = i ? (n = e ? e / i * (t[0] - r[0]) + r[1] : r[1], t[1]) : (n = r[0], t[0]), n - e } function ki(t, e, n, r) { return void 0 === r && (r = A), t.every(function (t) { t = Bi(t, e); return t <= 0 === n || Math.abs(t) <= r }) } function Ai(t, e, n, r, i) { return void 0 === i && (i = 0), r && e - i <= t || !r && t <= n + i ? { isBound: !0, offset: r ? e - t : n - t } : { isBound: !1, offset: 0 } } function Fi(t, e, n, r, i, o) { var a, s, u = e[0], e = e[1], t = t[0], c = n[0], n = n[1], l = oi(n[1] - c[1]), f = e, p = u, u = -u / e; return oi(n[0] - c[0]) ? l || o && !f ? { isBound: !1, offset: 0 } : p ? Ai((c[1] - t[1]) / u + t[0], c[0], n[0], r, i) : (a = c[1] - t[1], { isBound: s = Math.abs(a) <= (i || 0), offset: s ? a : 0 }) : o && !p ? { isBound: !1, offset: 0 } : f ? Ai(u * (c[0] - t[0]) + t[1], c[1], n[1], r, i) : (a = c[0] - t[0], { isBound: s = Math.abs(a) <= (i || 0), offset: s ? a : 0 }) } function Ni(a, t, s) { return t.map(function (t) { var e = function (t, e) { var n = e.line, r = e.centerSign, i = e.verticalSign, o = e.horizontalSign, e = e.lineConstants; if (!(t = t.props.innerBounds)) return { isAllBound: !1, isBound: !1, isVerticalBound: !1, isHorizontalBound: !1, offset: [0, 0] }; var a = t.left, s = t.top, u = t.width, t = t.height, c = [[a, s], [a, s + t]], l = [[a, s], [a + u, s]], f = [[a + u, s], [a + u, s + t]], p = [[a, s + t], [a + u, s + t]]; return ki([[a, s], [a + u, s], [a, s + t], [a + u, s + t]], n, r) ? { isAllBound: !1, isBound: !1, isVerticalBound: !1, isHorizontalBound: !1, offset: [0, 0] } : (a = Fi(n, e, l, i), u = Fi(n, e, p, i), s = Fi(n, e, c, o), t = Fi(n, e, f, o), r = a.isBound && u.isBound, l = a.isBound || u.isBound, p = s.isBound && t.isBound, i = s.isBound || t.isBound, c = ti(a.offset, u.offset), n = ti(s.offset, t.offset), f = !(e = [0, 0]), { isAllBound: Math.abs(n) < Math.abs(c) ? (e = [c, 0], f = l, r) : (e = [0, n], f = i, p), isVerticalBound: l, isHorizontalBound: i, isBound: f, offset: e }) }(a, t), n = e.isBound, r = e.offset, i = e.isVerticalBound, e = e.isHorizontalBound, o = t.multiple, t = tr({ datas: s, distX: r[0], distY: r[1] }).map(function (t, e) { return t * (o[e] ? 2 / o[e] : 0) }); return { sign: o, isBound: n, isVerticalBound: i, isHorizontalBound: e, isSnap: !1, offset: t } }) } function Ii(t, e, n) { var r, i, o, a, s, u, t = Ni(t, ji(t, e, [0, 0], !1).map(function (t) { return Q(Q({}, t), { multiple: t.multiple.map(function (t) { return 2 * Math.abs(t) }) }) }), n), e = Gi(t, 0), t = Gi(t, 1), c = 0, l = 0, f = e.isVerticalBound || t.isVerticalBound, p = e.isHorizontalBound || t.isHorizontalBound; return (f || p) && (n = { datas: n, distX: -e.offset[0], distY: -t.offset[1] }, e = n.datas, t = n.distX, n = n.distY, i = e.beforeMatrix, o = e.matrix, a = e.is3d, s = e.startDragBeforeDist, u = e.startDragDist, e = e.absoluteOrigin, a = a ? 4 : 3, c = (i = z(G(r ? i : o, J(r ? s : u, [t, n]), a), e))[0], l = i[1]), { vertical: { isBound: f, offset: c }, horizontal: { isBound: p, offset: l } } } function ji(t, l, e, n) { var r, i, t = t.state, f = Rr(t.allMatrix, 100, 100, t.is3d ? 4 : 3), p = j(f, [0, 0]); return t = n, n = [], r = (e = e)[0], i = e[1], r && i ? n.push([[0, 2 * i], e, [-r, i]], [[2 * r, 0], e, [r, -i]]) : r ? (n.push([[2 * r, 0], [r, 1], [r, -1]]), t && n.push([[0, -1], [r, -1], [-r, -1]], [[0, 1], [r, 1], [-r, 1]])) : i ? (n.push([[0, 2 * i], [1, i], [-1, i]]), t && n.push([[-1, 0], [-1, i], [-1, -i]], [[1, 0], [1, i], [1, -i]])) : n.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), n.map(function (t) { var e, n, r = t[0], i = t[1], t = t[2], o = [j(f, i), j(f, t)], a = (u = (a = o)[0], s = (a = a[1])[0] - u[0], a = a[1] - u[1], Math.abs(s) < k && (s = 0), Math.abs(a) < k && (a = 0), n = e = c = 0, n = s ? a ? (c = -a / s) * u[0] - u[e = 1] : -u[e = 1] : (c = -1, u[0]), [c, e, n].map(function (t) { return I(t, k) })), s = zi(p, o), u = s.vertical, c = s.horizontal; return { multiple: r, centerSign: Bi(p, o) <= 0, verticalSign: u, horizontalSign: c, lineConstants: a, line: [j(l, i), j(l, t)] } }) } function Yi(t, n, r, e) { t = e ? t.map(function (t) { return De(t, e) }) : t; return [[t[0], t[1]], [t[1], t[3]], [t[3], t[2]], [t[2], t[0]]].some(function (t) { var e = Bi(r, t) <= 0; return !ki(n, t, e) }) } function Xi(t, a, e, n, r) { var t = t.props.innerBounds, s = r * Math.PI / 180; if (!t) return []; var r = t.left, i = t.top, o = t.width, t = t.height, u = r - n[0], r = r + o - n[0], o = i - n[1], i = i + t - n[1], c = [[u, o], [r, o], [u, i], [r, i]], l = j(e, [0, 0]); if (!Yi(e, c, l, 0)) return []; var f = [], p = c.map(function (t) { return [Gr(t), N([0, 0], t)] }); return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function (t) { var e, n, r, i = N([0, 0], (r = (n = t)[0], e = (n = n[1])[0] - r[0], n = n[1] - r[1], e ? n ? [-(e = -(n /= e) * r[0] + r[1]) / (n + 1 / n), e / (n * n + 1)] : [0, r[1]] : [r[0], 0])), o = (n = (e = t)[0], r = (e = e[1])[0] - n[0], e = e[1] - n[1], r ? e ? (e /= r, Math.abs((-e * n[0] + n[1]) / Math.sqrt(Math.pow(e, 2) + 1))) : Math.abs(n[1]) : Math.abs(n[0])); f.push.apply(f, p.filter(function (t) { t = t[0]; return t && o <= t }).map(function (t) { var e = t[0], t = t[1], e = Math.acos(e ? o / e : 0); return [s + (t + e) - i, s + (t - e) - i] }).reduce(function (t, e) { return t.push.apply(t, e), t }, []).filter(function (t) { return !Yi(a, c, l, t) }).map(function (t) { return I(180 * t / Math.PI, A) })) }), f } function Wi(t, e, n) { var t = t || {}, r = t.position, i = t.left, o = t.top, a = t.right, t = t.bottom, r = { position: void 0 === r ? "client" : r, left: void 0 === i ? -1 / 0 : i, top: void 0 === o ? -1 / 0 : o, right: void 0 === a ? 1 / 0 : a, bottom: void 0 === t ? 1 / 0 : t }; return { vertical: Li(r, e, !0), horizontal: Li(r, n, !1) } } function qi(t, e) { var n = t.state, r = n.containerClientRect, i = r.clientHeight, o = r.clientWidth, a = r.clientLeft, r = r.clientTop, n = n.snapOffset, s = n.left, u = n.top, c = n.right, n = n.bottom, e = e || t.props.bounds || {}, t = "css" === (e.position || "client"), l = e.left, f = e.top, p = e.right, p = void 0 === p ? t ? -1 / 0 : 1 / 0 : p, e = e.bottom, e = void 0 === e ? t ? -1 / 0 : 1 / 0 : e; return t && (p = o + c - s - p, e = i + n - u - e), { left: (void 0 === l ? -1 / 0 : l) + s - a, right: p + s - a, top: (void 0 === f ? -1 / 0 : f) + u - r, bottom: e + u - r } } function Li(t, e, n) { var r = t[n ? "left" : "top"], t = t[n ? "right" : "bottom"], n = Math.min.apply(Math, e), e = Math.max.apply(Math, e), i = []; return n < r + 1 && i.push({ isBound: !0, offset: n - r, pos: r }), t - 1 < e && i.push({ isBound: !0, offset: e - t, pos: t }), i.length || i.push({ isBound: !1, offset: 0, pos: 0 }), i.sort(function (t, e) { return Math.abs(e.offset) - Math.abs(t.offset) }) } function Hi(t, e, n) { return (n ? t.map(function (t) { return De(t, n) }) : t).some(function (t) { return t[0] < e.left && .1 < Math.abs(t[0] - e.left) || t[0] > e.right && .1 < Math.abs(t[0] - e.right) || t[1] < e.top && .1 < Math.abs(t[1] - e.top) || t[1] > e.bottom && .1 < Math.abs(t[1] - e.bottom) }) } function Vi(t, s, e, n, r) { if (!t.props.bounds) return []; var u = r * Math.PI / 180, r = qi(t), t = r.left, i = r.top, o = r.right, r = r.bottom, t = t - n[0], o = o - n[0], i = i - n[1], r = r - n[1], c = { left: t, top: i, right: o, bottom: r }; if (!Hi(e, c, 0)) return []; var l = []; return [[t, 0], [o, 0], [i, 1], [r, 1]].forEach(function (t) { var o = t[0], a = t[1]; e.forEach(function (t) { var n, e, r, i = N([0, 0], t); l.push.apply(l, (e = o, r = a, t = Gr(n = t), [t = Math.sqrt(t * t - e * e) || 0, -t].sort(function (t, e) { return Math.abs(t - n[r ? 0 : 1]) - Math.abs(e - n[r ? 0 : 1]) }).map(function (t) { return N([0, 0], r ? [t, e] : [e, t]) }).map(function (t) { return u + t - i }).filter(function (t) { return !Hi(s, c, t) }).map(function (t) { return I(180 * t / Math.PI, A) }))) }) }), l } function Ui(t, e) { return t = Q(Q({}, t), { classNames: tt([B("line", "guideline", t.direction)], t.classNames, !0).filter(function (t) { return t }), size: t.size || "".concat(t.sizeValue, "px"), pos: t.pos || t.posValue.map(function (t) { return "".concat(I(t, .1), "px") }) }), e = e, n = t.direction, r = t.classNames, i = t.size, o = t.pos, a = t.zoom, t = t.key, s = (n = "horizontal" === n) ? "Y" : "X", e.createElement("div", { key: t, className: r.join(" "), style: ((e = {})[n ? "width" : "height"] = "".concat(i), e.transform = "translate(".concat(o[0], ", ").concat(o[1], ") translate").concat(s, "(-50%) scale").concat(s, "(").concat(a, ")"), e) }); var n, r, i, o, a, s } function $i(t, i, e, o, a, s, u, c) { var l = t.props.zoom; return e.map(function (t, e) { var n = t.type, t = t.pos, r = [0, 0]; return r[u] = o, r[u ? 0 : 1] = -a + t, Ui({ key: "".concat(i, "TargetGuideline").concat(e), classNames: [B("target", "bold", n)], posValue: r, sizeValue: s, zoom: l, direction: i }, c) }) } function Zi(t, o, e, a, n, s) { var t = t.props, u = t.zoom, r = t.isDisplayInnerSnapDigit, i = "horizontal" === o ? yi : Ei, c = n[i.start], l = n[i.end]; return e.filter(function (t) { var e = t.hide, t = t.elementRect; if (e) return !1; if (r && t) { e = t.rect; if (e[i.start] <= c && l <= e[i.end]) return !1 } return !0 }).map(function (t, e) { var n = t.pos, r = t.size, i = t.element, t = t.className, n = [-a[0] + n[0], -a[1] + n[1]]; return Ui({ key: "".concat(o, "-default-guideline-").concat(e), classNames: i ? [B("bold"), t] : [B("normal"), t], direction: o, posValue: n, sizeValue: r, zoom: u }, s) }) } function Ki(t, e, n, r, i, o, a, s) { var t = t.props, u = t.snapDigit, u = void 0 === u ? 0 : u, c = t.isDisplaySnapDigit, c = void 0 === c || c, l = t.snapDistFormat, l = void 0 === l ? function (t, e) { return t } : l, t = t.zoom, f = "horizontal" === e ? "X" : "Y", p = "vertical" === e ? "height" : "width", i = Math.abs(i), c = c ? parseFloat(i.toFixed(u)) : 0; return s.createElement("div", { key: "".concat(e, "-").concat(n, "-guideline-").concat(r), className: B("guideline-group", e), style: ((u = { left: "".concat(o[0], "px"), top: "".concat(o[1], "px") })[p] = "".concat(i, "px"), u) }, Ui({ direction: e, classNames: [B(n), a], size: "100%", posValue: [0, 0], sizeValue: i, zoom: t }, s), s.createElement("div", { className: B("size-value", "gap"), style: { transform: "translate".concat(f, "(-50%) scale(").concat(t, ")") } }, 0 < c ? l(c, e) : "")) } function Ji(y, e, E, S, C) { var n = y.props.isDisplayInnerSnapDigit, M = []; return ["vertical", "horizontal"].forEach(function (a) { var u, c, l, f, p, d, h, t = e.filter(function (t) { return t.type === a }), s = "vertical" === a ? 1 : 0, g = s ? 0 : 1, t = (c = n, f = "vertical" === (u = a) ? 1 : 0, d = S[(p = (l = "vertical" === u ? 0 : 1) ? yi : Ei).start], h = S[p.end], Jr(t, function (t) { return t.pos[l] }).map(function (t) { var a = [], s = []; return t.forEach(function (t) { var e, n, r, i = t.element, o = t.elementRect.rect; o[p.end] < d ? a.push(t) : h < o[p.start] ? s.push(t) : o[p.start] <= d && h <= o[p.end] && c && (e = t.pos, n = { element: i, rect: Q(Q({}, o), ((n = {})[p.end] = o[p.start], n)) }, o = { element: i, rect: Q(Q({}, o), ((i = {})[p.start] = o[p.end], i)) }, i = [0, 0], (r = [0, 0])[l] = e[l], r[f] = e[f], i[l] = e[l], i[f] = e[f] + t.size, a.push({ type: u, pos: r, size: 0, elementRect: n }), s.push({ type: u, pos: i, size: 0, elementRect: o })) }), a.sort(function (t, e) { return e.pos[f] - t.pos[f] }), s.sort(function (t, e) { return t.pos[f] - e.pos[f] }), { total: t, start: a, end: s, inner: [] } })), v = s ? Ei : yi, m = s ? yi : Ei, b = S[v.start], x = S[v.end]; t.forEach(function (t) { var e = t.total, n = t.start, r = t.end, t = t.inner, o = E[g] + e[0].pos[g] - S[m.start], i = S; n.forEach(function (t) { var e, n = t.elementRect.rect, r = i[v.start] - n[v.end]; 0 < r && ((e = [0, 0])[s] = E[s] + i[v.start] - b - r, e[g] = o, M.push(Ki(y, a, "dashed", M.length, r, e, t.className, C))), i = n }), i = S, r.forEach(function (t) { var e, n = t.elementRect.rect, r = n[v.start] - i[v.end]; 0 < r && ((e = [0, 0])[s] = E[s] + i[v.end] - b, e[g] = o, M.push(Ki(y, a, "dashed", M.length, r, e, t.className, C))), i = n }), t.forEach(function (t) { var e = t.elementRect.rect, n = b - e[v.start], e = e[v.end] - x, r = [0, 0], i = [0, 0]; r[s] = E[s] - n, r[g] = o, i[s] = E[s] + x - b, i[g] = o, M.push(Ki(y, a, "dashed", M.length, n, r, t.className, C)), M.push(Ki(y, a, "dashed", M.length, e, i, t.className, C)) }) }) }), M } function Qi(t, e, n, r, i) { o = t, n = n, r = r, a = (u = e)[0] - o[0], s = u[1] - o[1], Math.abs(a) < k && (a = 0), Math.abs(s) < k && (s = 0); var o = a ? s ? (s /= a, a = o[1] - s * o[0], r ? [n, s * (u[0] + n) + a - u[1]] : [(u[1] + n - a) / s - u[0], n]) : r ? [n, 0] : [0, 0] : r ? [0, 0] : [0, n]; if (!o) return { isOutside: !1, offset: [0, 0] }; var a = wt(t, e), s = wt(o, t), u = wt(o, e), r = a < s || a < u, n = tr({ datas: i, distX: o[0], distY: o[1] }); return { offset: [n[0], n[1]], isOutside: r } } function to(t, e) { return t.isBound ? t.offset : e.isSnap ? Ri(e).offset : 0 } function eo(t, e, n, r, i, o) { if (!Si(t, "draggable")) return [{ isSnap: !1, isBound: !1, offset: 0 }, { isSnap: !1, isBound: !1, offset: 0 }]; var a, s, u, c, l = Lr(o.absolutePoses, [e, n]), f = Or(l), p = f.left, d = f.right, h = f.top, f = f.bottom, g = { horizontal: l.map(function (t) { return t[1] }), vertical: l.map(function (t) { return t[0] }) }, i = no(t, i, Mi(Ci(t.props.snapDirections), { left: p, right: d, top: h, bottom: f, center: (p + d) / 2, middle: (h + f) / 2 }), g), p = i.vertical, d = i.horizontal, h = Ii(t, l, o), f = h.vertical, g = h.horizontal, i = p.isSnap, t = d.isSnap, l = p.isBound || f.isBound, o = d.isBound || g.isBound, h = ti(p.offset, f.offset), p = ti(d.offset, g.offset), v = (f = r, d = [l, o], g = [i, t], r = [h, p], s = (h = [e, n])[0], u = h[1], h = d[0], d = d[1], p = g[0], g = g[1], e = r[0], r = r[1], n = -e, c = -r, f && s && u ? (c = n = 0, v = [], h && d ? v.push([0, r], [e, 0]) : h ? v.push([e, 0]) : d ? v.push([0, r]) : p && g ? v.push([0, r], [e, 0]) : p ? v.push([e, 0]) : g && v.push([0, r]), v.length && (v.sort(function (t, e) { return Gr(z([s, u], t)) - Gr(z([s, u], e)) }), (p = v[0])[0] && Math.abs(s) > k ? (n = -p[0], c = u * Math.abs(s + n) / Math.abs(s) - u) : p[1] && Math.abs(u) > k && (g = u, c = -p[1], n = s * Math.abs(u + c) / Math.abs(g) - s), f && d && h && (Math.abs(n) > k && Math.abs(n) < Math.abs(e) ? (n *= a = Math.abs(e) / Math.abs(n), c *= a) : Math.abs(c) > k && Math.abs(c) < Math.abs(r) ? (n *= a = Math.abs(r) / Math.abs(c), c *= a) : (n = ti(-e, n), c = ti(-r, c))))) : (n = s || h ? -e : 0, c = u || d ? -r : 0), [n, c]); return [{ isBound: l, isSnap: i, offset: v[0] }, { isBound: o, isSnap: t, offset: v[1] }] } function no(t, e, n, r) { var r = Wi(qi(t), (r = void 0 === r ? n : r).vertical, r.horizontal), i = r.horizontal, r = r.vertical, e = e ? { horizontal: { isSnap: !1, index: -1 }, vertical: { isSnap: !1, index: -1 } } : Di(t, n.vertical, n.horizontal), t = e.horizontal, n = e.vertical, e = to(i[0], t), o = to(r[0], n), a = Math.abs(e), s = Math.abs(o); return { horizontal: { isBound: i[0].isBound, isSnap: t.isSnap, snapIndex: t.index, offset: e, dist: a, bounds: i, snap: t }, vertical: { isBound: r[0].isBound, isSnap: n.isSnap, snapIndex: n.index, offset: o, dist: s, bounds: r, snap: n } } } function ro(t, e, n, r, i) { var e = Wi(e, n, r), o = e.horizontal, e = e.vertical, t = wi(t, n, r, i), n = t.horizontal, r = t.vertical, i = to(o[0], n), t = to(e[0], r), a = Math.abs(i), s = Math.abs(t); return { horizontal: { isBound: o[0].isBound, isSnap: n.isSnap, snapIndex: n.index, offset: i, dist: a, bounds: o, snap: n }, vertical: { isBound: e[0].isBound, isSnap: r.isSnap, snapIndex: r.index, offset: t, dist: s, bounds: e, snap: r } } } function io(C, M, t, D, w, _) { return t.map(function (t) { var e = t[0], t = t[1], n = j(M, e), r = j(M, t), i = D ? (l = w, u = function (t, e, n) { var r, i, o = (t = qi(t)).left, a = t.top, s = t.right, t = t.bottom, u = n[0], c = n[1], l = (e = z(n, e))[0], e = e[1], f = (Math.abs(l) < A && (l = 0), 0 < (e = Math.abs(e) < A ? 0 : e)), p = 0 < l, d = { isBound: !1, offset: 0, pos: 0 }, h = { isBound: !1, offset: 0, pos: 0 }; return 0 === l && 0 === e || (0 === l ? f ? t < c && (h.pos = t, h.offset = c - t) : c < a && (h.pos = a, h.offset = c - a) : 0 === e ? p ? s < u && (d.pos = s, d.offset = u - s) : u < o && (d.pos = o, d.offset = u - o) : (e = n[1] - (n = e / l) * u, r = l = 0, i = !1, p && s <= u ? (l = n * s + e, r = s, i = !0) : !p && u <= o && (l = n * o + e, r = o, i = !0), (i = i && (l < a || t < l) ? !1 : i) || (f && t <= c ? (r = ((l = t) - e) / n, i = !0) : !f && c <= a && (r = ((l = a) - e) / n, i = !0)), i && (d.isBound = !0, d.pos = r, d.offset = u - r, h.isBound = !0, h.pos = l, h.offset = c - l))), { vertical: d, horizontal: h } }(o = C, c = n, a = r), i = u.horizontal, u = u.vertical, l = l ? { horizontal: { isSnap: !1 }, vertical: { isSnap: !1 } } : function (t, e, n) { var r = n[0], i = n[1], o = e[0], a = e[1], s = (e = z(n, e))[0], u = 0 < (e = e[1]), c = 0 < s, s = oi(s), e = oi(e), l = { isSnap: !1, offset: 0, pos: 0 }, f = { isSnap: !1, offset: 0, pos: 0 }; if (0 === s && 0 === e) return { vertical: l, horizontal: f }; var p, d = (t = Di(t, s ? [r] : [], e ? [i] : [])).vertical, t = t.horizontal; d.posInfos.filter(function (t) { t = t.pos; return c ? o <= t : t <= o }), t.posInfos.filter(function (t) { t = t.pos; return u ? a <= t : t <= a }), d.isSnap = 0 < d.posInfos.length, t.isSnap = 0 < t.posInfos.length; var h = (d = Ri(d)).isSnap, d = d.guideline, g = (t = Ri(t)).isSnap, t = t.guideline, v = g ? t.pos[1] : 0, d = h ? d.pos[0] : 0; return 0 === s ? g && (f.isSnap = !0, f.pos = t.pos[1], f.offset = i - f.pos) : 0 === e ? h && (l.isSnap = !0, l.pos = d, l.offset = r - d) : (n = n[1] - (t = e / s) * r, s = e = 0, p = !1, h ? (e = t * (s = d) + n, p = !0) : g && (s = ((e = v) - n) / t, p = !0), p && (l.isSnap = !0, l.pos = s, l.offset = r - s, f.isSnap = !0, f.pos = e, f.offset = i - e)), { vertical: l, horizontal: f } }(o, c, a), o = l.horizontal, c = l.vertical, a = oo(i, o), l = oo(u, c), s = Math.abs(a), f = Math.abs(l), { horizontal: { isBound: i.isBound, isSnap: o.isSnap, offset: a, dist: s }, vertical: { isBound: u.isBound, isSnap: c.isSnap, offset: l, dist: f } }) : no(C, w, { vertical: [r[0]], horizontal: [r[1]] }), o = i.horizontal, a = o.offset, s = o.isBound, u = o.isSnap, c = i.vertical, l = c.offset, f = c.isBound, p = c.isSnap, d = z(t, e); if (!l && !a) return { isBound: f || s, isSnap: p || u, sign: d, offset: [0, 0] }; y = i, g = D, h = N(h = n, E = r) / Math.PI * 180, S = (E = y.vertical).isBound, v = E.isSnap, E = E.dist, m = (y = y.horizontal).isBound, b = y.isSnap, x = (h = h % 180) < 3 || 177 < h, h = 87 < h && h < 93; var h, g, v, m, b, x, y = y.dist < E && (S || v && !h && (!g || !x)) ? "vertical" : !m && (!b || x || g && h) ? "" : "horizontal"; if (!y) return { sign: d, isBound: !1, isSnap: !1, offset: [0, 0] }; var E = "vertical" == y, S = [0, 0]; return S = (S = D || 1 !== Math.abs(t[0]) || 1 !== Math.abs(t[1]) || e[0] === t[0] || e[1] === t[1] ? Qi(n, r, -(E ? l : a), E, _).offset : tr({ datas: _, distX: -l, distY: -a })).map(function (t, e) { return t * (d[e] ? 2 / d[e] : 0) }), { sign: d, isBound: E ? f : s, isSnap: E ? p : u, offset: S } }) } function oo(t, e) { return t.isBound ? t.offset : e.isSnap ? e.offset : 0 } function ao(t) { var m, b, x, y, o, E, e = t.state, n = e.containerClientRect, r = e.hasFixed, i = n.overflow, a = n.scrollHeight, s = n.scrollWidth, u = n.clientHeight, c = n.clientWidth, l = n.clientLeft, f = n.clientTop, p = t.props, d = p.snapGap, d = void 0 === d || d, h = p.verticalGuidelines, g = p.horizontalGuidelines, v = p.snapThreshold, v = void 0 === v ? 5 : v, S = p.snapGridWidth, S = void 0 === S ? 0 : S, C = p.snapGridHeight, C = void 0 === C ? 0 : C, p = p.maxSnapElementGuidelineDistance, M = void 0 === p ? 1 / 0 : p, p = Or(Y(t.state)), D = p.top, w = p.left, _ = p.bottom, p = p.right, R = { top: D, left: w, bottom: _, right: p, center: (w + p) / 2, middle: (D + _) / 2 }, w = tt([], function (t) { var e = t.state, n = t.props.elementGuidelines, n = void 0 === n ? [] : n; if (!n.length) return e.elementRects = [], []; var r = (e.elementRects || []).filter(function (t) { return !t.refresh }), i = n.map(function (t) { return ot(t) && "element" in t ? Q(Q({}, t), { element: ci(t.element, !0) }) : { element: ci(t, !0) } }).filter(function (t) { return t.element }), n = function (t, e) { return O(t, e, Fe) }(r.map(function (t) { return t.element }), i.map(function (t) { return t.element })), o = n.maintained, a = n.added, s = [], g = (o.forEach(function (t) { var e = t[0], t = t[1]; s[t] = r[e] }), function (t, e) { if (!e.length) return []; var t = t.state, n = t.containerClientRect, r = t.targetClientRect, i = r.top, r = r.left, o = t.rootMatrix, a = t.is3d ? 4 : 3, n = function (t, e, n) { return t = F(t, [e.clientLeft, e.clientTop], n), [e.left + t[0], e.top + t[1]] }(o, n, a), s = n[0], u = n[1], n = Ye(Y(t)), t = n.minX, n = n.minY, t = z([t, n], ei(o, [r - s, i - u], a)).map(function (t) { return t = t, Math.round(t % 1 == -.5 ? t - 1 : t) }), c = t[0], l = t[1]; return e.map(function (t) { var e = t.element.getBoundingClientRect(), n = e.left - s, r = e.top - u, i = r + e.height, e = n + e.width, n = ei(o, [n, r], a), r = n[0], n = n[1], e = ei(o, [e, i], a), i = e[0], e = e[1]; return Q(Q({}, t), { rect: { left: r + c, right: i + c, top: n + l, bottom: e + l, center: (r + i) / 2 + c, middle: (n + e) / 2 + l } }) }) }(t, a.map(function (t) { return i[t] })).map(function (t, e) { s[a[e]] = t }), e.elementRects = s, Ci(t.props.elementSnapDirections)), v = []; return s.forEach(function (e) { var n = e.element, t = e.top, t = void 0 === t ? g.top : t, r = e.left, r = void 0 === r ? g.left : r, i = e.right, i = void 0 === i ? g.right : i, o = e.bottom, o = void 0 === o ? g.bottom : o, a = e.center, a = void 0 === a ? g.center : a, s = e.middle, s = void 0 === s ? g.middle : s, u = e.className, c = e.rect, t = Mi({ top: t, right: i, left: r, bottom: o, center: a, middle: s }, c), i = t.horizontal, r = t.vertical, l = c.top, f = c.left, p = c.right - f, d = c.bottom - l, h = [p, d]; r.forEach(function (t) { v.push({ type: "vertical", element: n, pos: [I(t, .1), l], size: d, sizes: h, className: u, elementRect: e }) }), i.forEach(function (t) { v.push({ type: "horizontal", element: n, pos: [f, I(t, .1)], size: p, sizes: h, className: u, elementRect: e }) }) }), v }(t), !0), _ = (d && w.push.apply(w, (m = R, b = v, p = t.props, D = p.maxSnapElementGuidelineDistance, x = void 0 === D ? 1 / 0 : D, D = p.maxSnapElementGapDistance, y = void 0 === D ? 1 / 0 : D, o = t.state.elementRects, E = [], [["vertical", yi, Ei], ["horizontal", Ei, yi]].forEach(function (t) { var p = t[0], d = t[1], a = t[2], h = m[d.start], g = m[d.end], v = m[d.center], n = m[a.start], r = m[a.end]; function i(t) { t = t.rect; return t[d.end] < h + b ? h - t[d.end] : g - b < t[d.start] ? t[d.start] - g : -1 } var e = o.filter(function (t) { var e = t.rect; return !(e[a.start] > r || e[a.end] < n) && 0 < i(t) }).sort(function (t, e) { return i(t) - i(e) }), s = []; e.forEach(function (o) { e.forEach(function (t) { var e, n, r, i; o !== t && (r = o.rect, e = t.rect, n = r[a.start], r = r[a.end], i = e[a.start], e[a.end] < n || r < i || s.push([o, t])) }) }), s.forEach(function (t) { var e = t[0], t = t[1], n = e.rect, r = t.rect, i = n[d.start], n = n[d.end], o = r[d.start], a = r[d.end], s = 0, u = 0, c = !1, l = !1, f = !1; if (n <= h && g <= o) { if (l = !0, u = n + (s = (o - n - (g - h)) / 2) + (g - h) / 2, Math.abs(u - v) > b) return } else if (n < o && a < h + b) { if (c = !0, u = a + (s = o - n), Math.abs(u - h) > b) return } else { if (!(n < o && g - b < i)) return; if (f = !0, u = i - (s = o - n), Math.abs(u - g) > b) return } !s || !so(m, r, p, x) || y < s || E.push({ type: p, pos: "vertical" === p ? [u, 0] : [0, u], element: t.element, size: 0, className: t.className, isStart: c, isCenter: l, isEnd: f, gap: s, hide: !0, gapRects: [e, t] }) }) }), E)), w.push.apply(w, function (t, e, n, r, i, o) { void 0 === i && (i = 0); void 0 === o && (o = 0); var a = []; if (e) for (var s = 0; s <= r; s += e)a.push({ type: "horizontal", pos: [0, I(s - o, .1)], size: n, hide: !0 }); if (t) for (s = 0; s <= n; s += t)a.push({ type: "vertical", pos: [I(s - i, .1), 0], size: r, hide: !0 }); return a }(S, C, i ? s : c, i ? a : u, l, f)), Q({}, e.snapOffset || { left: 0, top: 0, bottom: 0, right: 0 })); return r && (d = n.left, v = n.top, _.left += d, _.top += v, _.right += d, _.bottom += v), w.push.apply(w, uo(g || !1, h || !1, i ? s : c, i ? a : u, l, f, _)), w = w.filter(function (t) { var e = t.element, n = t.elementRect, t = t.type; if (!e || !n) return !0; e = n.rect; return so(R, e, t, M) }) } function so(t, e, n, r) { return "horizontal" === n ? Math.abs(t.right - e.left) <= r || Math.abs(t.left - e.right) <= r || t.left <= e.right && e.left <= t.right : "vertical" !== n || (Math.abs(t.bottom - e.top) <= r || Math.abs(t.top - e.bottom) <= r || t.top <= e.bottom && e.top <= t.bottom) } function uo(t, e, n, r, i, o, a) { void 0 === i && (i = 0), void 0 === o && (o = 0); var s = [], u = (a = void 0 === a ? { left: 0, top: 0, right: 0, bottom: 0 } : a).left, c = a.top, l = a.bottom, f = n + a.right - u, p = r + l - c; return t && t.forEach(function (t) { t = ot(t) ? t : { pos: t }; s.push({ type: "horizontal", pos: [u, I(t.pos - o + c, .1)], size: f, className: t.className }) }), e && e.forEach(function (t) { t = ot(t) ? t : { pos: t }; s.push({ type: "vertical", pos: [I(t.pos - i + u, .1), c], size: p, className: t.className }) }), s } function co(t) { var e, n, r, i = t.state, o = i.container, a = t.props.snapContainer || o; if (i.snapContainer !== a || !i.guidelines || !i.guidelines.length) return e = i.containerClientRect, n = { left: 0, top: 0, bottom: 0, right: 0 }, o !== a && (o = ci(a, !0)) && (r = fi(i, [(o = Xr(o)).left - e.left, o.top - e.top]), o = fi(i, [o.right - e.right, o.bottom - e.bottom]), n.left = I(r[0], 1e-5), n.top = I(r[1], 1e-5), n.right = I(o[0], 1e-5), n.bottom = I(o[1], 1e-5)), i.snapContainer = a, i.snapOffset = n, i.guidelines = ao(t), i.enableSnap = !0 } function lo(t, e, n, r, i, o) { t = Rr(t, e, n, o ? 4 : 3); return Lr(t, z(i, j(t, r))) } function fo(t, e, n, r, i, o) { var a, s, u, c, l = o.fixedDirection, l = (a = n, s = l, c = [], r ? (1 !== Math.abs(s[0]) || 1 !== Math.abs(s[1]) ? c.push([s, [-1, -1]], [s, [-1, 1]], [s, [1, -1]], [s, [1, 1]]) : c.push([s, [a[0], -a[1]]], [s, [-a[0], a[1]]]), c.push([s, a])) : a[0] && a[1] || !a[0] && !a[1] ? (u = a[0] ? a : [1, 1], [1, -1].forEach(function (e) { [1, -1].forEach(function (t) { t = [e * u[0], t * u[1]]; s[0] === t[0] && s[1] === t[1] || c.push([s, t]) }) })) : a[0] ? (1 === Math.abs(s[0]) ? [1] : [1, -1]).forEach(function (t) { c.push([[s[0], -1], [t * a[0], -1]], [[s[0], 0], [t * a[0], 0]], [[s[0], 1], [t * a[0], 1]]) }) : a[1] && (1 === Math.abs(s[1]) ? [1] : [1, -1]).forEach(function (t) { c.push([[-1, s[1]], [-1, t * a[1]]], [[0, s[1]], [0, t * a[1]]], [[1, s[1]], [1, t * a[1]]]) }), c), n = ji(t, e, n, r), e = tt(tt([], io(t, e, l, r, i, o), !0), Ni(t, n, o), !0), l = Gi(e, 0), r = Gi(e, 1); return { width: { isBound: l.isBound, offset: l.offset[0] }, height: { isBound: r.isBound, offset: r.offset[1] } } } function po(t, e, n, r, i, o, a, s) { for (var u, c, l, f, p, d, h, g, v, m, b, x, y, E, S, C, A, M, D, w = Y(t.state), F = t.props.keepRatio, _ = 0, R = 0, O = 0; O < 2; ++O) { var P = fo(t, e(_, R), i, F, a, s), T = P.width, P = P.height, G = T.isBound, z = P.isBound, B = T.offset, k = P.offset; if (1 === O && (G || (B = 0), z || (k = 0)), 0 === O && a && !G && !z) return [0, 0]; F && (T = Math.abs(B) * (n ? 1 / n : 1), P = Math.abs(k) * (r ? 1 / r : 1), (G && z ? T < P : z || !G && T < P) ? B = n * k / r : k = r * B / n), _ += B, R += k } return i[0] && i[1] && (h = t, g = w, v = o, m = s, S = [-(w = i)[0], -w[1]], C = (o = h.state).width, A = o.height, o = h.props.bounds, D = M = 1 / 0, o && (h = [[w[0], -w[1]], [-w[0], w[1]]], w = o.left, b = void 0 === w ? -1 / 0 : w, w = o.top, x = void 0 === w ? -1 / 0 : w, w = o.right, y = void 0 === w ? 1 / 0 : w, w = o.bottom, E = void 0 === w ? 1 / 0 : w, h.forEach(function (t) { var e, n, r = t[0] !== S[0], i = t[1] !== S[1], t = j(g, t), o = 360 * N(v, t) / Math.PI; i && (e = t.slice(), (Math.abs(o - 360) < 2 || Math.abs(o - 180) < 2) && (e[1] = v[1]), n = (i = Qi(v, e, (v[1] < t[1] ? E : x) - t[1], !1, m)).offset[1], i = i.isOutside, isNaN(n) || (D = A + (i ? 1 : -1) * Math.abs(n))), r && (e = t.slice(), (Math.abs(o - 90) < 2 || Math.abs(o - 270) < 2) && (e[0] = v[0]), n = (i = Qi(v, e, (v[0] < t[0] ? y : b) - t[0], !0, m)).offset[0], r = i.isOutside, isNaN(n) || (M = C + (r ? 1 : -1) * Math.abs(n))) })), w = (o = { maxWidth: M, maxHeight: D }).maxWidth, h = o.maxHeight, o = t, u = e(_, R).map(function (t) { return t.map(function (t) { return I(t, Nn) }) }), c = n + _, l = r + R, w = w, h = h, p = a, d = s, u = j(u, f = i), p = (o = no(o, p, { vertical: [u[0]], horizontal: [u[1]] })).horizontal.offset, _ += B = (p = I(u = o.vertical.offset, Nn) || I(p, Nn) ? (d = (o = tr({ datas: d, distX: -u, distY: -p }))[0], u = o[1], [Math.min(w || 1 / 0, c + f[0] * d) - c, Math.min(h || 1 / 0, l + f[1] * u) - l]) : [0, 0])[0], R += k = p[1]), [_, R] } function ho(t, o, e, n, a) { if (!Si(t, "scalable")) return [0, 0]; var s = a.startOffsetWidth, u = a.startOffsetHeight, c = a.fixedPosition, l = a.fixedDirection, f = a.is3d, t = po(t, function (t, e) { return lo((n = a, t = J(o, [t / s, e / u]), e = n.transformOrigin, r = n.offsetMatrix, i = n.is3d ? 4 : 3, nr(r, K(n.targetMatrix, Oe(t, i), i), e, i)), s, u, l, c, f); var n, r, i }, s, u, e, c, n, a); return [t[0] / s, t[1] / u] } function go(t) { var e = []; return t.forEach(function (t) { t.guidelineInfos.forEach(function (t) { t = t.guideline; -1 < e.indexOf(t) || e.push(t) }) }), e } function vo(t, e, n, r, i, o) { o = Wi(qi(t, o), e, n), e = o.vertical, n = o.horizontal, e.forEach(function (t) { t.isBound && r.push({ type: "bounds", pos: t.pos }) }), n.forEach(function (t) { t.isBound && i.push({ type: "bounds", pos: t.pos }) }), o = function (t) { if (!(n = t.props.innerBounds)) return { vertical: [], horizontal: [] }; var e = t.getRect(), a = j(e = [e.pos1, e.pos2, e.pos3, e.pos4], [0, 0]), s = n.left, u = n.top, c = n.width, l = n.height, f = [[s, u], [s, u + l]], p = [[s, u], [s + c, u]], d = [[s + c, u], [s + c, u + l]], h = [[s, u + l], [s + c, u + l]], n = ji(t, e, [0, 0], !1), g = [], v = [], m = { top: !1, bottom: !1, left: !1, right: !1 }; return n.forEach(function (t) { var e = t.line, t = t.lineConstants, n = zi(a, e), r = n.horizontal, n = n.vertical, i = Fi(e, t, p, n, 1, !0), n = Fi(e, t, h, n, 1, !0), o = Fi(e, t, f, r, 1, !0), e = Fi(e, t, d, r, 1, !0); i.isBound && !m.top && (g.push(u), m.top = !0), n.isBound && !m.bottom && (g.push(u + l), m.bottom = !0), o.isBound && !m.left && (v.push(s), m.left = !0), e.isBound && !m.right && (v.push(s + c), m.right = !0) }), { horizontal: g, vertical: v } }(t), e = o.vertical, n = o.horizontal; e.forEach(function (n) { 0 <= mt(r, function (t) { var e = t.type, t = t.pos; return "bounds" === e && t === n }) || r.push({ type: "bounds", pos: n }) }), n.forEach(function (n) { 0 <= mt(i, function (t) { var e = t.type, t = t.pos; return "bounds" === e && t === n }) || i.push({ type: "bounds", pos: n }) }) } var mo = si("", ["resizable", "scalable"]), g = { name: "snappable", dragRelation: "strong", props: { snappable: [Boolean, Array], snapContainer: Object, snapDirections: [Boolean, Object], elementSnapDirections: [Boolean, Object], snapGap: Boolean, snapGridWidth: Number, snapGridHeight: Number, isDisplaySnapDigit: Boolean, isDisplayInnerSnapDigit: Boolean, snapDigit: Number, snapThreshold: Number, snapRenderThreshold: Number, horizontalGuidelines: Array, verticalGuidelines: Array, elementGuidelines: Array, bounds: Object, innerBounds: Object, snapDistFormat: Function, maxSnapElementGuidelineDistance: Number, maxSnapElementGapDistance: Number }, events: { onSnap: "snap" }, css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-size: calc(12px * var(--zoom));\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n    bottom: calc(2px + 3px * var(--zoom));\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n    left: calc(2px + 3px * var(--zoom));\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"], render: function (t, e) { var n = t.state, r = n.top, i = n.left, o = n.pos1, a = n.pos2, s = n.pos3, u = n.pos4, c = n.snapRenderInfo, l = t.props.snapRenderThreshold, l = void 0 === l ? 1 : l; if (!c || !c.render || !Si(t, "")) return []; n.guidelines = ao(t); var d, h, g, v, m, b, n = Math.min(o[0], a[0], s[0], u[0]), o = Math.min(o[1], a[1], s[1], u[1]), a = c.externalPoses || [], s = Y(t.state), f = [], p = [], x = [], y = [], u = [], E = Or(s), S = E.width, C = E.height, M = E.top, D = E.left, w = E.bottom, E = E.right, _ = { left: D, right: E, top: M, bottom: w, center: (D + E) / 2, middle: (M + w) / 2 }, R = 0 < a.length, a = R ? Or(a) : {}, s = (c.request || (c.direction && u.push(Pi(t, s, c.direction, l)), c.snap && (s = Or(s), c.center && (s.middle = (s.top + s.bottom) / 2, s.center = (s.left + s.right) / 2), u.push(_i(t, s, l))), R && (c.center && (a.middle = (a.top + a.bottom) / 2, a.center = (a.left + a.right) / 2), u.push(_i(t, a, l))), u.forEach(function (t) { var e = t.vertical.posInfos, t = t.horizontal.posInfos; f.push.apply(f, e.filter(function (t) { return t.guidelineInfos.some(function (t) { return !t.guideline.hide }) }).map(function (t) { return { type: "snap", pos: t.pos } })), p.push.apply(p, t.filter(function (t) { return t.guidelineInfos.some(function (t) { return !t.guideline.hide }) }).map(function (t) { return { type: "snap", pos: t.pos } })), x.push.apply(x, go(e)), y.push.apply(y, go(t)) })), vo(t, [D, E], [M, w], f, p), R && vo(t, [a.left, a.right], [a.top, a.bottom], f, p, c.externalBounds), tt(tt([], x, !0), y, !0)), l = s.filter(function (t) { return t.element && !t.gapRects }), u = s.filter(function (t) { return t.gapRects }).sort(function (t, e) { return t.gap - e.gap }); return rt(t, "onSnap", { guidelines: s.filter(function (t) { return !t.element }), elements: l, gaps: u }, !0), tt(tt(tt(tt(tt(tt([], Ji(t, l, [n, o], _, e), !0), (d = t, h = u, g = [n, o], v = _, m = e, b = [], ["horizontal", "vertical"].forEach(function (e) { var t = h.filter(function (t) { return t.type === e }).slice(0, 1), o = "vertical" === e ? 0 : 1, a = o ? 0 : 1, s = o ? Ei : yi, u = o ? yi : Ei, c = v[s.start], l = v[s.end], f = v[u.start], p = v[u.end]; t.forEach(function (t) { var r = t.gap, t = t.gapRects, e = Math.max.apply(Math, tt([f], t.map(function (t) { return t.rect[u.start] }), !1)), n = Math.min.apply(Math, tt([p], t.map(function (t) { return t.rect[u.end] }), !1)), i = (e + n) / 2; e !== n && i != (f + p) / 2 && t.forEach(function (t) { var e = t.rect, t = t.className, n = [g[0], g[1]]; if (e[s.end] < c) n[o] += e[s.end] - c; else { if (!(l < e[s.start])) return; n[o] += e[s.start] - c - r } n[a] += i - f, b.push(Ki(d, o ? "vertical" : "horizontal", "gap", b.length, r, n, t, m)) }) }) }), b), !0), Zi(t, "horizontal", y, [i, r], _, e), !0), Zi(t, "vertical", x, [i, r], _, e), !0), $i(t, "horizontal", p, n, r, S, 0, e), !0), $i(t, "vertical", f, o, i, C, 1, e), !0) }, dragStart: function (t, e) { t.state.snapRenderInfo = { request: e.isRequest, snap: !0, center: !0 }, co(t) }, drag: function (t) { var e = t.state; co(t) || (e.guidelines = ao(t)), e.snapRenderInfo && (e.snapRenderInfo.render = !0) }, pinchStart: function (t) { this.unset(t) }, dragEnd: function (t) { this.unset(t) }, dragControlCondition: function (t, e) { return !(!mo(t, e) && !Po(t, e)) || (!e.isRequest && e.inputEvent ? T(e.inputEvent.target, B("snap-control")) : void 0) }, dragControlStart: function (t) { t.state.snapRenderInfo = null, co(t) }, dragControl: function (t) { this.drag(t) }, dragControlEnd: function (t) { this.unset(t) }, dragGroupStart: function (t, e) { this.dragStart(t, e) }, dragGroup: function (t) { this.drag(t) }, dragGroupEnd: function (t) { this.unset(t) }, dragGroupControlStart: function (t) { t.state.snapRenderInfo = null, co(t) }, dragGroupControl: function (t) { this.drag(t) }, dragGroupControlEnd: function (t) { this.unset(t) }, unset: function (t) { t = t.state; t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [] } }; function bo(t, a, e, s) { var n = t.getState(), u = n.renderPoses, c = n.rotation, n = n.direction, l = Ar(t.props, a).zoom, f = 0 < n ? 1 : -1, p = c / Math.PI * 180, d = {}, n = t.renderState, h = (n.renderDirectionMap || (n.renderDirectionMap = {}), n.renderDirectionMap); return e.forEach(function (t) { t = t.dir; d[t] = !0 }), e.map(function (t) { var e = t.data, n = t.classNames, t = t.dir, r = Xn[t]; if (!r || !d[t]) return null; h[t] = !0; var i = (I(p, 15) + f * Wn[t] + 720) % 180, o = {}; return Et(e).forEach(function (t) { o["data-".concat(t)] = e[t] }), s.createElement("div", Q({ className: B.apply(void 0, tt(["control", "direction", t, a], n, !1)), "data-rotation": i, "data-direction": t }, o, { key: "direction-".concat(t), style: kr.apply(void 0, tt([c, l], r.map(function (t) { return u[t] }), !1)) })) }) } function xo(t, e, n, r) { var i = Ar(t.props, n), o = i.renderDirections, e = void 0 === o ? e : o, o = i.displayAroundControls; if (!e) return []; i = !0 === e ? Dn : e; return tt(tt([], o ? Mo(t, r, n, i) : [], !0), bo(t, n, i.map(function (t) { return { data: {}, classNames: [], dir: t } }), r), !0) } function yo(t, e, n, r, i, o) { for (var a = [], s = 6; s < arguments.length; s++)a[s - 6] = arguments[s]; var u = N(n, r), c = e ? I(u / Math.PI * 180, 15) % 180 : -1; return t.createElement("div", { key: "line-".concat(o), className: B.apply(void 0, tt(["line", "direction", e ? "edge" : "", e], a, !1)), "data-rotation": c, "data-line-key": o, "data-direction": e, style: Br(n, r, i, u) }) } function Eo(i, o, t, a, s) { return (!0 === t ? Mn : t).map(function (t, e) { var n = Xn[t], r = n[0], n = n[1]; if (null != n) return yo(i, t, a[r], a[n], s, "".concat(o, "Edge").concat(e), o) }).filter(Boolean) } function So(r) { return function (t, e) { var n = Ar(t.props, r).edge; return n && (!0 === n || n.length) ? tt(tt([], Eo(e, r, n, t.getState().renderPoses, t.props.zoom), !0), xo(t, ["nw", "ne", "sw", "se"], r, e), !0) : Co(t, r, e) } } function Co(t, e, n) { return xo(t, Dn, e, n) } function Mo(t, i, o, e) { var n = t.renderState, r = (n.renderDirectionMap || (n.renderDirectionMap = {}), t.getState()), a = r.renderPoses, s = r.rotation, r = r.direction, n = n.renderDirectionMap, u = t.props.zoom, c = 0 < r ? 1 : -1, l = s / Math.PI * 180; return (e || Et(n)).map(function (t) { var e = Xn[t]; if (!e) return null; var n = (I(l, 15) + c * Wn[t] + 720) % 180, r = ["around-control"]; return o && r.push("direction", o), i.createElement("div", { className: B.apply(void 0, r), "data-rotation": n, "data-direction": t, key: "direction-around-".concat(t), style: kr.apply(void 0, tt([s, u], e.map(function (t) { return a[t] }), !1)) }) }) } var X = { name: "draggable", props: { draggable: Boolean, throttleDrag: Number, throttleDragRotate: Number, startDragRotate: Number, edgeDraggable: Boolean }, events: { onDragStart: "dragStart", onDrag: "drag", onDragEnd: "dragEnd", onDragGroupStart: "dragGroupStart", onDragGroup: "dragGroup", onDragGroupEnd: "dragGroupEnd" }, requestStyle: function () { return ["left", "top", "right", "bottom"] }, requestChildStyle: function () { return ["left", "top", "right", "bottom"] }, render: function (t, e) { var n = t.props, r = n.throttleDragRotate, n = n.zoom, t = t.getState(), i = t.dragInfo, t = t.beforeOrigin; if (!r || !i) return []; r = i.dist; if (!r[0] && !r[1]) return []; i = Gr(r), r = N(r, [0, 0]); return [e.createElement("div", { className: B("line", "horizontal", "dragline", "dashed"), key: "dragRotateGuideline", style: { width: "".concat(i, "px"), transform: "translate(".concat(t[0], "px, ").concat(t[1], "px) rotate(").concat(r, "rad) scaleY(").concat(n, ")") } })] }, dragStart: function (t, e) { var n = e.datas, r = e.parentEvent, i = e.parentGesto, o = t.state, a = o.gestos, o = o.style; if (a.draggable) return !1; a.draggable = i || t.targetGesto, n.datas = {}, n.left = parseFloat(o.left || "") || 0, n.top = parseFloat(o.top || "") || 0, n.bottom = parseFloat(o.bottom || "") || 0, n.right = parseFloat(o.right || "") || 0, n.startValue = [0, 0], Un(t, e), ir(e, "translate"), n.absolutePoses = Y(t.state), n.prevDist = [0, 0], n.prevBeforeDist = [0, 0], n.isDrag = !1, n.deltaOffset = [0, 0]; i = nt(t, e, Q({ set: function (t) { n.startValue = t } }, rr(e))); return !1 !== (r || rt(t, "onDragStart", i)) ? (n.isDrag = !0, t.state.dragInfo = { startRect: t.getRect(), dist: [0, 0] }) : (a.draggable = null, n.isPinch = !1), !!n.isDrag && i }, drag: function (t, e) { if (e) { $n(e, "translate"); var n = e.datas, r = e.parentEvent, i = e.parentFlag, o = e.isPinch, a = e.isRequest, s = e.deltaOffset, u = e.distX, c = e.distY, l = n.isDrag, f = n.prevDist, p = n.prevBeforeDist, d = n.startValue; if (l) { s && (u += s[0], c += s[1]); var l = t.props, h = l.parentMoveable, g = !r && l.throttleDrag || 0, v = !r && l.throttleDragRotate || 0, m = 0, b = !1, x = !1, y = !1, E = !1, i = (!r && 0 < v && (u || c) && (l = I((l = l.startDragRotate || 0) + 180 * N([0, 0], [u, c]) / Math.PI, v) - l, S = c * Math.abs(Math.cos((l - 90) / 180 * Math.PI)), S = Gr([u * Math.abs(Math.cos(l / 180 * Math.PI)), S]), m = l * Math.PI / 180, u = S * Math.cos(m), c = S * Math.sin(m)), o || r || i || (S = (l = eo(t, u, c, v, a || s, n))[0], m = l[1], b = S.isSnap, x = S.isBound, y = m.isSnap, E = m.isBound, u += S.offset, c += m.offset), J(Qn({ datas: n, distX: u, distY: c }), d)), a = J(Kn({ datas: n, distX: u, distY: c }), d), s = (_t(a, A), _t(i, A), v || (b || x || (a[0] = I(a[0], g), i[0] = I(i[0], g)), y || E || (a[1] = I(a[1], g), i[1] = I(i[1], g))), z(i, d)), l = z(a, d), S = z(l, f), m = z(s, p), u = (n.prevDist = l, n.prevBeforeDist = s, n.passDelta = S, n.passDist = l, n.left + s[0]), c = n.top + s[1], v = n.right - s[0], b = n.bottom - s[1], x = Zn(n, "translate(".concat(a[0], "px, ").concat(a[1], "px)"), "translate(".concat(l[0], "px, ").concat(l[1], "px)")); if (ar(e, x), t.state.dragInfo.dist = r ? [0, 0] : l, r || h || !S.every(function (t) { return !t }) || !m.some(function (t) { return !t })) return E = (y = t.state).width, g = y.height, d = nt(t, e, Q({ transform: x, dist: l, delta: S, translate: a, beforeDist: s, beforeDelta: m, beforeTranslate: i, left: u, top: c, right: v, bottom: b, width: E, height: g, isPinch: o }, et({ transform: x }, e))), r || rt(t, "onDrag", d), d } } }, dragAfter: function (t, e) { var n = e.datas, r = n.deltaOffset; return !(!r[0] && !r[1]) && (n.deltaOffset = [0, 0], this.drag(t, Q(Q({}, e), { deltaOffset: r }))) }, dragEnd: function (t, e) { var n = e.parentEvent, r = e.datas; if (t.state.dragInfo = null, r.isDrag) return r.isDrag = !1, r = d(t, e, {}), n || rt(t, "onDragEnd", r), r }, dragGroupStart: function (t, e) { var n = e.datas, r = e.clientX, i = e.clientY, o = this.dragStart(t, e); if (!o) return !1; r = vi(t, this, "dragStart", [r || 0, i || 0], e, !1, "draggable"), i = rt(t, "onDragGroupStart", Q(Q({}, o), { targets: t.props.targets, events: r })); return n.isDrag = !1 !== i, !!n.isDrag && o }, dragGroup: function (t, e) { if (e.datas.isDrag) { var n = this.drag(t, e), e = vi(t, this, "drag", e.datas.passDelta, e, !1, "draggable"); if (n) return rt(t, "onDragGroup", t = Q({ targets: t.props.targets, events: e }, n)), t } }, dragGroupEnd: function (t, e) { var n, r = e.isDrag; if (e.datas.isDrag) return this.dragEnd(t, e), n = vi(t, this, "dragEnd", [0, 0], e, !1, "draggable"), rt(t, "onDragGroupEnd", d(t, e, { targets: t.props.targets, events: n })), r }, request: function (t) { var e = {}, n = t.getRect(), r = 0, i = 0; return { isControl: !1, requestStart: function () { return { datas: e } }, request: function (t) { return "x" in t ? r = t.x - n.left : "deltaX" in t && (r += t.deltaX), "y" in t ? i = t.y - n.top : "deltaY" in t && (i += t.deltaY), { datas: e, distX: r, distY: i } }, requestEnd: function () { return { datas: e, isDrag: !0 } } } }, unset: function (t) { t.state.gestos.draggable = null, t.state.dragInfo = null } }, Tn = si("resizable"), Do = { name: "resizable", ableGroup: "size", canPinch: !0, props: { resizable: Boolean, throttleResize: Number, renderDirections: Array, keepRatio: Boolean, resizeFormat: Function, keepRatioFinally: Boolean, edge: Boolean, checkResizableError: Boolean }, events: { onResizeStart: "resizeStart", onBeforeResize: "beforeResize", onResize: "resize", onResizeEnd: "resizeEnd", onResizeGroupStart: "resizeGroupStart", onBeforeResizeGroup: "beforeResizeGroup", onResizeGroup: "resizeGroup", onResizeGroupEnd: "resizeGroupEnd" }, render: So("resizable"), dragControlCondition: Tn, viewClassName: ai("resizable"), dragControlStart: function (r, t) { var e = t.inputEvent, n = t.isPinch, i = t.isGroup, o = t.parentDirection, a = t.parentGesto, s = t.datas, u = t.parentFixedDirection, c = t.parentEvent, o = Wr(o, n, e, s), e = r.state, l = e.target, f = e.width, p = e.height, d = e.gestos; if (!o || !l) return !1; if (d.resizable) return !1; d.resizable = a || r.controlGesto, n || Un(r, t), s.datas = {}, s.direction = o, s.startOffsetWidth = f, s.startOffsetHeight = p, s.prevWidth = 0, s.prevHeight = 0, s.minSize = [0, 0], s.startWidth = e.inlineCSSWidth || e.cssWidth, s.startHeight = e.inlineCSSHeight || e.cssHeight, s.maxSize = [1 / 0, 1 / 0], i || (s.minSize = [e.minOffsetWidth, e.minOffsetHeight], s.maxSize = [e.maxOffsetWidth, e.maxOffsetHeight]); l = r.props.transformOrigin || "% %"; function h(t) { s.ratio = t && isFinite(t) ? t : 0 } function g(t) { s.fixedDirection = t, s.fixedPosition = j(s.startPositions, t) } function v(t) { var e = r.state, n = e.width, e = e.height; s.fixedPosition = t, s.fixedDirection = dr(t, n, e) } function m(t) { s.minSize = [Z("".concat(t[0]), 0) || 0, Z("".concat(t[1]), 0) || 0] } function b(t) { t = [t[0] || 1 / 0, t[1] || 1 / 0]; at(t[0]) && !isFinite(t[0]) || (t[0] = Z("".concat(t[0]), 0) || 1 / 0), at(t[1]) && !isFinite(t[1]) || (t[1] = Z("".concat(t[1]), 0) || 1 / 0), s.maxSize = t } s.transformOrigin = l && x(l) ? l.split(" ") : l, s.startOffsetMatrix = e.offsetMatrix, s.startTransformOrigin = e.transformOrigin, s.isWidth = null != (d = null == t ? void 0 : t.parentIsWidth) ? d : !o[0] && !o[1] || o[0] || !o[1], s.startPositions = Y(r.state), h(f / p), g(u || [-o[0], -o[1]]), s.setFixedDirection = g, s.setFixedPosition = v, s.setMin = m, s.setMax = b; a = nt(r, t, { direction: o, startRatio: s.ratio, set: function (t) { var e = t[0], t = t[1]; s.startWidth = e, s.startHeight = t }, setMin: m, setMax: b, setRatio: h, setFixedDirection: g, setFixedPosition: v, setOrigin: function (t) { s.transformOrigin = t }, dragStart: X.dragStart(r, (new Hn).dragStart([0, 0], t)) }), n = c || rt(r, "onResizeStart", a); return s.startFixedDirection = s.fixedDirection, s.startFixedPosition = s.fixedPosition, !1 !== n && (s.isResize = !0, r.state.snapRenderInfo = { request: t.isRequest, direction: o }), !!s.isResize && a }, dragControl: function (t, n) { var r = n.datas, e = n.parentFlag, i = n.isPinch, o = n.parentKeepRatio, a = n.dragClient, s = n.parentDist, u = n.isRequest, c = n.isGroup, l = n.parentEvent, f = n.resolveMatrix, p = r.isResize, d = r.transformOrigin, h = r.startWidth, g = r.startHeight, v = r.prevWidth, m = r.prevHeight, b = r.minSize, x = r.maxSize, y = r.ratio, E = r.startOffsetWidth, S = r.startOffsetHeight, C = r.isWidth; if (p) { f && (p = t.state.is3d, f = r.startOffsetMatrix, D = r.startTransformOrigin, p = p ? 4 : 3, _ = Ge(ur(n)), D = Rr(f = nr(f, _ = p !== (f = Math.sqrt(_.length)) ? be(_, f, p) : _, D, p), E, S, p), r.startPositions = D, r.nextTargetMatrix = _, r.nextAllMatrix = f); var p = Ar(t.props, "resizable"), M = p.resizeFormat, D = p.throttleResize, w = void 0 === D ? e ? 0 : 1 : D, _ = p.parentMoveable, f = p.keepRatioFinally, D = r.direction, R = D, O = 0, P = 0, T = (D[0] || D[1] || (R = [1, 1]), y && (null != o ? o : p.keepRatio) || !1), o = B(), G = o[0], z = o[1], p = (l || (r.setFixedDirection(r.fixedDirection), rt(t, "onBeforeResize", nt(t, n, { startFixedDirection: r.startFixedDirection, startFixedPosition: r.startFixedPosition, setFixedDirection: function (t) { return r.setFixedDirection(t), t = B(), G = t[0], z = t[1], [G, z] }, setFixedPosition: function (t) { return r.setFixedPosition(t), t = B(), G = t[0], z = t[1], [G, z] }, boundingWidth: G, boundingHeight: z, setSize: function (t) { G = t[0], z = t[1] } }, !0))), a), o = (a || (p = !e && i ? vr(t, [0, 0]) : r.fixedPosition), [0, 0]), u = (i || (o = function (t, n, r, e, i, o, a) { if (!Si(t, "resizable")) return [0, 0]; var s = a.fixedDirection, u = a.nextAllMatrix, c = t.state, l = c.allMatrix, f = c.is3d; return po(t, function (t, e) { return lo(u || l, n + t, r + e, s, i, f) }, n, r, e, i, o, a) }(t, G, z, D, p, u, r)), s && (s[0] || (o[0] = 0), s[1] || (o[1] = 0)), T ? (R[0] && R[1] && o[0] && o[1] && (Math.abs(o[0]) > Math.abs(o[1]) ? o[1] = 0 : o[0] = 0), (a = !o[0] && !o[1]) && k(), R[0] && !R[1] || o[0] && !o[1] || a && C ? (G += o[0], z = G / y) : (!R[0] && R[1] || !o[0] && o[1] || a && !C) && (z += o[1], G = z * y)) : (G += o[0], z += o[1], G = Math.max(0, G), z = Math.max(0, z)), e = function (t, n, r, e) { if (!e) return t.map(function (t, e) { return St(t, n[e], r[e]) }); var i = t[0], o = t[1], a = (s = Ct(t, n, !1, e = !0 === e ? i / o : e))[0], s = s[1], e = (t = Ct(t, r, !0, e))[0], t = t[1]; return i < a || o < s ? (i = a, o = s) : (e < i || t < o) && (i = e, o = t), [i, o] }([G, z], b, x, !!T && y), G = e[0], z = e[1], k(), T && (c || f) && (C ? z = G / y : G = z * y), [(O = G - E) - v, (P = z - S) - m]), s = (r.prevWidth = O, r.prevHeight = P, gr(t, G, z, p, d, r)); if (_ || !u.every(function (t) { return !t }) || !s.every(function (t) { return !t })) return o = (a = X.drag(t, Ln(n, t.state, s, !!i, !1, "draggable"))).transform, e = nt(t, n, Q({ width: b = h + O, height: x = g + P, offsetWidth: Math.round(G), offsetHeight: Math.round(z), startRatio: y, boundingWidth: G, boundingHeight: z, direction: D, dist: [O, P], delta: u, isPinch: !!i, drag: a }, Vr({ style: { width: "".concat(b, "px"), height: "".concat(x, "px") }, transform: o }, a, n))), l || rt(t, "onResize", e), e } function B() { var t = r.fixedDirection, e = di(R, T, r, n), e = (O = e.distWidth, P = e.distHeight, R[0] - t[0] || T ? Math.max(E + O, A) : E), t = R[1] - t[1] || T ? Math.max(S + P, A) : S; return T && E && S && (C ? t = e / y : e = t * y), [e, t] } function k() { var t; M && (t = M([G, z]), G = t[0], z = t[1]), G = I(G, w), z = I(z, w) } }, dragControlAfter: function (t, e) { var n = e.datas, r = n.isResize, i = n.startOffsetWidth, o = n.startOffsetHeight, a = n.prevWidth, s = n.prevHeight; if (r && !1 !== t.props.checkResizableError) return r = t.state, i = r.width - (i + a), a = r.height - (o + s), r = 3 < Math.abs(i), o = 3 < Math.abs(a), r && (n.startWidth += i, n.startOffsetWidth += i, n.prevWidth += i), o && (n.startHeight += a, n.startOffsetHeight += a, n.prevHeight += a), r || o ? this.dragControl(t, e) : void 0 }, dragControlEnd: function (t, e) { var n = e.datas, r = e.parentEvent; if (n.isResize) return n.isResize = !1, n = d(t, e, {}), r || rt(t, "onResizeEnd", n), n }, dragGroupControlCondition: Tn, dragGroupControlStart: function (i, t) { var o = t.datas, e = this.dragControlStart(i, Q(Q({}, t), { isGroup: !0 })); if (!e) return !1; var a = gi(i, "resizable", t); function r(t, e) { var n = o.fixedDirection, r = o.fixedPosition, t = j(e.datas.startPositions || Y(t.state), n), n = G(Re(-i.rotation / 180 * Math.PI, 3), [t[0] - r[0], t[1] - r[1], 1], 3), t = n[0], r = n[1]; return e.datas.originalX = t, e.datas.originalY = r, e } var s = o.startOffsetWidth, u = o.startOffsetHeight; function n() { var r = o.minSize; a.forEach(function (t) { var t = t.datas, e = t.minSize, n = t.startOffsetWidth, t = t.startOffsetHeight, n = s * (n ? e[0] / n : 0), e = u * (t ? e[1] / t : 0); r[0] = Math.max(r[0], n), r[1] = Math.max(r[1], e) }) } function c() { var r = o.maxSize; a.forEach(function (t) { var t = t.datas, e = t.maxSize, n = t.startOffsetWidth, t = t.startOffsetHeight, n = s * (n ? e[0] / n : 0), e = u * (t ? e[1] / t : 0); r[0] = Math.min(r[0], n), r[1] = Math.min(r[1], e) }) } function l(n) { e.setFixedDirection(n), f.forEach(function (t, e) { t.setFixedDirection(n), r(t.moveable, a[e]) }) } var f = mi(i, this, "dragControlStart", t, r), t = (n(), c(), o.setFixedDirection = l, Q(Q({}, e), { targets: i.props.targets, events: f.map(function (e) { return Q(Q({}, e), { setMin: function (t) { e.setMin(t), n() }, setMax: function (t) { e.setMax(t), c() } }) }), setFixedDirection: l, setMin: function (t) { e.setMin(t), n() }, setMax: function (t) { e.setMax(t), c() } })), t = rt(i, "onResizeGroupStart", t); return o.isResize = !1 !== t, !!o.isResize && e }, dragGroupControl: function (i, e) { var t = e.datas; if (t.isResize) { var n, o, a, s, r, u, c = Ar(i.props, "resizable"), l = (Ur(i, "onBeforeResize", function (t) { rt(i, "onBeforeResizeGroup", nt(i, e, Q(Q({}, t), { targets: c.targets }), !0)) }), this.dragControl(i, Q(Q({}, e), { isGroup: !0 }))); if (l) return r = l.boundingWidth, u = l.boundingHeight, n = l.dist, o = c.keepRatio, a = [r / (r - n[0]), u / (u - n[1])], s = t.fixedPosition, r = mi(i, this, "dragControl", e, function (t, e) { var n = G(Re(i.rotation / 180 * Math.PI, 3), [e.datas.originalX * a[0], e.datas.originalY * a[1], 1], 3), r = n[0], n = n[1]; return Q(Q({}, e), { parentDist: null, parentScale: a, dragClient: J(s, [r, n]), parentKeepRatio: o }) }), u = Q({ targets: c.targets, events: r }, l), rt(i, "onResizeGroup", u), u } }, dragGroupControlEnd: function (t, e) { var n, r = e.isDrag; if (e.datas.isResize) return this.dragControlEnd(t, e), n = mi(t, this, "dragControlEnd", e), rt(t, "onResizeGroupEnd", d(t, e, { targets: t.props.targets, events: n })), r }, request: function (t) { var e = {}, n = 0, r = 0, i = t.getRect(); return { isControl: !0, requestStart: function (t) { return { datas: e, parentDirection: t.direction || [1, 1], parentIsWidth: null == (t = null == t ? void 0 : t.horizontal) || t } }, request: function (t) { return "offsetWidth" in t ? n = t.offsetWidth - i.offsetWidth : "deltaWidth" in t && (n += t.deltaWidth), "offsetHeight" in t ? r = t.offsetHeight - i.offsetHeight : "deltaHeight" in t && (r += t.deltaHeight), { datas: e, parentDist: [n, r], parentKeepRatio: t.keepRatio } }, requestEnd: function () { return { datas: e, isDrag: !0 } } } }, unset: function (t) { t.state.gestos.resizable = null } }; function wo(t, e, n, r, i) { var o = t.props.groupable, a = t.state, s = a.is3d ? 4 : 3, u = e.origin, t = F(t.state.rootMatrix, z([u[0], u[1]], o ? [0, 0] : [a.left, a.top]), s), u = J([i.left, i.top], t); e.startAbsoluteOrigin = u, e.prevDeg = N(u, [n, r]) / Math.PI * 180, e.defaultDeg = e.prevDeg, e.prevSnapDeg = 0, e.loop = 0, e.startDist = wt(u, [n, r]) } function _o(t, e, n) { var r = n.defaultDeg, i = n.prevDeg, o = i % 360, i = Math.floor(i / 360), o = (o < 0 && (o += 360), t < o && 270 < o && t < 90 ? ++i : o < t && o < 90 && 270 < t && --i, e * (360 * i + t - r)); return n.prevDeg = r + o, o } function Ro(t, e, n, r) { return _o(N(r.startAbsoluteOrigin, [t, e]) / Math.PI * 180, n, r) } function Oo(t, e, n, r, i, o) { var a = t.props.throttleRotate, a = void 0 === a ? 0 : a, s = n.prevSnapDeg, u = 0, c = !1, t = (o && (c = (o = function (t, e, n) { if (!Si(t, "rotatable")) return { isSnap: !1, rotation: n }; var r = e.pos1, i = e.pos2, o = e.pos3, a = e.pos4, s = e.origin, u = n * Math.PI / 180, r = (e = [r, i, o, a].map(function (t) { return z(t, s) })).map(function (t) { return De(t, u) }); return (i = tt(tt([], Vi(t, e, r, s, n), !0), Xi(t, e, r, s, n), !0)).sort(function (t, e) { return Math.abs(t - n) - Math.abs(e - n) }), { isSnap: o = 0 < i.length, rotation: o ? i[0] : n } }(t, e, r)).isSnap, u = i + o.rotation), (u = c ? u : I(i + r, a)) - i); return [(n.prevSnapDeg = t) - s, t, u] } function Po(t, e) { if (e.isRequest) return "rotatable" === e.requestAble; var n = e.inputEvent.target; if (T(n, B("rotation-control")) || t.props.rotateAroundControls && T(n, B("around-control")) || T(n, B("control")) && T(n, B("rotatable"))) return !0; e = t.props.rotationTarget; return !!e && li(e, !0).some(function (t) { return !!t && (n === t || n.contains(t)) }) } fe = { name: "rotatable", canPinch: !0, props: { rotatable: Boolean, rotationPosition: String, throttleRotate: Number, renderDirections: Object, rotationTarget: Object, rotateAroundControls: Boolean, edge: Boolean, resolveAblesWithRotatable: Object }, events: { onRotateStart: "rotateStart", onBeforeRotate: "beforeRotate", onRotate: "rotate", onRotateEnd: "rotateEnd", onRotateGroupStart: "rotateGroupStart", onBeforeRotateGroup: "beforeRotateGroup", onRotateGroup: "rotateGroup", onRotateGroupEnd: "rotateGroupEnd" }, css: [".rotation {\n    position: absolute;\n    height: 40px;\n    width: 1px;\n    transform-origin: 50% 100%;\n    height: calc(40px * var(--zoom));\n    top: auto;\n    left: 0;\n    bottom: 100%;\n    will-change: transform;\n}\n.rotation .rotation-line {\n    display: block;\n    width: 100%;\n    height: 100%;\n    transform-origin: 50% 50%;\n}\n.rotation .rotation-control {\n    border-color: #4af;\n    border-color: var(--moveable-color);\n    background:#fff;\n    cursor: alias;\n}\n:global .view-rotation-dragging, .rotatable.direction.control {\n    cursor: alias;\n}\n.rotatable.direction.control.move {\n    cursor: move;\n}\n"], viewClassName: function (t) { return t.isDragging("rotatable") ? B("view-rotation-dragging") : "" }, render: function (t, r) { var e = Ar(t.props, "rotatable"), n = e.rotatable, i = e.rotationPosition, o = e.zoom, a = e.renderDirections, s = e.rotateAroundControls, u = e.resolveAblesWithRotatable, e = t.getState(), c = e.renderPoses, e = e.direction; if (!n) return null; var l, n = function e(t, n, r) { var i = n[0], o = n[1], a = n[2], s = n[3]; if ("none" === t) return []; if (w(t)) return t.map(function (t) { return e(t, [i, o, a, s], r)[0] }); var n = (t || "top").split("-"), t = n[0], n = n[1], u = [i, o], c = ("left" === t ? u = [a, i] : "right" === t ? u = [o, s] : "bottom" === t && (u = [s, a]), [(u[0][0] + u[1][0]) / 2, (u[0][1] + u[1][1]) / 2]), l = Nr(u, r); return n && (t = "bottom" === t || "left" === t, c = u[(u = "top" === n || "left" === n) && !t || !u && t ? 0 : 1]), [[c, l]] }(i, c, e), f = []; return n.forEach(function (t, e) { var n = t[0], t = t[1]; f.push(r.createElement("div", { key: "rotation".concat(e), className: B("rotation"), style: { transform: "translate(-50%) translate(".concat(n[0], "px, ").concat(n[1], "px) rotate(").concat(t, "rad)") } }, r.createElement("div", { className: B("line rotation-line"), style: { transform: "scaleX(".concat(o, ")") } }), r.createElement("div", { className: B("control rotation-control"), style: { transform: "translate(0.5px) scale(".concat(o, ")") } }))) }), a && (i = Et(u || {}), l = {}, i.forEach(function (e) { u[e].forEach(function (t) { l[t] = e }) }), c = [], w(a) && (c = a.map(function (t) { var e = l[t]; return { data: e ? { resolve: e } : {}, classNames: e ? ["move"] : [], dir: t } })), f.push.apply(f, bo(t, "rotatable", c, r))), s && f.push.apply(f, Mo(t, r)), f }, dragControlCondition: Po, dragControlStart: function (i, t) { var o = t.datas, e = t.clientX, n = t.clientY, r = t.parentRotate, a = t.parentFlag, s = t.isPinch, u = t.isRequest, c = i.state, l = c.target, f = c.left, p = c.top, d = c.direction, h = c.beforeDirection, g = c.targetTransform, v = c.moveableClientRect, m = c.offsetMatrix, b = c.targetMatrix, x = c.allMatrix, y = c.width, E = c.height; if (!u && !l) return !1; var S, C, M, D, w, l = i.getRect(), _ = (o.rect = l, o.transform = g, o.left = f, o.top = p, function (t) { var e = i.state, n = e.allMatrix, r = e.is3d, e = dr(t, e.width, e.height); o.fixedDirection = e, o.fixedPosition = F(n, t, r ? 4 : 3), P && P.setFixedPosition(t) }), g = function (t) { o.fixedDirection = t, o.fixedPosition = hr(i, t), P && P.setFixedDirection(t) }, R = e, O = n, p = (u || s || a ? (o.beforeInfo = { origin: l.beforeOrigin, prevDeg: f = r || 0, defaultDeg: f, prevSnapDeg: 0, startDist: 0 }, o.afterInfo = Q(Q({}, o.beforeInfo), { origin: l.origin }), o.absoluteInfo = Q(Q({}, o.beforeInfo), { origin: l.origin, startValue: f })) : ((e = null == (p = t.inputEvent) ? void 0 : p.target) && (n = e.getAttribute("data-direction") || "", (u = Yn[n]) && (o.isControl = !0, o.isAroundControl = T(e, B("around-control")), o.controlDirection = u, (s = e.getAttribute("data-resolve")) && (o.resolveAble = s), C = c.rootMatrix, a = c.renderPoses, r = v, M = 16 === C.length ? 4 : 3, a = a.map(function (t) { return F(C, t, M) }), D = r.left, w = r.top, R = (f = j(a.map(function (t) { return [t[0] + D, t[1] + w] }), u))[0], O = f[1])), o.beforeInfo = { origin: l.beforeOrigin }, o.afterInfo = { origin: l.origin }, o.absoluteInfo = { origin: l.origin, startValue: l.rotation }, S = _, _ = function (t) { var e = c.is3d ? 4 : 3, n = J(ve(b, e), t), r = n[0], n = n[1], r = G(m, me([r, n], e)), n = G(x, me([t[0], t[1]], e)), e = (S(t), c.posDelta); o.beforeInfo.origin = z(r, e), o.afterInfo.origin = z(n, e), o.absoluteInfo.origin = z(n, e), wo(i, o.beforeInfo, R, O, v), wo(i, o.afterInfo, R, O, v), wo(i, o.absoluteInfo, R, O, v) }, g = function (t) { t = j([[0, 0], [y, 0], [0, E], [y, E]], t); _(t) }), o.startClientX = R, o.startClientY = O, o.direction = d, o.beforeDirection = h, o.startValue = 0, o.datas = {}, ir(t, "rotate"), !1), P = !1, n = ((P = o.isControl && o.resolveAble && "resizable" === o.resolveAble ? Do.dragControlStart(i, Q(Q({}, new Hn("resizable").dragStart([0, 0], t)), { parentPosition: o.controlPosition, parentFixedPosition: o.fixedPosition })) : P) || (p = X.dragStart(i, (new Hn).dragStart([0, 0], t))), _(c.transformOrigin), nt(i, t, Q(Q({ set: function (t) { o.startValue = t * Math.PI / 180 }, setFixedDirection: g, setFixedPosition: _ }, rr(t)), { dragStart: p, resizeStart: P }))), e = rt(i, "onRotateStart", n); return o.isRotate = !1 !== e, c.snapRenderInfo = { request: t.isRequest }, !!o.isRotate && n }, dragControl: function (t, e) { var n = e.datas, r = e.clientDistX, i = e.clientDistY, o = e.parentRotate, a = e.parentFlag, s = e.isPinch, u = e.groupDelta, c = n.beforeDirection, l = n.beforeInfo, f = n.afterInfo, p = n.absoluteInfo, d = n.isRotate, h = n.startValue, g = n.rect, v = n.startClientX, m = n.startClientY; if (d) { $n(e, "rotate"); var b, x, y, d = c * Tr(e.datas.beforeTransform, [50, 50], 100, 100).direction, E = t.props.parentMoveable, S = 180 / Math.PI * h, h = p.startValue, C = !1, v = v + r, r = m + i; if (!a && "parentDist" in e ? (m = e.parentDist, y = x = b = m) : s || a ? (b = _o(o, c, l), x = _o(o, d, f), y = _o(o, d, p)) : (b = Ro(v, r, c, l), x = Ro(v, r, d, f), y = Ro(v, r, d, p), C = !0), rt(t, "onBeforeRotate", nt(t, e, { beforeRotation: S + b, rotation: S + x, absoluteRotation: h + y, setRotation: function (t) { y = b = x = t - S } }, !0)), m = (i = Oo(t, g, l, b, S, C))[0], b = i[1], a = i[2], c = (o = Oo(t, g, f, x, S, C))[0], x = o[1], d = o[2], i = (l = Oo(t, g, p, y, h, C))[0], y = l[1], f = l[2], i || c || m || E) return o = Zn(n, "rotate(".concat(d, "deg)"), "rotate(".concat(x, "deg)")), g = x, C = (h = n).fixedDirection, l = h.fixedPosition, u = z(J(u || [0, 0], E = pr(t, "rotate(".concat(g, "deg)"), C, l, h)), n.prevInverseDist || [0, 0]), n.prevInverseDist = E, n.requestValue = null, C = g = fr(t, o, u, s, e), l = wt([v, r], p.startAbsoluteOrigin) - p.startDist, h = void 0, "resizable" === n.resolveAble && (E = Do.dragControl(t, Q(Q({}, Ln(e, t.state, [e.deltaX, e.deltaY], !!s, !1, "resizable")), { resolveMatrix: !0, parentDistance: l }))) && (C = Vr(C, h = E, e)), rt(t, "onRotate", o = nt(t, e, Q(Q({ delta: c, dist: x, rotate: d, rotation: d, beforeDist: b, beforeDelta: m, beforeRotate: a, beforeRotation: a, absoluteDist: y, absoluteDelta: i, absoluteRotate: f, absoluteRotation: f, isPinch: !!s, resize: h }, g), C))), o } }, dragControlEnd: function (t, e) { var n = e.datas; if (n.isRotate) return n.isRotate = !1, n = d(t, e, {}), rt(t, "onRotateEnd", n), n }, dragGroupControlCondition: Po, dragGroupControlStart: function (t, e) { var n = e.datas, r = t.state, i = r.left, o = r.top, a = r.beforeOrigin, r = this.dragControlStart(t, e); if (!r) return !1; r.set(n.beforeDirection * t.rotation); e = mi(t, this, "dragControlStart", e, function (t, e) { var t = t.state, n = t.left, r = t.top, t = t.beforeOrigin, n = J(z([n, r], [i, o]), z(t, a)); return e.datas.startGroupClient = n, e.datas.groupClient = n, Q(Q({}, e), { parentRotate: 0 }) }), t = rt(t, "onRotateGroupStart", Q(Q({}, r), { targets: t.props.targets, events: e })); return n.isRotate = !1 !== t, !!n.isRotate && r }, dragGroupControl: function (e, n) { var t = n.datas; if (t.isRotate) { Ur(e, "onBeforeRotate", function (t) { rt(e, "onBeforeRotateGroup", nt(e, n, Q(Q({}, t), { targets: e.props.targets }), !0)) }); var a, s, u, r = this.dragControl(e, n); if (r) return a = t.beforeDirection, s = r.beforeDist, u = s / 180 * Math.PI, t = mi(e, this, "dragControl", n, function (t, e) { var n = e.datas.startGroupClient, r = e.datas.groupClient, i = r[0], r = r[1], n = De(n, u * a), o = n[0], n = n[1], i = [o - i, n - r]; return e.datas.groupClient = [o, n], Q(Q({}, e), { parentRotate: s, groupDelta: i }) }), e.rotation = a * r.beforeRotation, t = Q({ targets: e.props.targets, events: t, set: function (t) { e.rotation = t }, setGroupRotation: function (t) { e.rotation = t } }, r), rt(e, "onRotateGroup", t), t } }, dragGroupControlEnd: function (t, e) { var n, r = e.isDrag; if (e.datas.isRotate) return this.dragControlEnd(t, e), n = mi(t, this, "dragControlEnd", e), rt(t, "onRotateGroupEnd", d(t, e, { targets: t.props.targets, events: n })), r }, request: function (t) { var e = {}, n = 0, r = t.getRotation(); return { isControl: !0, requestStart: function () { return { datas: e } }, request: function (t) { return "deltaRotate" in t ? n += t.deltaRotate : "rotate" in t && (n = t.rotate - r), { datas: e, parentDist: n } }, requestEnd: function () { return { datas: e, isDrag: !0 } } } } }, e = si("scalable"), t = { name: "scalable", ableGroup: "size", canPinch: !0, props: { scalable: Boolean, throttleScale: Number, renderDirections: String, keepRatio: Boolean, edge: Boolean }, events: { onScaleStart: "scaleStart", onBeforeScale: "beforeScale", onScale: "scale", onScaleEnd: "scaleEnd", onScaleGroupStart: "scaleGroupStart", onBeforeScaleGroup: "beforeScaleGroup", onScaleGroup: "scaleGroup", onScaleGroupEnd: "scaleGroupEnd" }, render: So("scalable"), dragControlCondition: e, viewClassName: ai("scalable"), dragControlStart: function (t, e) { var n = e.datas, r = e.isPinch, i = e.inputEvent, i = Wr(e.parentDirection, r, i, n), o = t.state, a = o.width, s = o.height, u = o.targetTransform, c = o.target, l = o.pos1, f = o.pos2, o = o.pos4; if (!i || !c) return !1; r || Un(t, e), n.datas = {}, n.transform = u, n.prevDist = [1, 1], n.direction = i, n.startOffsetWidth = a, n.startOffsetHeight = s, n.startValue = [1, 1]; c = wt(l, f), r = wt(f, o), u = !i[0] && !i[1] || i[0] || !i[1]; function p(t) { n.ratio = t && isFinite(t) ? t : 0 } function d(t) { n.fixedDirection = t, n.fixedPosition = j(n.startPositions, t) } n.scaleWidth = c, n.scaleHeight = r, n.scaleXRatio = c / a, n.scaleYRatio = r / s, ir(e, "scale"), n.isWidth = u, n.startPositions = Y(t.state), n.setFixedDirection = d, p(wt(l, f) / wt(f, o)), d([-i[0], -i[1]]); c = nt(t, e, Q(Q({ direction: i, set: function (t) { n.startValue = t }, setRatio: p, setFixedDirection: d }, rr(e)), { dragStart: X.dragStart(t, (new Hn).dragStart([0, 0], e)) })), a = rt(t, "onScaleStart", c); return n.startFixedDirection = n.fixedDirection, !1 !== a && (n.isScale = !0, t.state.snapRenderInfo = { request: e.isRequest, direction: i }), !!n.isScale && c }, dragControl: function (t, n) { $n(n, "scale"); var r = n.datas, e = n.parentKeepRatio, i = n.parentFlag, o = n.isPinch, a = n.dragClient, s = n.isRequest, u = r.prevDist, c = r.direction, l = r.startOffsetWidth, f = r.startOffsetHeight, p = r.isScale, d = r.startValue, h = r.isWidth, g = r.ratio; if (!p) return !1; var p = t.props, v = p.throttleScale, m = p.parentMoveable, b = c, x = (c[0] || c[1] || (b = [1, 1]), g && (null != e ? e : p.keepRatio) || !1), e = t.state; function y() { var t = di(b, x, r, n), e = t.distWidth, t = t.distHeight, e = l ? (l + e) / l : 1, t = f ? (f + t) / f : 1, e = b[0] || x ? e * d[0] : d[0], t = b[1] || x ? t * d[1] : d[1]; return [e = 0 === e ? 1e-9 * (0 < u[0] ? 1 : -1) : e, t = 0 === t ? 1e-9 * (0 < u[1] ? 1 : -1) : t] } var E = y(), p = (o || !t.props.groupable || w(p = (e.snapRenderInfo || {}).direction) && (p[0] || p[1]) && (e.snapRenderInfo = { direction: c, request: n.isRequest }), rt(t, "onBeforeScale", nt(t, n, { scale: E, setFixedDirection: function (t) { return r.setFixedDirection(t), E = y() }, startFixedDirection: r.startFixedDirection, setScale: function (t) { E = t } }, !0)), [E[0] / d[0], E[1] / d[1]]), e = a, S = [0, 0], i = (a || (e = !i && o ? vr(t, [0, 0]) : r.fixedPosition), o || (S = ho(t, p, c, s, r)), x ? (b[0] && b[1] && S[0] && S[1] && (Math.abs(S[0] * l) > Math.abs(S[1] * f) ? S[1] = 0 : S[0] = 0), (a = !S[0] && !S[1]) && (h ? p[0] = I(p[0] * d[0], v) / d[0] : p[1] = I(p[1] * d[1], v) / d[1]), b[0] && !b[1] || S[0] && !S[1] || a && h ? (p[0] += S[0], i = l * p[0] * d[0] / g, p[1] = i / f / d[1]) : (!b[0] && b[1] || !S[0] && S[1] || a && !h) && (p[1] += S[1], s = f * p[1] * d[1] * g, p[0] = s / l / d[0])) : (p[0] += S[0], p[1] += S[1], S[0] || (p[0] = I(p[0] * d[0], v) / d[0]), S[1] || (p[1] = I(p[1] * d[1], v) / d[1])), 0 === p[0] && (p[0] = 1e-9 * (0 < u[0] ? 1 : -1)), 0 === p[1] && (p[1] = 1e-9 * (0 < u[1] ? 1 : -1)), [p[0] / u[0], p[1] / u[1]]), s = (E = [p[0] * d[0], p[1] * d[1]], a = r.fixedDirection, h = e, g = r, pr(t, "scale(".concat(p.join(", "), ")"), a, h, g)), S = z(s, r.prevInverseDist || [0, 0]); if (r.prevDist = p, r.prevInverseDist = s, E[0] === u[0] && E[1] === u[1] && S.every(function (t) { return !t }) && !m) return !1; v = Zn(r, "scale(".concat(E.join(", "), ")"), "scale(".concat(p.join(", "), ")")), e = nt(t, n, Q({ offsetWidth: l, offsetHeight: f, direction: c, scale: E, dist: p, delta: i, isPinch: !!o }, fr(t, v, S, o, n))); return rt(t, "onScale", e), e }, dragControlEnd: function (t, e) { var n = e.datas; if (!n.isScale) return !1; n.isScale = !1; n = d(t, e, {}); return rt(t, "onScaleEnd", n), n }, dragGroupControlCondition: e, dragGroupControlStart: function (i, t) { var o = t.datas, e = this.dragControlStart(i, t); if (!e) return !1; var r = gi(i, "resizable", t); function a(t, e) { var n = o.fixedDirection, r = o.fixedPosition, t = j(e.datas.startPositions || Y(t.state), n), n = G(Re(-i.rotation / 180 * Math.PI, 3), [t[0] - r[0], t[1] - r[1], 1], 3), t = n[0], r = n[1]; return e.datas.originalX = t, e.datas.originalY = r, e } o.moveableScale = i.scale; function n(n) { e.setFixedDirection(n), s.forEach(function (t, e) { t.setFixedDirection(n), a(t.moveable, r[e]) }) } var s = mi(i, this, "dragControlStart", t, a), t = (o.setFixedDirection = n, Q(Q({}, e), { targets: i.props.targets, events: s, setFixedDirection: n })), u = rt(i, "onScaleGroupStart", t); return o.isScale = !1 !== u, !!o.isScale && t }, dragGroupControl: function (i, e) { var t = e.datas; if (t.isScale) { Ur(i, "onBeforeScale", function (t) { rt(i, "onBeforeScaleGroup", nt(i, e, Q(Q({}, t), { targets: i.props.targets }), !0)) }); var o, a, s, u, n, r = this.dragControl(i, e); if (r) return n = t.moveableScale, i.scale = [r.scale[0] * n[0], r.scale[1] * n[1]], o = i.props.keepRatio, a = r.dist, s = r.scale, u = t.fixedPosition, n = mi(i, this, "dragControl", e, function (t, e) { var n = G(Re(i.rotation / 180 * Math.PI, 3), [e.datas.originalX * a[0], e.datas.originalY * a[1], 1], 3), r = n[0], n = n[1]; return Q(Q({}, e), { parentDist: null, parentScale: s, parentKeepRatio: o, dragClient: J(u, [r, n]) }) }), t = Q({ targets: i.props.targets, events: n }, r), rt(i, "onScaleGroup", t), t } }, dragGroupControlEnd: function (t, e) { var n, r = e.isDrag; if (e.datas.isScale) return this.dragControlEnd(t, e), n = mi(t, this, "dragControlEnd", e), rt(t, "onScaleGroupEnd", d(t, e, { targets: t.props.targets, events: n })), r }, request: function () { var e = {}, n = 0, r = 0; return { isControl: !0, requestStart: function (t) { return { datas: e, parentDirection: t.direction || [1, 1] } }, request: function (t) { return n += t.deltaWidth, r += t.deltaHeight, { datas: e, parentDist: [n, r], parentKeepRatio: t.keepRatio } }, requestEnd: function () { return { datas: e, isDrag: !0 } } } } }; function To(t, n) { return t.map(function (t, e) { return $(t, n[e], 1, 2) }) } function Go(t, e, n) { e = N(t, e), t = N(t, n) - e; return 0 <= t ? t : t + 2 * Math.PI } var a = { name: "warpable", ableGroup: "size", props: { warpable: Boolean, renderDirections: Array, edge: Boolean }, events: { onWarpStart: "warpStart", onWarp: "warp", onWarpEnd: "warpEnd" }, viewClassName: ai("warpable"), render: function (t, e) { var n = t.props, r = n.resizable, i = n.scalable, o = n.warpable, n = n.zoom; if (r || i || !o) return []; var r = t.state, i = r.pos1, o = r.pos2, a = r.pos3, r = r.pos4, s = To(i, o), u = To(o, i), c = To(i, a), i = To(a, i), l = To(a, r), a = To(r, a), f = To(o, r), r = To(r, o); return tt([e.createElement("div", { className: B("line"), key: "middeLine1", style: Br(s, l, n) }), e.createElement("div", { className: B("line"), key: "middeLine2", style: Br(u, a, n) }), e.createElement("div", { className: B("line"), key: "middeLine3", style: Br(c, f, n) }), e.createElement("div", { className: B("line"), key: "middeLine4", style: Br(i, r, n) })], Co(t, "warpable", e), !0) }, dragControlCondition: function (t, e) { if (e.isRequest) return !1; e = e.inputEvent.target; return T(e, B("direction")) && T(e, B("warpable")) }, dragControlStart: function (t, e) { var n = e.datas, r = e.inputEvent, i = t.props.target, r = qr(r.target, n); if (!r || !i) return !1; var i = t.state, o = i.transformOrigin, a = i.is3d, s = i.targetTransform, u = i.targetMatrix, c = i.width, l = i.height, f = i.left, p = i.top; return n.datas = {}, n.targetTransform = s, n.warpTargetMatrix = a ? u : be(u, 3, 4), n.targetInverseMatrix = he(ge(n.warpTargetMatrix, 4), 3, 4), n.direction = r, n.left = f, n.top = p, n.poses = [[0, 0], [c, 0], [0, l], [c, l]].map(function (t) { return z(t, o) }), n.nextPoses = n.poses.map(function (t) { var e = t[0], t = t[1]; return G(n.warpTargetMatrix, [e, t, 0, 1], 4) }), n.startValue = W(4), n.prevMatrix = W(4), n.absolutePoses = Y(i), n.posIndexes = er(r), Un(t, e), ir(e, "matrix3d"), !(i.snapRenderInfo = { request: e.isRequest, direction: r }) !== rt(t, "onWarpStart", nt(t, e, Q({ set: function (t) { n.startValue = t } }, rr(e)))) && (n.isWarp = !0), n.isWarp }, dragControl: function (t, e) { var n = e.datas, r = e.isRequest, i = e.distX, o = e.distY, a = n.targetInverseMatrix, s = n.prevMatrix, u = n.isWarp, c = n.startValue, l = n.poses, f = n.posIndexes, p = n.absolutePoses; if (!u) return !1; $n(e, "matrix3d"), Si(t, "warpable") && (1 < (u = f.map(function (t) { return p[t] })).length && u.push([(u[0][0] + u[1][0]) / 2, (u[0][1] + u[1][1]) / 2]), u = (r = no(t, r, { horizontal: u.map(function (t) { return t[1] + o }), vertical: u.map(function (t) { return t[0] + i }) })).horizontal, r = r.vertical, o -= u.offset, i -= r.offset); var d = tr({ datas: n, distX: i, distY: o }, !0), h = n.nextPoses.slice(); if (f.forEach(function (t) { h[t] = J(h[t], d) }), !Fn.every(function (t) { return e = t.map(function (t) { return l[t] }), t = t.map(function (t) { return h[t] }), e = Go(e[0], e[1], e[2]), t = Go(t[0], t[1], t[2]), !((n = Math.PI) <= e && t <= n || e <= n && n <= t); var e, n })) return !1; u = Te(l[0], l[2], l[1], l[3], h[0], h[2], h[1], h[3]); if (!u.length) return !1; r = Jn(n, K(a, u, 4), !0), f = K(ge(s, 4), r, 4), a = K(c, n.prevMatrix = r, 4), u = Zn(n, "matrix3d(".concat(a.join(", "), ")"), "matrix3d(".concat(r.join(", "), ")")); return ar(e, u), rt(t, "onWarp", nt(t, e, Q({ delta: f, matrix: a, dist: r, multiply: K, transform: u }, et({ transform: u }, e)))), !0 }, dragControlEnd: function (t, e) { var n = e.datas, r = e.isDrag; return !!n.isWarp && (n.isWarp = !1, rt(t, "onWarpEnd", d(t, e, {})), r) } }, zo = B("area-pieces"), Bo = B("area-piece"), ko = B("avoid"), Ao = B("view-dragging"); function Fo(t) { var e, n = t.areaElement; n && (e = (t = t.state).width, t = t.height, Ot(n, ko), n.style.cssText += "left: 0px; top: 0px; width: ".concat(e, "px; height: ").concat(t, "px")) } function No(t) { return t.createElement("div", { key: "area_pieces", className: zo }, t.createElement("div", { className: Bo }), t.createElement("div", { className: Bo }), t.createElement("div", { className: Bo }), t.createElement("div", { className: Bo })) } var Io = { name: "dragArea", props: { dragArea: Boolean, passDragArea: Boolean }, events: { onClick: "click", onClickGroup: "clickGroup" }, render: function (t, e) { var n = t.props, r = n.target, i = n.dragArea, o = n.groupable, n = n.passDragArea, a = t.getState(), s = a.width, u = a.height, a = a.renderPoses, n = n ? B("area", "pass") : B("area"); if (o) return [e.createElement("div", { key: "area", ref: M(t, "areaElement"), className: n }), No(e)]; if (!r || !i) return []; o = Te([0, 0], [s, 0], [0, u], [s, u], a[0], a[1], a[2], a[3]), r = o.length ? wr(o, !0) : "none"; return [e.createElement("div", { key: "area", ref: M(t, "areaElement"), className: n, style: { top: "0px", left: "0px", width: "".concat(s, "px"), height: "".concat(u, "px"), transformOrigin: "0 0", transform: r } }), No(e)] }, dragStart: function (t, e) { var n = e.datas, r = e.clientX, i = e.clientY; if (!e.inputEvent) return !1; n.isDragArea = !1; var e = t.areaElement, n = t.state, t = n.moveableClientRect, o = n.renderPoses, a = n.rootMatrix, s = n.is3d, u = t.left, t = t.top, o = Or(o), c = o.left, l = o.top, f = o.width, o = o.height, a = ei(a, [r - u, i - t], s ? 4 : 3), r = a[0], u = a[1], i = [{ left: c, top: l, width: f, height: (u -= l) - 10 }, { left: c, top: l, width: (r -= c) - 10, height: o }, { left: c, top: l + u + 10, width: f, height: o - u - 10 }, { left: c + r + 10, top: l, width: f - r - 10, height: o }], p = [].slice.call(e.nextElementSibling.children); i.forEach(function (t, e) { p[e].style.cssText = "left: ".concat(t.left, "px;top: ").concat(t.top, "px; width: ").concat(t.width, "px; height: ").concat(t.height, "px;") }), Rt(e, ko), n.disableNativeEvent = !0 }, drag: function (t, e) { var n = e.datas, e = e.inputEvent; if (this.enableNativeEvent(t), !e) return !1; n.isDragArea || (n.isDragArea = !0, Fo(t)) }, dragEnd: function (t, e) { this.enableNativeEvent(t); var n = e.inputEvent, e = e.datas; if (!n) return !1; e.isDragArea || Fo(t) }, dragGroupStart: function (t, e) { return this.dragStart(t, e) }, dragGroup: function (t, e) { return this.drag(t, e) }, dragGroupEnd: function (t, e) { return this.dragEnd(t, e) }, unset: function (t) { Fo(t), t.state.disableNativeEvent = !1 }, enableNativeEvent: function (t) { var e = t.state; e.disableNativeEvent && xt(function () { e.disableNativeEvent = !1 }) } }, Tn = Cn("origin", { render: function (t, e) { var n = t.props.zoom, t = t.getState(), r = t.beforeOrigin, t = t.rotation; return [e.createElement("div", { className: B("control", "origin"), style: kr(t, n, r), key: "beforeOrigin" })] } }); function jo(t) { t = t.scrollContainer; return [t.scrollLeft, t.scrollTop] } var e = { name: "scrollable", canPinch: !0, props: { scrollable: Boolean, scrollContainer: Object, scrollThreshold: Number, scrollThrottleTime: Number, getScrollPosition: Function, scrollOptions: Object }, events: { onScroll: "scroll", onScrollGroup: "scrollGroup" }, dragRelation: "strong", dragStart: function (r, n) { var t = r.props, e = t.scrollContainer, e = void 0 === e ? r.getContainer() : e, t = t.scrollOptions, i = new en, e = ci(e, !0), o = (n.datas.dragScroll = i, r.state.dragScroll = i, n.isControl ? "controlGesto" : "targetGesto"), a = n.targets; i.on("scroll", function (t) { var e = t.container, t = t.direction, e = nt(r, n, { scrollContainer: e, direction: t }), t = a ? "onScrollGroup" : "onScroll"; a && (e.targets = a), rt(r, t, e) }).on("move", function (t) { var e = t.offsetX, n = t.offsetY, t = t.inputEvent; r[o].scrollBy(e, n, t.inputEvent, !0) }).on("scrollDrag", function (t) { (0, t.next)(r[o].getCurrentEvent()) }), i.dragStart(n, Q({ container: e }, t)) }, checkScroll: function (t, e) { var n, r, i, o, a, s = e.datas.dragScroll; if (s) return n = t.props, r = n.scrollContainer, t = void 0 === r ? t.getContainer() : r, r = n.scrollThreshold, i = n.scrollThrottleTime, a = n.getScrollPosition, o = void 0 === a ? jo : a, a = n.scrollOptions, s.drag(e, Q({ container: t, threshold: void 0 === r ? 0 : r, throttleTime: void 0 === i ? 0 : i, getScrollPosition: function (t) { return o({ scrollContainer: t.container, direction: t.direction }) } }, a)), !0 }, drag: function (t, e) { return this.checkScroll(t, e) }, dragEnd: function (t, e) { e.datas.dragScroll.dragEnd(), e.datas.dragScroll = null }, dragControlStart: function (t, e) { return this.dragStart(t, Q(Q({}, e), { isControl: !0 })) }, dragControl: function (t, e) { return this.drag(t, e) }, dragControlEnd: function (t, e) { return this.dragEnd(t, e) }, dragGroupStart: function (t, e) { return this.dragStart(t, Q(Q({}, e), { targets: t.props.targets })) }, dragGroup: function (t, e) { return this.drag(t, Q(Q({}, e), { targets: t.props.targets })) }, dragGroupEnd: function (t, e) { return this.dragEnd(t, Q(Q({}, e), { targets: t.props.targets })) }, dragGroupControlStart: function (t, e) { return this.dragStart(t, Q(Q({}, e), { targets: t.props.targets, isControl: !0 })) }, dragGroupControl: function (t, e) { return this.drag(t, Q(Q({}, e), { targets: t.props.targets })) }, dragGroupControEnd: function (t, e) { return this.dragEnd(t, Q(Q({}, e), { targets: t.props.targets })) }, unset: function (t) { var e, t = t.state; null != (e = t.dragScroll) && e.dragEnd(), t.dragScroll = null } }, Yo = { name: "", props: { target: Object, dragTarget: Object, container: Object, portalContainer: Object, rootContainer: Object, useResizeObserver: Boolean, zoom: Number, transformOrigin: Array, edge: Object, ables: Array, className: String, pinchThreshold: Number, pinchOutside: Boolean, triggerAblesSimultaneously: Boolean, checkInput: Boolean, cspNonce: String, translateZ: Number, hideDefaultLines: Boolean, props: Object, flushSync: Function, stopPropagation: Boolean, preventClickEventOnDrag: Boolean, preventClickDefault: Boolean, viewContainer: Object, persistData: Object, useAccuratePosition: Boolean, firstRenderState: Object, linePadding: Boolean, displayAroundControls: Boolean, controlPadding: Number, preventDefault: Boolean, requestStyles: Array }, events: { onChangeTargets: "changeTargets" } }, Xo = Cn("padding", { render: function (t, r) { var e = t.props; if (e.dragArea) return []; var e = e.padding || {}, n = e.left, n = void 0 === n ? 0 : n, i = e.top, i = void 0 === i ? 0 : i, o = e.right, o = void 0 === o ? 0 : o, e = e.bottom, e = void 0 === e ? 0 : e, t = t.getState(), a = t.renderPoses, s = [t.pos1, t.pos2, t.pos3, t.pos4], t = []; return 0 < n && t.push([0, 2]), 0 < i && t.push([0, 1]), 0 < o && t.push([1, 3]), 0 < e && t.push([2, 3]), t.map(function (t, e) { var n = t[0], t = t[1], n = Te([0, 0], [100, 0], [0, 100], [100, 100], s[n], s[t], a[n], a[t]); if (n.length) return r.createElement("div", { key: "padding".concat(e), className: B("padding"), style: { transform: wr(n, !0) } }) }) } }), Wo = ["nw", "ne", "se", "sw"]; function qo(t, e) { var n = t[0] + t[1], n = e < n ? e / n : 1; return t[0] *= n, t[1] = e - t[1] * n, t } var Lo = [1, 2, 5, 6], Ho = [0, 3, 4, 7], Vo = [1, -1, -1, 1], Uo = [1, 1, -1, -1]; function $o(t, i, o, a, s, u, c, l) { void 0 === s && (s = 0), void 0 === u && (u = 0), void 0 === c && (c = o), void 0 === l && (l = a); var f = [], p = !1, t = t.filter(function (t) { return !t.virtual }), e = t.map(function (t) { var e, n = t.horizontal, r = t.vertical, t = t.pos; return r && !p && (p = !0, f.push("/")), p ? (e = Math.max(0, 1 === r ? t[1] - u : l - t[1]), f.push(ii(e, a, i))) : (e = Math.max(0, 1 === n ? t[0] - s : c - t[0]), f.push(ii(e, o, i))), e }); return { radiusPoses: t, styles: f, raws: e } } function Zo(t) { for (var e = [0, 0], n = [0, 0], r = t.length, i = 0; i < r; ++i) { var o = t[i]; o.sub && (o.horizontal && (0 === e[1] && (e[0] = i), e[1] = i - e[0] + 1, n[0] = i + 1), o.vertical && (0 === n[1] && (n[0] = i), n[1] = i - n[0] + 1)) } return { horizontalRange: e, verticalRange: n } } function Ko(t, r, i, o, a, e, n) { void 0 === e && (e = [0, 0]), void 0 === n && (n = !1); var s = t.indexOf("/"), s = (-1 < s ? t.slice(0, s) : t).length, u = t.slice(0, s), t = t.slice(s + 1), c = u.length, l = t.length, s = 0 < l, f = u[0], f = void 0 === f ? "0px" : f, p = u[1], p = void 0 === p ? f : p, d = u[2], d = void 0 === d ? f : d, u = u[3], u = void 0 === u ? p : u, h = t[0], h = void 0 === h ? f : h, g = t[1], g = void 0 === g ? s ? h : p : g, v = t[2], v = void 0 === v ? s ? h : d : v, t = t[3], s = void 0 === t ? s ? g : u : t, m = [f, p, d, u].map(function (t) { return Z(t, r) }), b = [h, g, v, s].map(function (t) { return Z(t, i) }), t = m.slice(), f = b.slice(), p = qo([t[0], t[1]], r), g = (t[0] = p[0], t[1] = p[1], d = qo([t[3], t[2]], r), t[3] = d[0], t[2] = d[1], u = qo([f[0], f[3]], i), f[0] = u[0], f[3] = u[1], h = qo([f[1], f[2]], i), f[1] = h[0], f[2] = h[1], n ? t : t.slice(0, Math.max(e[0], c))), v = n ? f : f.slice(0, Math.max(e[1], l)); return tt(tt([], g.map(function (t, e) { var n = Wo[e]; return { virtual: c <= e, horizontal: Vo[e], vertical: 0, pos: [o + t, a + (-1 === Uo[e] ? i : 0)], sub: !0, raw: m[e], direction: n } }), !0), v.map(function (t, e) { var n = Wo[e]; return { virtual: l <= e, horizontal: 0, vertical: Uo[e], pos: [o + (-1 === Vo[e] ? r : 0), a + t], sub: !0, raw: b[e], direction: n } }), !0) } var Jo = [[0, -1, "n"], [1, 0, "e"]], Qo = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]]; function ta(t, e, n) { var r = t.props.clipRelative, t = t.state, i = t.width, o = t.height, t = e.type, e = e.poses, a = "rect" === t, s = "circle" === t; if ("polygon" === t) return n.map(function (t) { return "".concat(ii(t[0], i, r), " ").concat(ii(t[1], o, r)) }); if (a || "inset" === t) { var u = n[1][1], c = n[3][0], l = n[7][0], f = n[5][1]; if (a) return [u, c, f, l].map(function (t) { return "".concat(t, "px") }); var p, d = [u, i - c, o - f, l].map(function (t, e) { return ii(t, e % 2 ? i : o, r) }); return 8 < n.length && (p = (a = z(n[4], n[0]))[0], a = a[1], d.push.apply(d, tt(["round"], $o(e.slice(8).map(function (t, e) { return Q(Q({}, t), { pos: n[e] }) }), r, p, a, l, u, c, f).styles, !1))), d } return s || "ellipse" === t ? (e = n[0], p = ii(Math.abs(n[1][1] - e[1]), s ? Math.sqrt((i * i + o * o) / 2) : o, r), (d = s ? [p] : [ii(Math.abs(n[2][0] - e[0]), i, r), p]).push("at", ii(e[0], i, r), ii(e[1], o, r)), d) : void 0 } function ea(t, e, n, r) { var o = [r, (r + e) / 2, e], a = [t, (t + n) / 2, n]; return Qo.map(function (t) { var e = t[0], n = t[1], t = t[2], r = o[e + 1], i = a[n + 1]; return { vertical: Math.abs(n), horizontal: Math.abs(e), direction: t, pos: [r, i] } }) } function na(t) { var e = [1 / 0, -1 / 0], n = [1 / 0, -1 / 0]; return t.forEach(function (t) { t = t.pos; e[0] = Math.min(e[0], t[0]), e[1] = Math.max(e[1], t[0]), n[0] = Math.min(n[0], t[1]), n[1] = Math.max(n[1], t[1]) }), [Math.abs(e[1] - e[0]), Math.abs(n[1] - n[0])] } function ra(t, n, r, e, i) { if (t) { var o, a, s, u, c, l, f, p, d, h, g, v, m, b, x, y; if ((i = i ? i : "none" !== (o = (t = getComputedStyle(t)).clipPath) ? o : t.clip) && "none" !== i && "auto" !== i || (i = e)) return t = (o = dt(i)).prefix, o = void 0 === (e = o.value) ? "" : e, t = "circle" === (e = void 0 === t ? i : t), a = " ", "polygon" === e ? (a = ",", d = Ye((y = (h = pt(o || "0% 0%, 100% 0%, 100% 100%, 0% 100%")).map(function (t) { var t = t.split(" "), e = t[0], t = t[1]; return { vertical: 1, horizontal: 1, pos: [Z(e, n), Z(t, r)] } })).map(function (t) { return t.pos })), { type: e, clipText: i, poses: y, splitter: a, left: d.minX, right: d.maxX, top: d.minY, bottom: d.maxY }) : t || "ellipse" === e ? (f = d = "", u = s = 0, h = ft(o), u = t ? (p = h[0], d = void 0 === (l = h[2]) ? "50%" : l, f = void 0 === (l = h[3]) ? "50%" : l, s = Z(void 0 === p ? "50%" : p, Math.sqrt((n * n + r * r) / 2))) : (l = "", p = h[0], l = void 0 === (g = h[1]) ? "50%" : g, d = void 0 === (g = h[3]) ? "50%" : g, f = void 0 === (g = h[4]) ? "50%" : g, s = Z(void 0 === p ? "50%" : p, n), Z(l, r)), y = tt([{ vertical: 1, horizontal: 1, pos: c = [Z(d, n), Z(f, r)], direction: "nesw" }], Jo.slice(0, t ? 1 : 2).map(function (t) { return { vertical: Math.abs(t[1]), horizontal: t[0], direction: t[2], sub: !0, pos: [c[0] + t[0] * s, c[1] + t[1] * u] } }), !0), { type: e, clipText: i, radiusX: s, radiusY: u, left: c[0] - s, top: c[1] - u, right: c[0] + s, bottom: c[1] + u, poses: y, splitter: a }) : "inset" === e ? (p = (-1 < (g = (h = ft(o || "0 0 0 0")).indexOf("round")) ? h.slice(0, g) : h).length, l = h.slice(p + 1), f = (d = h.slice(0, p))[0], g = void 0 === (t = d[1]) ? f : t, p = d[2], d = void 0 === (t = d[3]) ? g : t, v = (t = [f, void 0 === p ? f : p].map(function (t) { return Z(t, r) }))[0], b = t[1], x = (f = [d, g].map(function (t) { return Z(t, n) }))[0], m = f[1], d = Ko(l, (p = n - m) - x, (t = r - b) - v, x, v), { type: "inset", clipText: i, poses: y = tt(tt([], ea(v, p, t, x), !0), d, !0), top: v, left: x, right: p, bottom: t, radius: l, splitter: a }) : "rect" === e ? (a = ",", { type: "rect", clipText: i, poses: y = ea(v = (g = (h = pt(o || "0px, ".concat(n, "px, ").concat(r, "px, 0px"))).map(function (t) { return ht(t).value }))[0], m = g[1], b = g[2], x = g[3]), top: v, right: m, bottom: b, left: x, values: h, splitter: a }) : void 0 } } function ia(t, e) { var n = Vn(t, e), r = n[0], n = n[1], i = e.datas, o = i.clipPath, i = i.clipIndex, a = o.type, s = o.poses, u = o.splitter, c = s.map(function (t) { return t.pos }); if ("polygon" === a) c.splice(i, 0, [r, n]); else { if ("inset" !== a) return; var l = Lo.indexOf(i), i = Ho.indexOf(i), f = s.length, p = s, d = c, h = 8, g = l, v = i, m = r, b = n, x = c[4][0], y = c[4][1], E = c[0][0], S = c[0][1], i = (void 0 === E && (E = 0), void 0 === S && (S = 0), (l = Zo(p.slice(h))).horizontalRange), l = l.verticalRange; if (-1 < g) for (var C = 1 === Vo[g] ? m - E : x - m, M = i[1]; M <= g; ++M) { var D = 1 === Uo[M] ? S : y, w = 0; if (g === M ? w = m : 0 === M ? w = E + C : -1 === Vo[M] && (w = x - (d[h][0] - E)), p.splice(h + M, 0, { horizontal: Vo[M], vertical: 0, pos: [w, D] }), d.splice(h + M, 0, [w, D]), 0 === M) break } else if (-1 < v) for (var _ = 1 === Uo[v] ? b - S : y - b, R = (0 === i[1] && 0 === l[1] && (p.push({ horizontal: Vo[0], vertical: 0, pos: i = [E + _, S] }), d.push(i)), l[0]), M = l[1]; M <= v; ++M) { w = 1 === Vo[M] ? E : x, D = 0; if (v === M ? D = b : 0 === M ? D = S + _ : 1 === Uo[M] ? D = d[h + R][1] : -1 === Uo[M] && (D = y - (d[h + R][1] - S)), p.push({ horizontal: 0, vertical: Uo[M], pos: [w, D] }), d.push([w, D]), 0 === M) break } if (f === s.length) return } r = ta(t, o, c), n = "".concat(a, "(").concat(r.join(u), ")"); rt(t, "onClip", nt(t, e, Q({ clipEventType: "added", clipType: a, poses: c, clipStyles: r, clipStyle: n, distX: 0, distY: 0 }, et({ clipPath: n }, e)))) } function oa(t, e) { var n = e.datas, r = n.clipPath, n = n.clipIndex, i = r.type, o = r.poses, a = r.splitter, s = o.map(function (t) { return t.pos }), u = s.length; if ("polygon" === i) o.splice(n, 1), s.splice(n, 1); else { if ("inset" !== i) return; if (n < 8) return; if (!function (t, e, n, r, i) { void 0 === i && (i = e.length); var o = (a = Zo(t.slice(r))).horizontalRange, a = a.verticalRange, s = 0; if (0 == (r = n - r)) s = i; else if (0 < r && r < o[1]) s = o[1] - r; else { if (!(r >= a[0])) return; s = a[0] + a[1] - r } t.splice(n, s), e.splice(n, s) }(o, s, n, 8, u), u === o.length) return } n = ta(t, r, s), u = "".concat(i, "(").concat(n.join(a), ")"); rt(t, "onClip", nt(t, e, Q({ clipEventType: "removed", clipType: i, poses: s, clipStyles: n, clipStyle: u, distX: 0, distY: 0 }, et({ clipPath: u }, e)))) } var aa = { name: "clippable", props: { clippable: Boolean, defaultClipPath: String, customClipPath: String, keepRatio: Boolean, clipRelative: Boolean, clipArea: Boolean, dragWithClip: Boolean, clipTargetBounds: Boolean, clipVerticalGuidelines: Array, clipHorizontalGuidelines: Array, clipSnapThreshold: Boolean }, events: { onClipStart: "clipStart", onClip: "clip", onClipEnd: "clipEnd" }, css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"], render: function (t, o) { var e = t.props, n = e.customClipPath, r = e.defaultClipPath, i = e.clipArea, a = e.zoom, e = e.groupable, t = t.getState(), s = t.target, u = t.width, c = t.height, l = t.allMatrix, f = t.is3d, p = t.left, d = t.top, h = t.pos1, g = t.pos2, v = t.pos3, m = t.pos4, b = t.clipPathState, x = t.snapBoundInfos, y = t.rotation; if (!s || e) return []; t = ra(s, u, c, r || "inset", b || n); if (!t) return []; var E, S, C, M = f ? 4 : 3, e = t.type, s = t.poses.map(function (t) { t = F(l, t.pos, M); return [t[0] - p, t[1] - d] }), r = [], D = [], b = "rect" === e, n = "inset" === e, f = "polygon" === e; if ((b || n || f) && (E = n ? s.slice(0, 8) : s, D = E.map(function (t, e) { var n = 0 === e ? E[E.length - 1] : E[e - 1], r = N(n, t), t = zr(n, t); return o.createElement("div", { key: "clipLine".concat(e), className: B("line", "clip-line", "snap-control"), "data-clip-index": e, style: { width: "".concat(t, "px"), transform: "translate(".concat(n[0], "px, ").concat(n[1], "px) rotate(").concat(r, "rad) scaleY(").concat(a, ")") } }) })), r = s.map(function (t, e) { return o.createElement("div", { key: "clipControl".concat(e), className: B("control", "clip-control", "snap-control"), "data-clip-index": e, style: { transform: "translate(".concat(t[0], "px, ").concat(t[1], "px) rotate(").concat(y, "rad) scale(").concat(a, ")") } }) }), n && r.push.apply(r, s.slice(8).map(function (t, e) { return o.createElement("div", { key: "clipRadiusControl".concat(e), className: B("control", "clip-control", "clip-radius", "snap-control"), "data-clip-index": 8 + e, style: { transform: "translate(".concat(t[0], "px, ").concat(t[1], "px) rotate(").concat(y, "rad) scale(").concat(a, ")") } }) })), "circle" === e || "ellipse" === e) { var e = t.left, w = t.top, _ = t.radiusX, R = t.radiusY, t = z(F(l, [e, w], M), F(l, [0, 0], M)), e = t[0], w = t[1], t = "none"; if (!i) { for (var O = Math.max(10, _ / 5, R / 5), P = [], T = 0; T <= O; ++T) { var G = 2 * Math.PI / O * T; P.push([_ + (_ - a) * Math.cos(G), R + (R - a) * Math.sin(G)]) } P.push([_, -2]), P.push([-2, -2]), P.push([-2, 2 * R + 2]), P.push([2 * _ + 2, 2 * R + 2]), P.push([2 * _ + 2, -2]), P.push([_, -2]), t = "polygon(".concat(P.map(function (t) { return "".concat(t[0], "px ").concat(t[1], "px") }).join(", "), ")") } r.push(o.createElement("div", { key: "clipEllipse", className: B("clip-ellipse", "snap-control"), style: { width: "".concat(2 * _, "px"), height: "".concat(2 * R, "px"), clipPath: t, transform: "translate(".concat(-p + e, "px, ").concat(-d + w, "px) ").concat(wr(l)) } })) } return i && (e = (t = Or(tt([h, g, v, m], s, !0))).width, w = t.height, S = t.left, C = t.top, (f || b || n) && (P = n ? s.slice(0, 8) : s, r.push(o.createElement("div", { key: "clipArea", className: B("clip-area", "snap-control"), style: { width: "".concat(e, "px"), height: "".concat(w, "px"), transform: "translate(".concat(S, "px, ").concat(C, "px)"), clipPath: "polygon(".concat(P.map(function (t) { return "".concat(t[0] - S, "px ").concat(t[1] - C, "px") }).join(", "), ")") } })))), x && ["vertical", "horizontal"].forEach(function (r) { var t = x[r], i = "horizontal" === r; t.isSnap && D.push.apply(D, t.snap.posInfos.map(function (t, e) { var t = t.pos, n = z(F(l, i ? [0, t] : [t, 0], M), [p, d]), t = z(F(l, i ? [u, t] : [t, c], M), [p, d]); return yo(o, "", n, t, a, "clip".concat(r, "snap").concat(e), "guideline") })), t.isBound && D.push.apply(D, t.bounds.map(function (t, e) { var t = t.pos, n = z(F(l, i ? [0, t] : [t, 0], M), [p, d]), t = z(F(l, i ? [u, t] : [t, c], M), [p, d]); return yo(o, "", n, t, a, "clip".concat(r, "bounds").concat(e), "guideline", "bounds", "bold") })) }), tt(tt([], r, !0), D, !0) }, dragControlCondition: function (t, e) { return e.inputEvent && -1 < (e.inputEvent.target.getAttribute("class") || "").indexOf("clip") }, dragStart: function (t, e) { var n = t.props.dragWithClip; return void 0 !== n && !n && this.dragControlStart(t, e) }, drag: function (t, e) { return this.dragControl(t, Q(Q({}, e), { isDragTarget: !0 })) }, dragEnd: function (t, e) { return this.dragControlEnd(t, e) }, dragControlStart: function (t, e) { var n = t.state, r = t.props, i = r.defaultClipPath, r = r.customClipPath, o = n.target, a = n.width, s = n.height, u = e.inputEvent ? e.inputEvent.target : null, c = u && u.getAttribute("class") || "", l = e.datas, o = ra(o, a, s, i || "inset", r); if (!o) return !1; a = o.clipText; return !1 === rt(t, "onClipStart", nt(t, e, { clipType: o.type, clipStyle: a, poses: o.poses.map(function (t) { return t.pos }) })) ? l.isClipStart = !1 : (l.isControl = c && -1 < c.indexOf("clip-control"), l.isLine = -1 < c.indexOf("clip-line"), l.isArea = -1 < c.indexOf("clip-area") || -1 < c.indexOf("clip-ellipse"), l.clipIndex = u ? parseInt(u.getAttribute("data-clip-index"), 10) : -1, l.clipPath = o, l.isClipStart = !0, n.clipPathState = a, Un(t, e), !0) }, dragControl: function (t, e) { var n = e.datas, r = e.originalDatas, A = e.isDragTarget; if (!n.isClipStart) return !1; var i = n.isControl, o = n.isLine, a = n.isArea, s = n.clipIndex, n = n.clipPath; if (!n) return !1; var u, c, F, N, I, l, f, p, j, d, h, g, v, Y, X, W = Ar(t.props, "clippable"), m = W.keepRatio, b = 0, x = 0, r = r.draggable, q = tr(e), x = A && r ? (L = r.prevBeforeDist, b = L[0], L[1]) : (b = q[0], q[1]), L = [b, x], y = t.state, H = y.width, V = y.height, a = !a && !i && !o, o = n.type, E = n.poses, U = n.splitter, S = E.map(function (t) { return t.pos }), a = (a && (b = -b, x = -x), !i || "nesw" === E[s].direction), $ = "inset" === o || "rect" === o, C = E.map(function () { return [0, 0] }), M = (i && !a ? (f = (w = E[s]).horizontal, w = w.vertical, f = [b * Math.abs(f), x * Math.abs(w)], c = f, w = $, f = m, O = (P = (u = E)[G = s]).direction, P = P.sub, l = u.map(function () { return [0, 0] }), T = O ? O.split("") : [], w && G < 8 ? (w = T.filter(function (t) { return "w" === t || "e" === t }), _ = T.filter(function (t) { return "n" === t || "s" === t }), F = w[0], N = _[0], l[G] = c, _ = (w = na(u))[0], w = w[1], (M = _ && w ? _ / w : 0) && f ? (f = u[(G + 4) % 8].pos, D = [0, 0], -1 < O.indexOf("w") ? D[0] = -1 : -1 < O.indexOf("e") && (D[0] = 1), -1 < O.indexOf("n") ? D[1] = -1 : -1 < O.indexOf("s") && (D[1] = 1), M = _ + (_ = pi([_, w], c, M, D, !0))[0], w = w + _[1], _ = f[1], p = f[1], R = f[0], f = f[0], -1 === D[0] ? R = f - M : 1 === D[0] ? f = R + M : (R -= M / 2, f += M / 2), -1 === D[1] ? _ = p - w : p = 1 === D[1] ? _ + w : (_ = p - w / 2) + w, I = ea(_, f, p, R), u.forEach(function (t, e) { l[e][0] = I[e].pos[0] - t.pos[0], l[e][1] = I[e].pos[1] - t.pos[1] })) : (u.forEach(function (t, e) { t = t.direction; t && (-1 < t.indexOf(F) && (l[e][0] = c[0]), -1 < t.indexOf(N) && (l[e][1] = c[1])) }), F && (l[1][0] = c[0] / 2, l[5][0] = c[0] / 2), N && (l[3][1] = c[1] / 2, l[7][1] = c[1] / 2))) : O && !P ? T.forEach(function (i) { var o = "n" === i || "s" === i; u.forEach(function (t, e) { var n = t.direction, r = t.horizontal, t = t.vertical; n && -1 !== n.indexOf(i) && (l[e] = [o || !r ? 0 : c[0], o && t ? c[1] : 0]) }) }) : l[G] = c, C = l) : a && (C = S.map(function () { return [b, x] })), S.map(function (t, e) { return J(t, C[e]) })), D = tt([], M, !0), w = (y.snapBoundInfos = null, "circle" === n.type), _ = "ellipse" === n.type, R = ((w || _) && (d = Or(M), f = Math.abs(d.bottom - d.top), p = Math.abs(_ ? d.right - d.left : f), h = M[0][1] + f, g = M[0][0] - p, v = M[0][0] + p, w && (D.push([v, d.bottom]), C.push([1, 0])), D.push([d.left, h]), C.push([0, 1]), D.push([g, d.bottom]), C.push([1, 0])), uo((W.clipHorizontalGuidelines || []).map(function (t) { return Z("".concat(t), V) }), (W.clipVerticalGuidelines || []).map(function (t) { return Z("".concat(t), H) }), H, V)), O = [], P = [], T = (P = w || _ ? (O = [D[4][0], D[2][0]], [D[1][1], D[3][1]]) : $ ? (X = [D[0], D[2], D[4], D[6]], j = [C[0], C[2], C[4], C[6]], O = X.filter(function (t, e) { return j[e][0] }).map(function (t) { return t[0] }), X.filter(function (t, e) { return j[e][1] }).map(function (t) { return t[1] })) : (O = D.filter(function (t, e) { return C[e][0] }).map(function (t) { return t[0] }), D.filter(function (t, e) { return C[e][1] }).map(function (t) { return t[1] })), [0, 0]), G = ro(R, W.clipTargetBounds && { left: 0, top: 0, right: H, bottom: V }, O, P, 5), a = G.horizontal, S = G.vertical, z = a.offset, B = S.offset, a = (a.isBound && (T[1] += z), S.isBound && (T[0] += B), (_ || w) && 0 === C[0][0] && 0 === C[0][1] ? (k = (d = Or(M)).bottom - d.top, d = _ ? d.right - d.left : k, d -= S.isBound ? Math.abs(B) : 0 === S.snapIndex ? -B : B, k -= a.isBound ? Math.abs(z) : 0 === a.snapIndex ? -z : z, w && (d = k = 0 < Ti(S, a) ? k : d), S = D[0], D[1][1] = S[1] - k, D[2][0] = S[0] + d, D[3][1] = S[1] + k, D[4][0] = S[0] - d) : $ && m && i ? (k = (a = na(E))[0], S = a[1], d = k && S ? k / S : 0, m = E[s].direction || "", i = D[1][1], h = D[5][1], g = D[7][0], v = D[3][0], z <= B ? z = B / d : B = z * d, -1 < m.indexOf("w") ? g -= B : -1 < m.indexOf("e") ? v -= B : (g += B / 2, v -= B / 2), -1 < m.indexOf("n") ? i -= z : -1 < m.indexOf("s") ? h -= z : (i += z / 2, h -= z / 2), Y = ea(i, v, h, g), D.forEach(function (t, e) { e = Y[e].pos; t[0] = e[0], t[1] = e[1] })) : D.forEach(function (t, e) { e = C[e]; e[0] && (t[0] -= B), e[1] && (t[1] -= z) }), ta(t, n, M)), k = "".concat(o, "(").concat(a.join(U), ")"); return y.clipPathState = k, P = w || _ ? (O = [D[4][0], D[2][0]], [D[1][1], D[3][1]]) : $ ? (O = (X = [D[0], D[2], D[4], D[6]]).map(function (t) { return t[0] }), X.map(function (t) { return t[1] })) : (O = D.map(function (t) { return t[0] }), D.map(function (t) { return t[1] })), y.snapBoundInfos = ro(R, W.clipTargetBounds && { left: 0, top: 0, right: H, bottom: V }, O, P, 1), r && (S = y.is3d, E = y.allMatrix, s = T, A && (s = [L[0] + T[0] - q[0], L[1] + T[1] - q[1]]), r.deltaOffset = K(E, [s[0], s[1], 0, 0], S ? 4 : 3)), rt(t, "onClip", nt(t, e, Q({ clipEventType: "changed", clipType: o, poses: M, clipStyle: k, clipStyles: a, distX: b, distY: x }, et(((d = {})["rect" === o ? "clip" : "clipPath"] = k, d), e)))), !0 }, dragControlEnd: function (t, e) { this.unset(t); var n = e.isDrag, r = e.datas, i = e.isDouble, o = r.isLine, a = r.isClipStart, r = r.isControl; return !!a && (rt(t, "onClipEnd", d(t, e, {})), i && (r ? oa(t, e) : o && ia(t, e)), i || n) }, unset: function (t) { t.state.clipPathState = "", t.state.snapBoundInfos = null } }, sa = { name: "originDraggable", props: { originDraggable: Boolean, originRelative: Boolean }, events: { onDragOriginStart: "dragOriginStart", onDragOrigin: "dragOrigin", onDragOriginEnd: "dragOriginEnd" }, css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"], dragControlCondition: function (t, e) { return e.isRequest ? "originDraggable" === e.requestAble : T(e.inputEvent.target, B("origin")) }, dragControlStart: function (t, e) { var n = e.datas, e = (Un(t, e), nt(t, e, { dragStart: X.dragStart(t, (new Hn).dragStart([0, 0], e)) })), r = rt(t, "onDragOriginStart", e); return n.startOrigin = t.state.transformOrigin, n.startTargetOrigin = t.state.targetOrigin, n.prevOrigin = [0, 0], !(n.isDragOrigin = !0) === r ? n.isDragOrigin = !1 : e }, dragControl: function (t, e) { var n = e.datas, r = e.isPinch, i = e.isRequest; if (!n.isDragOrigin) return !1; var o = tr(e), a = o[0], o = o[1], s = t.state, u = s.width, c = s.height, l = s.offsetMatrix, f = s.targetMatrix, s = s.is3d, p = t.props.originRelative, p = void 0 === p || p, s = s ? 4 : 3, a = [a, o], i = (!i || ((o = e.distOrigin)[0] || o[1]) && (a = o), J(n.startOrigin, a)), o = J(n.startTargetOrigin, a), d = z(a, n.prevOrigin), l = nr(l, f, i, s), f = t.getRect(), l = Or(Rr(l, u, c, s)), s = [f.left - l.left, f.top - l.top], f = (n.prevOrigin = a, [ii(o[0], u, p), ii(o[1], c, p)].join(" ")), l = X.drag(t, Ln(e, t.state, s, !!r, !1)), n = nt(t, e, Q(Q({ width: u, height: c, origin: i, dist: a, delta: d, transformOrigin: f, drag: l }, et({ transformOrigin: f, transform: l.transform }, e)), { afterTransform: l.transform })); return rt(t, "onDragOrigin", n), n }, dragControlEnd: function (t, e) { return !!e.datas.isDragOrigin && (rt(t, "onDragOriginEnd", d(t, e, {})), !0) }, dragGroupControlCondition: function (t, e) { return this.dragControlCondition(t, e) }, dragGroupControlStart: function (t, e) { return !!this.dragControlStart(t, e) }, dragGroupControl: function (t, e) { e = this.dragControl(t, e); return !!e && (t.transformOrigin = e.transformOrigin, !0) }, request: function (t) { var e = {}, n = t.getRect(), r = 0, i = 0, o = n.transformOrigin, a = [0, 0]; return { isControl: !0, requestStart: function () { return { datas: e } }, request: function (t) { return "deltaOrigin" in t ? (a[0] += t.deltaOrigin[0], a[1] += t.deltaOrigin[1]) : "origin" in t ? (a[0] = t.origin[0] - o[0], a[1] = t.origin[1] - o[1]) : ("x" in t ? r = t.x - n.left : "deltaX" in t && (r += t.deltaX), "y" in t ? i = t.y - n.top : "deltaY" in t && (i += t.deltaY)), { datas: e, distX: r, distY: i, distOrigin: a } }, requestEnd: function () { return { datas: e, isDrag: !0 } } } } }; function ua(t, e, n, r, i) { void 0 === r && (r = [0, 0]); return Ko(t && "0px" !== t ? ft(t) : [], e, n, 0, 0, r, i) } function ca(t, e, n, r, i) { var o, a = t.state, s = a.width, u = a.height, i = $o(i, t.props.roundRelative, s, u), c = i.raws, l = i.styles, i = i.radiusPoses, c = (i = i, void 0 === (o = c) && (o = i.map(function (t) { return t.raw })), { horizontals: i.map(function (t, e) { return t.horizontal ? o[e] : null }).filter(function (t) { return null != t }), verticals: i.map(function (t, e) { return t.vertical ? o[e] : null }).filter(function (t) { return null != t }) }), i = c.horizontals, c = c.verticals, l = l.join(" "), a = (a.borderRadiusState = l, nt(t, e, Q({ horizontals: i, verticals: c, borderRadius: l, width: s, height: u, delta: r, dist: n }, et({ borderRadius: l }, e)))); return rt(t, "onRound", a), a } function la(t) { var e = t.getState().style, n = e.borderRadius || ""; return !n && t.props.groupable && (n = t.moveables[0].state.style.borderRadius, e.borderRadius = n), n } var fa = { name: "roundable", props: { roundable: Boolean, roundRelative: Boolean, minRoundControls: Array, maxRoundControls: Array, roundClickable: Boolean, roundPadding: Number, isDisplayShadowRoundControls: Boolean }, events: { onRoundStart: "roundStart", onRound: "round", onRoundEnd: "roundEnd", onRoundGroupStart: "roundGroupStart", onRoundGroup: "roundGroup", onRoundGroupEnd: "roundGroupEnd" }, css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n    z-index: 3;\n}", ".control.border-radius.vertical {\n    background: #d6d;\n    z-index: 2;\n}", ".control.border-radius.virtual {\n    opacity: 0.5;\n    z-index: 1;\n}", ":host.round-line-clickable .line.direction {\n    cursor: pointer;\n}"], className: function (t) { t = t.props.roundClickable; return !0 === t || "line" === t ? B("round-line-clickable") : "" }, requestStyle: function () { return ["borderRadius"] }, requestChildStyle: function () { return ["borderRadius"] }, render: function (t, a) { var e = t.getState(), n = e.target, r = e.width, i = e.height, s = e.allMatrix, o = e.is3d, u = e.left, c = e.top, e = e.borderRadiusState, l = t.props, f = l.minRoundControls, f = void 0 === f ? [0, 0] : f, p = l.maxRoundControls, d = void 0 === p ? [4, 4] : p, h = l.zoom, p = l.roundPadding, g = void 0 === p ? 0 : p, v = l.isDisplayShadowRoundControls, p = l.groupable; if (!n) return null; var l = e || la(t), m = o ? 4 : 3, n = ua(l, r, i, f, !0); if (!n) return null; var b = 0, x = 0, y = p ? [0, 0] : [u, c]; return n.map(function (t, e) { var n = t.horizontal, r = t.vertical, i = t.direction || "", o = tt([], t.pos, !0), n = (x += Math.abs(n), b += Math.abs(r), n && -1 < i.indexOf("n") && (o[1] -= g), r && -1 < i.indexOf("w") && (o[0] -= g), n && -1 < i.indexOf("s") && (o[1] += g), r && -1 < i.indexOf("e") && (o[0] += g), z(F(s, o, m), y)), r = t.vertical ? b <= d[1] && (v || !t.virtual) : x <= d[0] && (v || !t.virtual); return a.createElement("div", { key: "borderRadiusControl".concat(e), className: B("control", "border-radius", t.vertical ? "vertical" : "", t.virtual ? "virtual" : ""), "data-radius-index": e, style: { display: r ? "block" : "none", transform: "translate(".concat(n[0], "px, ").concat(n[1], "px) scale(").concat(h, ")") } }) }) }, dragControlCondition: function (t, e) { if (!e.inputEvent || e.isRequest) return !1; e = e.inputEvent.target.getAttribute("class") || ""; return -1 < e.indexOf("border-radius") || -1 < e.indexOf("moveable-line") && -1 < e.indexOf("moveable-direction") }, dragGroupControlCondition: function (t, e) { return this.dragControlCondition(t, e) }, dragControlStart: function (t, e) { var n = e.inputEvent, r = e.datas, n = n.target, i = n.getAttribute("class") || "", o = -1 < i.indexOf("border-radius"), i = -1 < i.indexOf("moveable-line") && -1 < i.indexOf("moveable-direction"), a = o ? parseInt(n.getAttribute("data-radius-index"), 10) : -1, s = -1; if (!i || (n = n.getAttribute("data-line-key") || "") && (s = parseInt(n.replace(/render-line-/g, ""), 10), isNaN(s) && (s = -1)), !o && !i) return !1; n = nt(t, e, {}); if (!1 === rt(t, "onRoundStart", n)) return !1; r.lineIndex = s, r.controlIndex = a, r.isControl = o, r.isLine = i, Un(t, e); s = t.props, a = s.roundRelative, o = s.minRoundControls, i = void 0 === o ? [0, 0] : o, e = t.state, s = e.width, o = e.height; r.isRound = !0, r.prevDist = [0, 0]; t = ua(la(t) || "", s, o, i, !0) || []; return r.controlPoses = t, e.borderRadiusState = $o(t, a, s, o).styles.join(" "), n }, dragControl: function (t, e) { var n = e.datas, r = n.controlPoses; if (!n.isRound || !n.isControl || !r.length) return !1; var i = n.controlIndex, o = tr(e), a = o[0], o = o[1], s = [a, o], u = z(s, n.prevDist), c = t.props.maxRoundControls, l = void 0 === c ? [4, 4] : c, c = t.state, f = c.width, p = c.height, c = r[i], d = c.vertical, h = c.horizontal, g = r.map(function (t) { var e = t.horizontal, t = t.vertical, n = [e * h * s[0], t * d * s[1]]; if (e) { if (1 === l[0]) return n; if (l[0] < 4 && e !== h) return n } else { if (0 === l[1]) return n[1] = t * h * s[0] / f * p, n; if (d) { if (1 === l[1]) return n; if (l[1] < 4 && t !== d) return n } } return [0, 0] }), c = (g[i] = s, r.map(function (t, e) { return Q(Q({}, t), { pos: J(t.pos, g[e]) }) })); return i < 4 ? c.slice(0, i + 1).forEach(function (t) { t.virtual = !1 }) : c.slice(4, i + 1).forEach(function (t) { t.virtual = !1 }), n.prevDist = [a, o], ca(t, e, s, u, c) }, dragControlEnd: function (t, e) { var n = t.state, r = (n.borderRadiusState = "", e.datas), i = e.isDouble; if (!r.isRound) return !1; var o, a = r.isControl, s = r.controlIndex, u = r.isLine, c = r.lineIndex, r = r.controlPoses, l = r.filter(function (t) { return t.virtual }).length, f = t.props.roundClickable, f = void 0 === f || f, p = (i && f && (!a || !0 !== f && "control" !== f ? !u || !0 !== f && "line" !== f || (a = (i = Vn(t, e))[0], u = i[1], f = c, i = a, c = u, u = (a = r).filter(function (t) { var e = t.virtual; return t.horizontal && !e }).length, p = a.filter(function (t) { var e = t.virtual; return t.vertical && !e }).length, o = -1, 0 === f && (0 === u ? o = 0 : 1 === u && (o = 1)), 2 === f && (u <= 2 ? o = 2 : u <= 3 && (o = 3)), 3 === f && (0 === p ? o = 4 : p < 4 && (o = 7)), 1 === f && (p <= 1 ? o = 5 : p <= 2 && (o = 6)), -1 !== o && a[o].virtual && (u = a[o], f = a, (p = o) < 4 ? f.slice(0, p + 1).forEach(function (t) { t.virtual = !1 }) : (f[0].virtual && (f[0].virtual = !1), f.slice(4, p + 1).forEach(function (t) { t.virtual = !1 })), o < 4 ? u.pos[0] = i : u.pos[1] = c)) : (a = r, (f = s) < 4 ? a.slice(f, 4).forEach(function (t) { t.virtual = !0 }) : a.slice(f).forEach(function (t) { t.virtual = !0 })), l !== r.filter(function (t) { return t.virtual }).length && ca(t, e, [0, 0], [0, 0], r)), d(t, e, {})); return rt(t, "onRoundEnd", p), n.borderRadiusState = "", p }, dragGroupControlStart: function (t, e) { var n = this.dragControlStart(t, e); if (!n) return !1; var r = t.moveables, i = t.props.targets, e = gi(t, "roundable", e); return rt(t, "onRoundGroupStart", Q({ targets: t.props.targets, events: e.map(function (t, e) { return Q(Q({}, t), { target: i[e], moveable: r[e], currentTarget: r[e] }) }) }, n)), n }, dragGroupControl: function (t, e) { var n = this.dragControl(t, e); if (!n) return !1; var r = t.moveables, i = t.props.targets, e = gi(t, "roundable", e), e = Q({ targets: t.props.targets, events: e.map(function (t, e) { return Q(Q(Q({}, t), { target: i[e], moveable: r[e], currentTarget: r[e] }), et({ borderRadius: n.borderRadius }, t)) }) }, n); return rt(t, "onRoundGroup", e), e }, dragGroupControlEnd: function (e, t) { var r = e.moveables, i = e.props.targets, o = gi(e, "roundable", t), t = (Ur(e, "onRound", function (n) { var t = Q({ targets: e.props.targets, events: o.map(function (t, e) { return Q(Q(Q({}, t), { target: i[e], moveable: r[e], currentTarget: r[e] }), et({ borderRadius: n.borderRadius }, t)) }) }, n); rt(e, "onRoundGroup", t) }), this.dragControlEnd(e, t)); if (!t) return !1; t = Q({ targets: e.props.targets, events: o.map(function (t, e) { return Q(Q({}, t), { target: i[e], moveable: r[e], currentTarget: r[e], lastEvent: null == (e = t.datas) ? void 0 : e.lastEvent }) }) }, t); return rt(e, "onRoundGroupEnd", t), t }, unset: function (t) { t.state.borderRadiusState = "" } }; var pa = { isPinch: !0, name: "beforeRenderable", props: {}, events: { onBeforeRenderStart: "beforeRenderStart", onBeforeRender: "beforeRender", onBeforeRenderEnd: "beforeRenderEnd", onBeforeRenderGroupStart: "beforeRenderGroupStart", onBeforeRenderGroup: "beforeRenderGroup", onBeforeRenderGroupEnd: "beforeRenderGroupEnd" }, dragRelation: "weak", setTransform: function (t, e) { var t = t.state, n = t.is3d, r = t.target, t = t.targetMatrix, r = null == r ? void 0 : r.style.transform, t = n ? "matrix3d(".concat(t.join(","), ")") : "matrix(".concat(ye(t, !0), ")"), r = r && "none" !== r ? r : t; e.datas.startTransforms = (t = r, n = W((e = n) ? 4 : 3), t === "matrix".concat(e ? "3d" : "", "(").concat(n.join(","), ")") || "matrix(1,0,0,1,0,0)" === t ? [] : ft(r)) }, resetStyle: function (t) { var e = t.datas; e.nextStyle = {}, e.nextTransforms = t.datas.startTransforms, e.nextTransformAppendedIndexes = [] }, fillDragStartParams: function (t, e) { return nt(t, e, { setTransform: function (t) { e.datas.startTransforms = w(t) ? t : ft(t) }, isPinch: !!e.isPinch }) }, fillDragParams: function (t, e) { return nt(t, e, { isPinch: !!e.isPinch }) }, dragStart: function (t, e) { this.setTransform(t, e), this.resetStyle(e), rt(t, "onBeforeRenderStart", this.fillDragStartParams(t, e)) }, drag: function (t, e) { this.resetStyle(e), rt(t, "onBeforeRender", nt(t, e, { isPinch: !!e.isPinch })) }, dragEnd: function (t, e) { rt(t, "onBeforeRenderEnd", nt(t, e, { isPinch: !!e.isPinch, isDrag: e.isDrag })) }, dragGroupStart: function (t, e) { var n = this, r = (this.dragStart(t, e), gi(t, "beforeRenderable", e)), i = t.moveables, r = r.map(function (t, e) { e = i[e]; return n.setTransform(e, t), n.resetStyle(t), n.fillDragStartParams(e, t) }); rt(t, "onBeforeRenderGroupStart", nt(t, e, { isPinch: !!e.isPinch, targets: t.props.targets, setTransform: function () { }, events: r })) }, dragGroup: function (t, e) { var n = this, r = (this.drag(t, e), gi(t, "beforeRenderable", e)), i = t.moveables, r = r.map(function (t, e) { e = i[e]; return n.resetStyle(t), n.fillDragParams(e, t) }); rt(t, "onBeforeRenderGroup", nt(t, e, { isPinch: !!e.isPinch, targets: t.props.targets, events: r })) }, dragGroupEnd: function (t, e) { this.dragEnd(t, e), rt(t, "onBeforeRenderGroupEnd", nt(t, e, { isPinch: !!e.isPinch, isDrag: e.isDrag, targets: t.props.targets })) }, dragControlStart: function (t, e) { return this.dragStart(t, e) }, dragControl: function (t, e) { return this.drag(t, e) }, dragControlEnd: function (t, e) { return this.dragEnd(t, e) }, dragGroupControlStart: function (t, e) { return this.dragGroupStart(t, e) }, dragGroupControl: function (t, e) { return this.dragGroup(t, e) }, dragGroupControlEnd: function (t, e) { return this.dragGroupEnd(t, e) } }, da = { name: "renderable", props: {}, events: { onRenderStart: "renderStart", onRender: "render", onRenderEnd: "renderEnd", onRenderGroupStart: "renderGroupStart", onRenderGroup: "renderGroup", onRenderGroupEnd: "renderGroupEnd" }, dragRelation: "weak", dragStart: function (t, e) { rt(t, "onRenderStart", nt(t, e, { isPinch: !!e.isPinch })) }, drag: function (t, e) { rt(t, "onRender", this.fillDragParams(t, e)) }, dragAfter: function (t, e) { if (e.resultCount) return this.drag(t, e) }, dragEnd: function (t, e) { rt(t, "onRenderEnd", this.fillDragEndParams(t, e)) }, dragGroupStart: function (t, e) { rt(t, "onRenderGroupStart", nt(t, e, { isPinch: !!e.isPinch, targets: t.props.targets })) }, dragGroup: function (t, e) { var n = this, r = gi(t, "beforeRenderable", e), i = t.moveables, r = r.map(function (t, e) { e = i[e]; return n.fillDragParams(e, t) }); rt(t, "onRenderGroup", nt(t, e, Q(Q({ isPinch: !!e.isPinch, targets: t.props.targets, transform: cr(e) }, et(lr(e))), { events: r }))) }, dragGroupEnd: function (t, e) { var n = this, r = gi(t, "beforeRenderable", e), i = t.moveables, r = r.map(function (t, e) { e = i[e]; return n.fillDragEndParams(e, t) }); rt(t, "onRenderGroupEnd", nt(t, e, Q({ isPinch: !!e.isPinch, isDrag: e.isDrag, targets: t.props.targets, events: r, transform: cr(e) }, et(lr(e))))) }, dragControlStart: function (t, e) { return this.dragStart(t, e) }, dragControl: function (t, e) { return this.drag(t, e) }, dragControlAfter: function (t, e) { return this.dragAfter(t, e) }, dragControlEnd: function (t, e) { return this.dragEnd(t, e) }, dragGroupControlStart: function (t, e) { return this.dragGroupStart(t, e) }, dragGroupControl: function (t, e) { return this.dragGroup(t, e) }, dragGroupControlEnd: function (t, e) { return this.dragGroupEnd(t, e) }, fillDragParams: function (t, e) { return nt(t, e, Q({ isPinch: !!e.isPinch, transform: cr(e) }, et(lr(e)))) }, fillDragEndParams: function (t, e) { return nt(t, e, Q({ isPinch: !!e.isPinch, isDrag: e.isDrag, transform: cr(e) }, et(lr(e)))) } }; function ha(n, t, e, r, i, o, a) { var s = "Start" === i, u = n.state.target, c = o.isRequest; if (!u || s && -1 < r.indexOf("Control") && !c && n.areaElement === o.inputEvent.target) return !1; var l, f = "".concat(e).concat(r).concat(i), p = "".concat(e).concat(r, "Condition"), d = "End" === i, u = "After" === i, h = !(!s || n.targetGesto && n.controlGesto && n.targetGesto.isFlag() && n.controlGesto.isFlag()), g = (h && n.updateRect(i, !0, !1), o.clientDistX = o.distX, o.clientDistY = o.distY, "" !== i || c || ni(n.state, o), tt([], n[t], !0)); if (c && (l = o.requestAble, g.some(function (t) { return t.name === l }) || g.push.apply(g, n.props.ables.filter(function (t) { return t.name === l }))), !g.length || g.every(function (t) { return t.dragRelation })) return !1; function v() { var t; y = !0, null != (t = o.stop) && t.call(o) } var m, g = tt(tt([pa], g, !0), [da], !1).filter(function (t) { return t[f] }), b = o.datas, h = (h && g.forEach(function (t) { t.unset && t.unset(n) }), o.inputEvent), x = (d && h && (m = document.elementFromPoint(o.clientX, o.clientY) || h.target), 0), y = !1, h = g.filter(function (t) { var e = t.name, e = b[e] || (b[e] = {}); return s && (e.isEventStart = !t[p] || t[p](n, o)), !!e.isEventStart && (t = t[f](n, Q(Q({}, o), { stop: v, resultCount: x, datas: e, originalDatas: b, inputTarget: m })), n._emitter.off(), s && !1 === t && (e.isEventStart = !1), x += t || e.isEventStart ? 1 : 0, t) }).length, E = y ? !0 : !1; return !E && s && g.length && !h && (E = g.filter(function (t) { var e = t.name; return !!b[e].isEventStart && "strong" !== t.dragRelation }).length), (d || E) && (n.state.gestos = {}, n.moveables && n.moveables.forEach(function (t) { t.state.gestos = {} }), g.forEach(function (t) { t.unset && t.unset(n) })), s && !E && !c && h && n.props.preventDefault && null != o && o.preventDefault(), !n.isUnmounted && !E && ((!s && h && !a || d) && (n.props.flushSync || mr)(function () { n.updateRect(d ? i : "", !0, !1), n.forceUpdate() }), s || d || u || !h || a || ha(n, t, e, r, i + "After", o), !0) } function ga(r) { return function (t) { var e = r.props.dragTarget, t = t.inputEvent.target, n = r.areaElement; return e && (t === e || e.contains(t)) || t === n || !r.isMoveableElement(t) && !r.controlBox.getElement().contains(t) || T(t, "moveable-area") || T(t, "moveable-padding") || T(t, "moveable-edgeDraggable") } } function va(t, e, n) { var r = t.controlBox.getElement(), i = [], o = t.props.dragTarget; return i.push(r), t.props.dragArea && !o || i.push(e), ma(t, i, "targetAbles", n, { dragStart: ga(t), pinchStart: ga(t) }) } function ma(i, t, o, a, s) { void 0 === s && (s = {}); var e = "targetAbles" === o, n = i.props, r = n.pinchOutside, u = n.pinchThreshold, c = n.preventClickEventOnDrag, l = n.preventClickDefault, f = n.checkInput, n = n.preventDefault, n = { preventDefault: void 0 === n || n, preventRightClick: !0, preventWheelClick: !0, container: window, pinchThreshold: u, pinchOutside: r, preventClickEventOnDrag: e && c, preventClickEventOnDragStart: e && l, preventClickEventByCondition: e ? null : function (t) { return i.controlBox.getElement().contains(t.target) }, checkInput: e && f }, p = new pn(t, n), d = "Control" === a; return ["drag", "pinch"].forEach(function (r) { ["Start", "", "End"].forEach(function (n) { p.on("".concat(r).concat(n), function (t) { var e = t.eventType; (!s[e] || s[e](t)) && ha(i, o, r, a, n, t) ? (i.props.stopPropagation || "Start" === n && d) && null != (e = null == t ? void 0 : t.inputEvent) && e.stopPropagation() : t.stop() }) }) }), p } var ba = function () { function t(t, e, n) { var i = this; this.target = t, this.moveable = e, this.eventName = n, this.ables = [], this._onEvent = function (e) { var n = i.eventName, r = i.moveable; r.state.disableNativeEvent || i.ables.forEach(function (t) { t[n](r, { inputEvent: e }) }) }, t.addEventListener(n.toLowerCase(), this._onEvent) } var e = t.prototype; return e.setAbles = function (t) { this.ables = t }, e.destroy = function () { this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null }, t }(); function xa(t, e, A) { for (var n, r, i, o = t, a = [], s = document.documentElement || document.body, u = !A && t === e || t === s, c = u, l = !1, f = 3, F = !1, p = Sr(e, e, !0).offsetParent, N = 1; o && !c;) { var c = u, d = getComputedStyle(o), h = d.position, g = Er(o, d), v = (g = (g = g) && "none" !== g ? ot(g) ? g : Ge(g) : [1, 0, 0, 1, 0, 0], (v = (v = void 0) === v ? 6 === g.length : v) ? [g[0], g[1], 0, g[2], g[3], 0, g[4], g[5], 1] : g), g = "fixed" === h, m = { hasTransform: !1, fixedContainer: null }, b = (g && (F = !0, p = (m = function (t) { for (var e = t.parentElement, n = !1; e;) { var r = $r(e).transform; if (r && "none" !== r) { n = !0; break } if (e === document.body) break; e = e.parentElement } return { fixedContainer: e || document.body, hasTransform: n } }(o)).fixedContainer), v.length), b = (l || 16 !== b || (l = !0, f = 4, Dr(a), i = i && be(i, 3, 4)), l && 9 === b && (v = be(v, 3, 4)), Cr(o, t, d)), x = b.tagName, y = b.hasOffset, E = b.isSVG, I = b.origin, j = b.targetOrigin, b = b.offset, S = b[0], b = b[1], C = ("svg" === x && i && (a.push({ type: "target", target: o, matrix: (x = f, k = B = T = z = C = P = R = D = G = w = _ = void 0, w = (R = _r(M = o)).width, G = R.height, D = R.clientWidth, R = R.clientHeight, P = D / w, C = R / G, z = (M = M.preserveAspectRatio.baseVal).align, M = M.meetOrSlice, T = [0, 0], B = [P, C], k = [0, 0], 1 !== z && (_ = (z - 2) % 3, z = Math.floor((z - 2) / 3), T[0] = w * _ / 2, T[1] = G * z / 2, M = 2 === M ? Math.max(C, P) : Math.min(P, C), B[0] = M, B[1] = M, k[0] = (D - w) / 2 * _, k[1] = (R - G) / 2 * z), (P = Oe(B, x))[x * (x - 1)] = k[0], P[x * (x - 1) + 1] = k[1], br(P, x, T)) }), a.push({ type: "offset", target: o, matrix: W(f) })), void 0), M = !1, D = !1, w = parseFloat(d.zoom) || 1; if (g) C = m.fixedContainer, M = !0; else { var _ = Sr(o, e, !1, !0, d), R = _.offsetZoom, C = _.offsetParent, M = _.isEnd, D = _.isStatic; if (N *= R, 1 !== R && D) S -= C.offsetLeft, b -= C.offsetTop; else if (zn || Gn) if (_.parentSlotElement) { for (var O = C, Y = 0, X = 0; O && function (t) { if (t && t.getRootNode) { t = t.getRootNode(); if (11 === t.nodeType) return t } }(O);)Y += O.offsetLeft, X += O.offsetTop, O = O.offsetParent; S -= Y, b -= X } } !On || Bn || !y || E || !D || "relative" !== h && "static" !== h || (S -= C.offsetLeft, b -= C.offsetTop, u = u || M); var P, T, G = 0, z = 0, B = 0, k = 0; if (g ? y && m.hasTransform && (B = C.clientLeft, k = C.clientTop) : (y && p !== C && (G = C.clientLeft, z = C.clientTop), y && C === s && (S += (P = Mr(o, !1, d))[0], b += P[1])), a.push({ type: "target", target: o, matrix: br(v, f, I) }), y ? (T = (x = o === t) ? 0 : o.scrollLeft, E = x ? 0 : o.scrollTop, a.push({ type: "offset", target: o, matrix: Pe([S - T + G - B, b - E + z - k], f) })) : a.push({ type: "offset", target: o, origin: I }), 1 !== w && a.push({ type: "zoom", target: o, matrix: br(Oe([w, w], f), f, [0, 0]) }), i = i || v, n = n || I, r = r || j, c || g) break; o = C, u = M, A && o !== s || (c = u) } return { zoom: N, offsetContainer: p, matrixes: a, targetMatrix: i = i || W(f), transformOrigin: n = n || [0, 0], targetOrigin: r = r || [0, 0], is3d: l, hasFixed: F } } function ya(t, e, n, r) { void 0 === n && (n = e); var e = xa(t, e), i = e.matrixes, o = e.is3d, a = e.targetMatrix, s = e.transformOrigin, u = e.targetOrigin, c = e.offsetContainer, l = e.hasFixed, e = e.zoom, f = xa(c, n, !0), p = f.matrixes, d = f.is3d, h = f.offsetContainer, f = f.zoom, r = r || d || o, g = r ? 4 : 3, t = "svg" !== t.tagName.toLowerCase() && "ownerSVGElement" in t, v = W(g), m = W(g), b = W(g), x = W(g), y = i.length, d = (p.reverse(), i.reverse(), !o && r && (a = be(a, 3, 4), Dr(i)), !d && r && Dr(p), p.forEach(function (t) { m = K(m, t.matrix, g) }), n || document.body), E = (null == (n = p[0]) ? void 0 : n.target) || Sr(d, d, !0).offsetParent, S = p.slice(1).reduce(function (t, e) { return K(t, e.matrix, g) }, W(g)), n = (i.forEach(function (t, e) { y - 2 === e && (b = v.slice()), y - 1 === e && (x = v.slice()), t.matrix || (e = function (t, e, n, r, i) { var o = t.target, t = t.origin, a = e.matrix, s = (e = Fr(o)).offsetWidth, u = e.offsetHeight, e = n.getBoundingClientRect(), c = [0, 0]; n === document.body && (c = Mr(o, !0)); for (var l = (o = o.getBoundingClientRect()).left - e.left + n.scrollLeft - (n.clientLeft || 0) + c[0], f = o.top - e.top + n.scrollTop - (n.clientTop || 0) + c[1], e = o.width, n = o.height, c = xe(r, i, a), p = (o = Pr(c, s, u, r)).left, d = o.top, h = o.width, o = o.height, g = F(c, t, r), c = z(g, [p, d]), v = [l + c[0] * e / h, f + c[1] * n / o], m = [0, 0], b = 0; ++b < 10;) { var x = ge(i, r), x = z(F(x, v, r), F(x, g, r)); m[0] = x[0], m[1] = x[1]; var x = Pr(xe(r, i, Pe(m, r), a), s, u, r), y = x.left - l, x = x.top - f; if (Math.abs(y) < 2 && Math.abs(x) < 2) break; v[0] -= y, v[1] -= x } return m.map(function (t) { return Math.round(t) }) }(t, i[e + 1], E, g, K(S, v, g)), t.matrix = Pe(e, g)), v = K(v, t.matrix, g) }), !t && o), a = a || W(n ? 4 : 3), d = wr(t && 16 === a.length ? be(a, 4, 3) : a, n), p = m; return { hasZoom: 1 !== e || 1 !== f, hasFixed: l, rootMatrix: m = he(m, g, g), originalRootMatrix: p, beforeMatrix: b, offsetMatrix: x, allMatrix: v, targetMatrix: a, targetTransform: d, transformOrigin: s, targetOrigin: u, is3d: r, offsetContainer: c, offsetRootContainer: h } } function Ea(t, e, n, r) { void 0 === n && (n = e); var i = 0, o = 0, a = 0, s = {}, u = Fr(t), e = (t && (i = u.offsetWidth, o = u.offsetHeight), t && (e = Tr((t = ya(t, e, n, r)).allMatrix, t.transformOrigin, i, o), s = Q(Q({}, t), e), a = Nr([(n = Tr(t.allMatrix, [50, 50], 100, 100)).pos1, n.pos2], n.direction)), r ? 4 : 3); return Q(Q(Q({ hasZoom: !1, width: i, height: o, rotation: a }, u), { originalRootMatrix: W(e), rootMatrix: W(e), beforeMatrix: W(e), offsetMatrix: W(e), allMatrix: W(e), targetMatrix: W(e), targetTransform: "", transformOrigin: [0, 0], targetOrigin: [0, 0], is3d: !!r, left: 0, top: 0, right: 0, bottom: 0, origin: [0, 0], pos1: [0, 0], pos2: [0, 0], pos3: [0, 0], pos4: [0, 0], direction: 1, hasFixed: !1, offsetContainer: null, offsetRootContainer: null }), s) } function Sa(t, e, n, r, i, o) { void 0 === o && (o = []); var a, s = 1, u = [0, 0], c = Ir(), l = Ir(), f = Ir(), p = Ir(), d = [0, 0], h = {}, n = Ea(e, n, i, !0); return e && (a = getComputedStyle(e), o.forEach(function (t) { h[t] = a[t] }), i = n.is3d ? 4 : 3, s = (o = Tr(n.offsetMatrix, J(n.transformOrigin, ve(n.targetMatrix, i)), n.width, n.height)).direction, u = J(o.origin, [o.left - n.left, o.top - n.top]), p = Xr(n.offsetRootContainer), i = Sr(r, r, !0).offsetParent || n.offsetRootContainer, n.hasZoom ? (o = Tr(K(n.originalRootMatrix, n.allMatrix), n.transformOrigin, n.width, n.height), r = Tr(n.originalRootMatrix, yr(getComputedStyle(i)).map(function (t) { return parseFloat(t) }), i.offsetWidth, i.offsetHeight), c = Yr(o, p), f = Yr(r, p, i, !0), t && (l = Yr({ left: o.left, top: r = o.top, bottom: r, right: r }, p))) : (c = Xr(e), f = Xr(i, !0), t && (l = Xr(t)), o = f.left, r = f.top, i = f.clientLeft, t = f.clientTop, o = [c.left - o, c.top - r], d = z(ei(n.rootMatrix, o, 4), [i + n.left, t + n.top]))), Q({ targetClientRect: c, containerClientRect: f, moveableClientRect: l, rootContainerClientRect: p, beforeDirection: s, beforeOrigin: u, originalBeforeOrigin: u, target: e, style: h, offsetDelta: d }, n) } function Ca(t) { var e = t.pos1, n = t.pos2, r = t.pos3, i = t.pos4; if (!(e && n && r && i)) return null; var o = Ye([e, n, r, i]), o = [o.minX, o.minY], a = z(t.origin, o), e = z(e, o), n = z(n, o), r = z(r, o), i = z(i, o); return Q(Q({}, t), { left: t.left, top: t.top, posDelta: o, pos1: e, pos2: n, pos3: r, pos4: i, origin: a, beforeOrigin: a, isPersisted: !0 }) } var Ma = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.state = Q({ container: null, gestos: {}, renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]], disableNativeEvent: !1, posDelta: [0, 0] }, Sa(null)), e.renderState = {}, e.enabledAbles = [], e.targetAbles = [], e.controlAbles = [], e.rotation = 0, e.scale = [1, 1], e.isMoveableMounted = !1, e.isUnmounted = !1, e.events = { mouseEnter: null, mouseLeave: null }, e._emitter = new $e, e._prevTarget = null, e._prevDragArea = !1, e._isPropTargetChanged = !1, e._hasFirstTarget = !1, e._observer = null, e._observerId = 0, e._rootContainer = null, e._viewContainer = null, e._viewClassNames = [], e.checkUpdateRect = function () { var t; e.isDragging() || ((t = e.props.parentMoveable) ? t.checkUpdateRect() : (yt(e._observerId), e._observerId = xt(function () { e.isDragging() || e.updateRect() }))) }, e._onPreventClick = function (t) { t.stopPropagation(), t.preventDefault() }, e } Sn(e, t); var n = e.prototype; return n.render = function () { var t = this.props, e = this.getState(), n = t.parentPosition, r = t.className, i = t.target, o = t.zoom, a = t.cspNonce, s = t.translateZ, u = t.cssStyled, c = t.portalContainer, l = t.groupable, f = t.linePadding, p = t.controlPadding, n = (this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses(), n || [0, 0]), d = n[0], n = n[1], h = e.left, g = e.top, v = e.target, m = e.direction, b = e.hasFixed, e = e.offsetDelta, x = t.targets, y = this.isDragging(), E = {}, S = (this.getEnabledAbles().forEach(function (t) { E["data-able-".concat(t.name.toLowerCase())] = !0 }), this._getAbleClassName()), x = x && x.length && (v || l) || i || !this._hasFirstTarget && this.state.isPersisted, v = this.controlBox || this.props.firstRenderState || this.props.persistData, i = [h - d, g - n], h = (!l && t.useAccuratePosition && (i[0] += e[0], i[1] += e[1]), { position: b ? "fixed" : "absolute", display: x ? "block" : "none", visibility: v ? "visible" : "hidden", transform: "translate3d(".concat(i[0], "px, ").concat(i[1], "px, ").concat(s, ")"), "--zoom": o, "--zoompx": "".concat(o, "px") }); return f && (h["--moveable-line-padding"] = f), p && (h["--moveable-control-padding"] = p), C(u, Q({ cspNonce: a, ref: M(this, "controlBox"), className: "".concat(B("control-box", -1 === m ? "reverse" : "", y ? "dragging" : ""), " ").concat(S, " ").concat(r) }, E, { onClick: this._onPreventClick, portalContainer: c, style: h }), this.renderAbles(), this._renderLines()) }, n.componentDidMount = function () { this.isMoveableMounted = !0, this.isUnmounted = !1, this.controlBox.getElement(); var t = this.props, e = t.parentMoveable, n = t.container, t = t.wrapperMoveable; this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), n || e || t || this.state.isPersisted || (this.updateRect("", !1, !1), this.forceUpdate()) }, n.componentDidUpdate = function (t) { this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(t) }, n.componentWillUnmount = function () { this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(); this._viewContainer && this._changeAbleViewClassNames([]), Hr(this, "targetGesto"), Hr(this, "controlGesto"); var t, e = this.events; for (t in e) { var n = e[t]; n && n.destroy() } }, n.getTargets = function () { var t = this.props.target; return t ? [t] : [] }, n.getAble = function (e) { return bt(this.props.ables || [], function (t) { return t.name === e }) }, n.getContainer = function () { var t = this.props, e = t.parentMoveable, n = t.wrapperMoveable; return t.container || n && n.getContainer() || e && e.getContainer() || this.controlBox.getElement().parentElement }, n.isMoveableElement = function (t) { var e; return t && -1 < ((null == (e = t.getAttribute) ? void 0 : e.call(t, "class")) || "").indexOf(kn) }, n.dragStart = function (t) { var e = this.targetGesto, n = this.controlGesto; return e && ga(this)({ inputEvent: t }) ? e.isFlag() || e.triggerDragStart(t) : n && this.isMoveableElement(t.target) && (n.isFlag() || n.triggerDragStart(t)), this }, n.hitTest = function (t) { var e = this.state, n = e.target, r = e.pos1, i = e.pos2, o = e.pos3, a = e.pos4, e = e.targetClientRect; if (!n) return 0; var t = (n = t instanceof Element ? { left: (n = t.getBoundingClientRect()).left, top: n.top, width: n.width, height: n.height } : Q({ width: 0, height: 0 }, t)).left, s = n.top, u = n.width, n = n.height, r = je([r, i, a, o], e), i = Ie(Ve(r, [[t, s], [t + u, s], [t + u, s + n], [t, s + n]])), a = Ie(r); return i && a ? Math.min(100, i / a * 100) : 0 }, n.isInside = function (t, e) { var n = this.state, r = n.target, i = n.pos1, o = n.pos2, a = n.pos3, s = n.pos4, n = n.targetClientRect; return !!r && Xe([t, e], je([i, o, s, a], n)) }, n.updateRect = function (t, e, n) { void 0 === n && (n = !0); var r = this.props, i = r.parentMoveable, o = this.state.target || this.props.target, a = this.getContainer(), s = (i || this)._rootContainer, u = Sa(this.controlBox && this.controlBox.getElement(), o, a, a, s || a, this._getRequestStyles()); if (!o && this._hasFirstTarget && r.persistData) { var c, l = Ca(r.persistData); for (c in l) u[c] = l[c] } this.updateState(u, !i && n) }, n.isDragging = function (t) { var e = this.targetGesto, n = this.controlGesto; return null != e && e.isFlag() ? !t || !(null == (e = e.getEventData()[t]) || !e.isEventStart) : !(null == n || !n.isFlag()) && (!t || !(null == (e = n.getEventData()[t]) || !e.isEventStart)) }, n.updateTarget = function (t) { this.updateRect(t, !0) }, n.getRect = function () { var t = this.state, e = Y(this.state), n = e[0], r = e[1], i = e[2], o = e[3], e = Or(e), a = t.width, s = t.height, u = e.width, c = e.height, l = e.left, e = e.top, f = [t.left, t.top], p = J(f, t.origin); return { width: u, height: c, left: l, top: e, pos1: n, pos2: r, pos3: i, pos4: o, offsetWidth: a, offsetHeight: s, beforeOrigin: J(f, t.beforeOrigin), origin: p, transformOrigin: t.transformOrigin, rotation: this.getRotation() } }, n.getManager = function () { return this }, n.stopDrag = function (t) { var e; t && "target" !== t || null != (e = this.targetGesto) && e.stop(), t && "control" !== t || null != (e = this.controlGesto) && e.stop() }, n.getRotation = function () { var t = this.state, e = t.pos1, n = t.pos2, t = t.direction; return t = t, e = N(e = e, n) / Math.PI * 180, e = 0 <= (e = 0 <= t ? e : 180 - e) ? e : 360 + e }, n.request = function (e, t, n) { void 0 === t && (t = {}); var r = this.props, i = r.ables, r = r.groupable, i = i.filter(function (t) { return t.name === e })[0]; if (this.isDragging() || !i || !i.request) return { request: function () { return this }, requestEnd: function () { return this } }; var o = this, a = i.request(this), s = n || t.isInstant, u = a.isControl ? "controlAbles" : "targetAbles", c = "".concat(r ? "Group" : "").concat(a.isControl ? "Control" : ""), i = { request: function (t) { return ha(o, u, "drag", c, "", Q(Q({}, a.request(t)), { requestAble: e, isRequest: !0 }), s), this }, requestEnd: function () { return ha(o, u, "drag", c, "End", Q(Q({}, a.requestEnd()), { requestAble: e, isRequest: !0 }), s), this } }; return ha(o, u, "drag", c, "Start", Q(Q({}, a.requestStart(t)), { requestAble: e, isRequest: !0 }), s), s ? i.request(t).requestEnd() : i }, n.destroy = function () { this.componentWillUnmount() }, n.updateRenderPoses = function () { var t = this.getState(), e = this.props, n = t.originalBeforeOrigin, r = t.transformOrigin, i = t.allMatrix, o = t.is3d, a = t.pos1, s = t.pos2, u = t.pos3, c = t.pos4, l = t.left, f = t.top, p = t.isPersisted, d = e.padding || {}, h = d.left, h = void 0 === h ? 0 : h, g = d.top, g = void 0 === g ? 0 : g, v = d.bottom, v = void 0 === v ? 0 : v, d = d.right, d = void 0 === d ? 0 : d, o = o ? 4 : 3, m = [], m = p ? r : this.controlBox && e.groupable ? n : J(n, [l, f]); t.renderPoses = [J(a, ri(i, [-h, -g], r, m, o)), J(s, ri(i, [d, -g], r, m, o)), J(u, ri(i, [-h, v], r, m, o)), J(c, ri(i, [d, v], r, m, o))] }, n.checkUpdate = function () { this._isPropTargetChanged = !1; var t = this.props, e = t.target, n = t.container, t = t.parentMoveable, r = this.state, i = r.target, r = r.container; (i || e) && (this.updateAbles(), !(i = !Kr(i, e)) && Kr(r, n) || ((r = n || this.controlBox) && this.unsetAbles(), this.updateState({ target: e, container: n }), !t && r && this.updateRect("End", !1, !1), this._isPropTargetChanged = i)) }, n.waitToChangeTarget = function () { return new Promise(function () { }) }, n.triggerEvent = function (t, e) { this._emitter.trigger(t, e); t = this.props[t]; return t && t(e) }, n.useCSS = function (t, e) { var n = this.props.customStyledMap, r = t + e; return n[r] || (n[r] = yn(t, e)), n[r] }, n.getState = function () { var t = this.props, e = ((t.target || null != (e = t.targets) && e.length) && (this._hasFirstTarget = !0), this.controlBox), n = t.persistData, t = t.firstRenderState; if (t && !e) return t; if (!this._hasFirstTarget && n) { e = Ca(n); if (e) return this.updateState(e, !1), this.state } return this.state.isPersisted = !1, this.state }, n.updateSelectors = function () { }, n.unsetAbles = function () { var e = this; this.targetAbles.forEach(function (t) { t.unset && t.unset(e) }) }, n.updateAbles = function (t, e) { void 0 === t && (t = this.props.ables), void 0 === e && (e = ""); var n = this.props.triggerAblesSimultaneously, t = this.getEnabledAbles(t), r = "drag".concat(e, "Start"), i = "pinch".concat(e, "Start"), e = "drag".concat(e, "ControlStart"), r = Zr(t, [r, i], n), i = Zr(t, [e], n); this.enabledAbles = t, this.targetAbles = r, this.controlAbles = i }, n.updateState = function (t, e) { if (e) this.isUnmounted || this.setState(t); else { var n, r = this.state; for (n in t) r[n] = t[n] } }, n.getEnabledAbles = function (t) { void 0 === t && (t = this.props.ables); var e = this.props; return t.filter(function (t) { return t && (t.always && !1 !== e[t.name] || e[t.name]) }) }, n.renderAbles = function () { var r, i, o, a, e = this, t = this.props.triggerAblesSimultaneously, n = { createElement: C }; return this.renderState = {}, r = Qr(Zr(this.getEnabledAbles(), ["render"], t).map(function (t) { return (0, t.render)(e, n) || [] })).filter(function (t) { return t }), i = function (t) { return t.key }, o = [], a = {}, r.forEach(function (t, e) { var e = i(t, e, r), n = a[e]; n || (a[e] = n = [], o.push(n)), n.push(t) }), o.map(function (t) { return t[0] }) }, n.updateCheckInput = function () { this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput) }, n._getRequestStyles = function () { return this.getEnabledAbles().reduce(function (t, e) { var n, e = null != (n = null == (n = e.requestStyle) ? void 0 : n.call(e)) ? n : []; return tt(tt([], t, !0), e, !0) }, tt([], this.props.requestStyles || [], !0)) }, n._updateObserver = function (t) { var e = this.props, n = e.target; window.ResizeObserver && n && e.useResizeObserver ? t.target === n && this._observer || ((e = new ResizeObserver(this.checkUpdateRect)).observe(n, { box: "border-box" }), this._observer = e) : null != (t = this._observer) && t.disconnect() }, n._updateEvents = function () { var t = this.controlBox.getElement(), e = this.targetAbles.length, n = this.controlAbles.length, r = this.props, r = r.dragTarget || r.target; (!e && this.targetGesto || this._isTargetChanged(!0)) && (Hr(this, "targetGesto"), this.updateState({ gesto: null })), n || Hr(this, "controlGesto"), r && e && !this.targetGesto && (this.targetGesto = va(this, r, "")), !this.controlGesto && n && (this.controlGesto = ma(this, t, "controlAbles", "Control")) }, n._updateTargets = function () { var t = this.props; this._prevTarget = t.dragTarget || t.target, this._prevDragArea = t.dragArea }, n._renderLines = function () { var t = this.props, r = t.zoom, e = t.hideDefaultLines, n = t.hideChildMoveableDefaultLines, t = t.parentMoveable; if (e || t && n) return []; var i = this.getState().renderPoses, o = { createElement: C }; return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function (t, e) { var n = t[0], t = t[1]; return yo(o, "", i[n], i[t], r, "render-line-".concat(e)) }) }, n._isTargetChanged = function (t) { var e = this.props, n = e.dragTarget || e.target, r = this._prevTarget, i = this._prevDragArea, e = e.dragArea; return !e && r !== n || (t || e) && i !== e }, n._updateNativeEvents = function () { var i, o = this, a = this.props.dragArea ? this.areaElement : this.state.target, s = this.events, t = Et(s); if (this._isTargetChanged()) for (var e in s) { var n = s[e]; n && n.destroy(), s[e] = null } a && (i = this.enabledAbles, t.forEach(function (t) { var e = Zr(i, [t]), n = 0 < e.length, r = s[t]; n ? (r || (r = new ba(a, o, t), s[t] = r), r.setAbles(e)) : r && (r.destroy(), s[t] = null) })) }, n._checkUpdateRootContainer = function () { var t = this.props.rootContainer; !this._rootContainer && t && (this._rootContainer = ci(t, !0)) }, n._checkUpdateViewContainer = function () { var t = this.props.viewContainer; !this._viewContainer && t && (this._viewContainer = ci(t, !0)), this._viewContainer && this._changeAbleViewClassNames(tt(tt([], this._getAbleViewClassNames(), !0), [this.isDragging() ? Ao : ""], !1)) }, n._changeAbleViewClassNames = function (t) { var e = this._viewContainer, n = Jr(t.filter(Boolean), function (t) { return t }).map(function (t) { return t[0] }), r = this._viewClassNames, t = O(r, n), i = t.removed, t = t.added; i.forEach(function (t) { Ot(e, r[t]) }), t.forEach(function (t) { Rt(e, n[t]) }), this._viewClassNames = n }, n._getAbleViewClassNames = function () { var n = this; return (this.getEnabledAbles().map(function (t) { var e; return (null == (e = t.viewClassName) ? void 0 : e.call(t, n)) || "" }).join(" ") + " ".concat(this._getAbleClassName("-view"))).split(/\s+/g) }, n._getAbleClassName = function (r) { var i = this, t = (void 0 === r && (r = ""), this.getEnabledAbles()), e = this.targetGesto, n = this.controlGesto, o = null != e && e.isFlag() ? e.getEventData() : {}, a = null != n && n.isFlag() ? n.getEventData() : {}; return t.map(function (t) { var e = t.name, n = (null == (n = t.className) ? void 0 : n.call(t, i)) || ""; return (null != (t = o[e]) && t.isEventStart || null != (t = a[e]) && t.isEventStart) && (n += " ".concat(B("".concat(e).concat(r, "-dragging")))), n.trim() }).filter(Boolean).join(" ") }, e.defaultProps = { target: null, dragTarget: null, container: null, rootContainer: null, origin: !0, parentMoveable: null, wrapperMoveable: null, isWrapperMounted: !1, parentPosition: null, portalContainer: null, useResizeObserver: !1, preventDefault: !0, linePadding: 0, controlPadding: 0, ables: [], pinchThreshold: 20, dragArea: !1, passDragArea: !1, transformOrigin: "", className: "", zoom: 1, triggerAblesSimultaneously: !1, padding: {}, pinchOutside: !0, checkInput: !1, groupable: !1, hideDefaultLines: !1, cspNonce: "", translateZ: 0, cssStyled: null, customStyledMap: {}, props: {}, stopPropagation: !1, preventClickDefault: !1, preventClickEventOnDrag: !0, flushSync: mr, firstRenderState: null, persistData: null, viewContainer: null, requestStyles: [], useAccuratePosition: !1 }, e }(Zt), Da = { name: "groupable", props: { defaultGroupRotate: Number, defaultGroupOrigin: String, groupable: Boolean, groupableProps: Object, targetGroups: Object, hideChildMoveableDefaultLines: Boolean }, events: {}, render: function (n, o) { var r = n.props, t = r.targets || [], e = (n.moveables = [], n.getState()), i = e.left, a = e.top, e = e.isPersisted, s = [i, a], u = r.zoom || 1, i = n.renderGroupRects, c = (null == (a = r.persistData) ? void 0 : a.children) || [], l = (e ? t = c.map(function () { return null }) : c = [], n.getRequestChildStyles()); return tt(tt([], t.map(function (t, e) { return o.createElement(Ma, { key: "moveable" + e, ref: f(n, "moveables", e), target: t, origin: !1, requestStyles: l, cssStyled: r.cssStyled, customStyledMap: r.customStyledMap, useResizeObserver: r.useResizeObserver, hideChildMoveableDefaultLines: r.hideChildMoveableDefaultLines, parentMoveable: n, parentPosition: s, persistData: c[e], zoom: u }) }), !0), Qr(i.map(function (t, r) { var i = [t.pos1, t.pos2, t.pos3, t.pos4]; return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function (t, e) { var n = t[0], t = t[1]; return yo(o, "", z(i[n], s), z(i[t], s), u, "group-rect-".concat(r, "-").concat(e)) }) })), !0) } }, wa = Cn("clickable", { props: { clickable: Boolean }, events: { onClick: "click", onClickGroup: "clickGroup" }, always: !0, dragRelation: "weak", dragStart: function () { }, dragControlStart: function () { }, dragGroupStart: function (t, e) { e.datas.inputTarget = e.inputEvent && e.inputEvent.target }, dragEnd: function (t, e) { var n = t.props.target, r = e.inputEvent, i = e.inputTarget, o = !t.isMoveableElement(i) && t.controlBox.getElement().contains(i); !r || !i || e.isDrag || t.isMoveableElement(i) || o || (r = n.contains(i), rt(t, "onClick", nt(t, e, { isDouble: e.isDouble, inputTarget: i, isTarget: n === i, moveableTarget: t.props.target, containsTarget: r }))) }, dragGroupEnd: function (t, e) { var n, r, i, o = e.inputEvent, a = e.inputTarget; o && a && !e.isDrag && !t.isMoveableElement(a) && e.datas.inputTarget !== a && (r = -1 < (n = (o = t.props.targets).indexOf(a)), i = !1, -1 === n && (i = -1 < (n = mt(o, function (t) { return t.contains(a) }))), rt(t, "onClickGroup", nt(t, e, { isDouble: e.isDouble, targets: o, inputTarget: a, targetIndex: n, isTarget: r, containsTarget: i, moveableTarget: o[n] }))) }, dragControlEnd: function (t, e) { this.dragEnd(t, e) }, dragGroupControlEnd: function (t, e) { this.dragEnd(t, e) } }); function _a(t) { var e = t.originalDatas.draggable; return e || (t.originalDatas.draggable = {}, e = t.originalDatas.draggable), Q(Q({}, t), { datas: e }) } var Ra = Cn("edgeDraggable", { css: [".edge.edgeDraggable.line {\n    cursor: move;\n}"], render: function (t, e) { var n = t.props, r = n.edgeDraggable; return r ? Eo(e, "edgeDraggable", r, t.getState().renderPoses, n.zoom) : [] }, dragCondition: function (t, e) { t = t.props, e = null == (e = e.inputEvent) ? void 0 : e.target; return !(!t.edgeDraggable || !e) && (!t.draggable && T(e, B("direction")) && T(e, B("edge")) && T(e, B("edgeDraggable"))) }, dragStart: function (t, e) { return X.dragStart(t, _a(e)) }, drag: function (t, e) { return X.drag(t, _a(e)) }, dragEnd: function (t, e) { return X.dragEnd(t, _a(e)) }, dragGroupCondition: function (t, e) { t = t.props, e = null == (e = e.inputEvent) ? void 0 : e.target; return !(!t.edgeDraggable || !e) && (!t.draggable && T(e, B("direction")) && T(e, B("line"))) }, dragGroupStart: function (t, e) { return X.dragGroupStart(t, _a(e)) }, dragGroup: function (t, e) { return X.dragGroup(t, _a(e)) }, dragGroupEnd: function (t, e) { return X.dragGroupEnd(t, _a(e)) }, unset: function (t) { return X.unset(t) } }), Oa = { name: "individualGroupable", props: { individualGroupable: Boolean, individualGroupableProps: Function }, events: {} }, Pa = [pa, Yo, g, le, X, Ra, Do, t, a, fe, e, Xo, Tn, sa, aa, fa, Da, Oa, wa, Io, da], g = Pa.reduce(function (t, e) { return Q(Q({}, t), "events" in e ? e.events : {}) }, {}), le = Pa.reduce(function (t, e) { return Q(Q({}, t), e.props) }, {}), Ra = Object.keys(ui(g)), t = Object.keys(le); function Ta(t, e) { var n = t[0], r = t[1], t = t[2]; return (n * e[0] + r * e[1] + t) / Math.sqrt(n * n + r * r) } function Ga(t, e) { var n = t[0], t = t[1]; return -n * e[0] - t * e[1] } function za(t, i) { return Math.max.apply(Math, t.map(function (t) { var e = t[0], n = t[1], r = t[2], t = t[3]; return Math.max(e[i], n[i], r[i], t[i]) })) } function Ba(t, i) { return Math.min.apply(Math, t.map(function (t) { var e = t[0], n = t[1], r = t[2], t = t[3]; return Math.min(e[i], n[i], r[i], t[i]) })) } var ka = function (r) { function t() { var t = null !== r && r.apply(this, arguments) || this; return t.differ = new Ne, t.moveables = [], t.transformOrigin = "50% 50%", t.renderGroupRects = [], t._targetGroups = [], t._hasFirstTargets = !1, t } Sn(t, r); var e = t.prototype; return e.componentDidMount = function () { r.prototype.componentDidMount.call(this) }, e.checkUpdate = function () { this._isPropTargetChanged = !1, this.updateAbles() }, e.getTargets = function () { return this.props.targets }, e.updateRect = function (e, t, n) { void 0 === n && (n = !0); var r, C, M, D, i, o, a, s, u, c, l, f, p, d, h, g, v, m = this.state; this.controlBox && !m.isPersisted && (this.moveables.forEach(function (t) { t.updateRect(e, !1, !1) }), v = this.props, o = this.moveables, r = m.target || v.target, (l = function r(i, t) { t = t.map(function (e) { var t, n; return w(e) ? 1 < (n = (t = r(i, e)).length) ? t : 1 === n ? t[0] : null : (n = bt(i, function (t) { return t.manager.props.target === e })) ? (n.finded = !0, n.manager) : null }).filter(Boolean); return 1 === t.length && w(t[0]) ? t[0] : t }(o = o.map(function (t) { return { finded: !1, manager: t } }), p = this.props.targetGroups || [])).push.apply(l, o.filter(function (t) { return !t.finded }).map(function (t) { return t.manager })), C = [], M = !t || "" !== e && v.updateGroup, D = v.defaultGroupRotate || 0, this._hasFirstTargets || null != (t = null == (o = this.props.persistData) ? void 0 : o.rotation) && (D = t), o = function r(t, i, e) { var t = t.map(function (t) { var e, n; return w(t) ? (n = [(e = r(t, i)).pos1, e.pos2, e.pos3, e.pos4], C.push(e), { poses: n, rotation: e.rotation }) : { poses: Y(t.state), rotation: t.getRotation() } }), n = t.map(function (t) { return t.rotation }), o = 0, a = n[0], n = n.every(function (t) { return Math.abs(a - t) < .1 }), o = M ? n ? a : D : !e && n ? a : i, e = t.map(function (t) { return t.poses }), n = o, t = [0, 0], o = [0, 0], s = [0, 0], u = [0, 0], c = 0, l = 0; if (!e.length) return { pos1: t, pos2: o, pos3: s, pos4: u, minX: 0, minY: 0, maxX: 0, maxY: 0, width: c, height: l, rotation: n }; var f, p, d, h, g, v, m, b, x, y, E, S = I(n, A), e = (S % 90 ? (x = S / 180 * Math.PI, f = Math.tan(x), p = -1 / f, d = [In, jn], h = [[0, 0], [0, 0]], g = [In, jn], v = [[0, 0], [0, 0]], e.forEach(function (t) { t.forEach(function (t) { var e = Ta([-f, 1, 0], t), n = Ta([-p, 1, 0], t); d[0] > e && (h[0] = t, d[0] = e), d[1] < e && (h[1] = t, d[1] = e), g[0] > n && (v[0] = t, g[0] = n), g[1] < n && (v[1] = t, g[1] = n) }) }), x = h[0], b = h[1], m = v[0], y = v[1], x = [-f, 1, Ga([-f, 1], x)], b = [-f, 1, Ga([-f, 1], b)], t = (y = [[x, m = [-p, 1, Ga([-p, 1], m)]], [x, x = [-p, 1, Ga([-p, 1], y)]], [b, m], [b, x]].map(function (t) { return qe(t[0], t[1])[0] }))[0], o = y[1], s = y[2], u = y[3], c = g[1] - g[0], l = d[1] - d[0]) : (t = [m = Ba(e, 0), b = Ba(e, 1)], o = [x = za(e, 0), b], s = [m, y = za(e, 1)], u = [x, y], c = x - m, l = y - b, S % 180 && (t = (E = [s, t, u, o])[0], o = E[1], s = E[2], u = E[3], c = y - b, l = x - m)), 180 < S % 360 && (t = (E = [u, s, o, t])[0], o = E[1], s = E[2], u = E[3]), Ye([t, o, s, u])); return { pos1: t, pos2: o, pos3: s, pos4: u, width: c, height: l, minX: e.minX, minY: e.minY, maxX: e.maxX, maxY: e.maxY, rotation: n } }(l, this.rotation, !0), M && (this.rotation = o.rotation, this.transformOrigin = v.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this._targetGroups = p, this.renderGroupRects = C, t = this.transformOrigin, l = this.rotation, v = this.scale, p = o.width, d = o.height, i = o.minX, o = o.minY, c = [[0, 0], [p, 0], [0, d], [p, d]], a = hi(t, p, d), s = this.rotation / 180 * Math.PI, u = (c = c.map(function (t) { return z(t, a) })).map(function (t) { return De(t, s) }), u = (c = Ye({ prev: c, next: u, result: u.map(function (t) { return J(t, a) }) }.result)).minX, c = c.minY, l = " rotate(".concat(l, "deg)") + " scale(".concat(0 <= v[0] ? 1 : -1, ", ").concat(0 <= v[1] ? 1 : -1, ")"), f = "translate(".concat(-u, "px, ").concat(-c, "px)").concat(l), this.controlBox.getElement().style.transform = "translate3d(".concat(i, "px, ").concat(o, "px, ").concat(this.props.translateZ || 0, ")"), r.style.cssText += "left:0px;top:0px;" + "transform-origin:".concat(t, ";") + "width:".concat(p, "px;height:").concat(d, "px;") + "transform: ".concat(f), m.width = p, m.height = d, t = this.getContainer(), p = [(f = Sa(this.controlBox.getElement(), r, this.controlBox.getElement(), this.getContainer(), this._rootContainer || t, [])).left, f.top], g = [(g = Ye([d = (m = Y(f))[0], t = m[1], h = m[2], m = m[3]])).minX, g.minY], v = 0 < v[0] * v[1] ? 1 : -1, f.pos1 = z(d, g), f.pos2 = z(t, g), f.pos3 = z(h, g), f.pos4 = z(m, g), f.left = i - f.left + g[0], f.top = o - f.top + g[1], f.origin = z(J(p, f.origin), g), f.beforeOrigin = z(J(p, f.beforeOrigin), g), f.originalBeforeOrigin = J(p, f.originalBeforeOrigin), f.transformOrigin = z(J(p, f.transformOrigin), g), r.style.transform = "translate(".concat(-u - g[0], "px, ").concat(-c - g[1], "px)") + l, this.updateState(Q(Q({}, f), { posDelta: g, direction: v, beforeDirection: v }), n)) }, e.getRect = function () { return Q(Q({}, r.prototype.getRect.call(this)), { children: this.moveables.map(function (t) { return t.getRect() }) }) }, e.triggerEvent = function (t, e, n) { if (n || -1 < t.indexOf("Group")) return r.prototype.triggerEvent.call(this, t, e); this._emitter.trigger(t, e) }, e.getRequestChildStyles = function () { return this.getEnabledAbles().reduce(function (t, e) { var n, e = null != (n = null == (n = e.requestChildStyle) ? void 0 : n.call(e)) ? n : []; return tt(tt([], t, !0), e, !0) }, []) }, e.updateAbles = function () { r.prototype.updateAbles.call(this, tt(tt([], this.props.ables, !0), [Da], !1), "Group") }, e._updateTargets = function () { r.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement }, e._updateEvents = function () { var t = this.state, e = this.props, n = this._prevTarget, r = e.dragTarget || this.areaElement, n = (n !== r && (Hr(this, "targetGesto"), Hr(this, "controlGesto"), t.target = null), t.target || (t.target = this.areaElement, this.controlBox.getElement().style.display = "block"), t.target && (this.targetGesto || (this.targetGesto = va(this, r, "Group")), this.controlGesto || (this.controlGesto = ma(this, this.controlBox.getElement(), "controlAbles", "GroupControl"))), !Kr(t.container, e.container)), r = (n && (t.container = e.container), e.targets), t = this.differ.update(r), i = t.added, o = t.changed, t = t.removed, i = i.length || t.length; (n || i || this.transformOrigin !== (e.defaultGroupOrigin || "50% 50%") || o.length || r.length && !function i(t, o) { return t.length === o.length && t.every(function (t, e) { var e = o[e], n = w(t), r = w(e); return n && r ? i(t, e) : !n && !r && t === e }) }(this._targetGroups, e.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!i }, e._updateObserver = function () { }, t.defaultProps = Q(Q({}, Ma.defaultProps), { transformOrigin: ["50%", "50%"], groupable: !0, dragArea: !0, keepRatio: !0, targets: [], defaultGroupRotate: 0, defaultGroupOrigin: "50% 50%" }), t }(Ma), Aa = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.moveables = [], t } Sn(t, e); var n = t.prototype; return n.render = function () { var r = this, i = this.props, t = i.cspNonce, e = i.cssStyled, n = i.persistData, o = i.targets || [], a = o.length, s = this.isUnmounted || !a, u = null != (n = null == n ? void 0 : n.children) ? n : []; return s && !a && u.length ? o = u.map(function () { return null }) : s || (u = []), C(e, { cspNonce: t, ref: M(this, "controlBox"), className: B("control-box") }, o.map(function (t, e) { var n = null != (n = null == (n = i.individualGroupableProps) ? void 0 : n.call(i, t, e)) ? n : {}; return C(Ma, Q({ key: "moveable" + e, ref: f(r, "moveables", e) }, i, n, { target: t, wrapperMoveable: r, isWrapperMounted: r.isMoveableMounted, persistData: u[e] })) })) }, n.componentDidUpdate = function () { }, n.getTargets = function () { return this.props.targets }, n.updateRect = function (e, n, r) { void 0 === r && (r = !0), this.moveables.forEach(function (t) { t.updateRect(e, n, r) }) }, n.getRect = function () { return Q(Q({}, e.prototype.getRect.call(this)), { children: this.moveables.map(function (t) { return t.getRect() }) }) }, n.request = function () { return { request: function () { return this }, requestEnd: function () { return this } } }, n.dragStart = function () { return this }, n.hitTest = function () { return 0 }, n.isInside = function () { return !1 }, n.isDragging = function () { return !1 }, n.updateRenderPoses = function () { }, n.checkUpdate = function () { }, n.triggerEvent = function () { }, n.updateAbles = function () { }, n._updateEvents = function () { }, n._updateObserver = function () { }, t }(Ma); var Fa = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return Sn(e, t), e.defaultAbles = Pa, e }(function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.refTargets = [], t.selectorMap = {}, t._differ = new Ne, t._elementTargets = [], t._onChangeTargets = null, t } Sn(t, e); var n, o, r = t.prototype; return t.makeStyled = function () { var n, e = {}, t = (this.getTotalAbles().forEach(function (t) { t = t.css; t && t.forEach(function (t) { e[t] = !0 }) }), Et(e).join("\n")); this.defaultStyled = yn("div", (n = kn, (An + t).replace(/([^}{]*){/gm, function (t, e) { return e.replace(/\.([^{,\s\d.]+)/g, "." + n + "$1") + "{" }))) }, t.getTotalAbles = function () { return tt([Yo, Da, Oa, Io], this.defaultAbles, !0) }, r.render = function () { var e, t = this.constructor, n = (t.defaultStyled || t.makeStyled(), this.props), r = n.ables, i = n.props, n = function (t, e) { var n = {}; for (i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }(n, ["ables", "props"]), o = this._updateRefs(!0), a = function e(t, n) { var r = []; return t.forEach(function (t) { t && (x(t) ? n[t] && r.push.apply(r, n[t]) : w(t) ? r.push.apply(r, e(t, n)) : r.push(t)) }), r }(o, this.selectorMap), s = 1 < a.length, r = tt(tt([], t.getTotalAbles(), !0), r || [], !0), i = Q(Q(Q({}, n), i || {}), { ables: r, cssStyled: t.defaultStyled, customStyledMap: t.customStyledMap }), r = (this._elementTargets = a, null), t = this.moveable, u = n.persistData; if (s = null != u && u.children ? !0 : s) { if (n.individualGroupable) return C(Aa, Q({ key: "individual-group", ref: M(this, "moveable") }, i, { target: null, targets: a })); u = function e(t, n) { var r = []; return t.forEach(function (t) { t && (x(t) ? n[t] && r.push.apply(r, n[t]) : w(t) ? r.push(e(t, n)) : r.push(t)) }), r }(o, this.selectorMap); return !t || t.props.groupable || t.props.individualGroupable || (s = t.props.target) && -1 < a.indexOf(s) && (r = Q({}, t.state)), C(ka, Q({ key: "group", ref: M(this, "moveable") }, i, null != (o = n.groupableProps) ? o : {}, { target: null, targets: a, targetGroups: u, firstRenderState: r })) } return e = a[0], t && (t.props.groupable || t.props.individualGroupable) && (s = bt(t.moveables || [], function (t) { return t.props.target === e })) && (r = Q({}, s.state)), C(Ma, Q({ key: "single", ref: M(this, "moveable") }, i, { target: e, firstRenderState: r })) }, r.componentDidMount = function () { this._checkChangeTargets(), this._updateRefs() }, r.componentDidUpdate = function () { this._checkChangeTargets() }, r.componentWillUnmount = function () { this.selectorMap = {}, this.refTargets = [] }, r.getTargets = function () { var t; return null != (t = null == (t = this.moveable) ? void 0 : t.getTargets()) ? t : [] }, r.updateSelectors = function () { this.selectorMap = {}, this._updateRefs() }, r.waitToChangeTarget = function () { var e, t = this; return this._onChangeTargets = function () { t._onChangeTargets = null, e() }, new Promise(function (t) { e = t }) }, r.waitToChangeTargets = function () { return this.waitToChangeTarget() }, r.getManager = function () { return this.moveable }, r._updateRefs = function (t) { var e = this.refTargets, n = li(this.props.target || this.props.targets), r = "undefined" != typeof document, i = function n(t, r) { return t.length !== r.length || t.some(function (t, e) { return e = r[e], !(!t && !e) && t != e && (!w(t) || !w(e) || n(t, e)) }) }(e, n), o = this.selectorMap, a = {}; return this.refTargets.forEach(function t(e) { x(e) ? o[e] ? a[e] = o[e] : r && (i = !0, a[e] = [].slice.call(document.querySelectorAll(e))) : w(e) && e.forEach(t) }), this.refTargets = n, this.selectorMap = a, !t && i && this.forceUpdate(), n }, r._checkChangeTargets = function () { var t = this._differ.update(this._elementTargets), e = t.added, t = t.removed; (e.length || t.length) && (null != (t = (e = this.props).onChangeTargets) && t.call(e, { moveable: this.moveable, targets: this._elementTargets }), null != (t = this._onChangeTargets) && t.call(this)), this._updateRefs() }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, function (t, e, n, r) { var i, o = arguments.length, a = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, e, n, r); else for (var s = t.length - 1; 0 <= s; s--)(i = t[s]) && (a = (o < 3 ? i(a) : 3 < o ? i(e, n, a) : i(e, n)) || a); 3 < o && a && Object.defineProperty(e, n, a) }([(n = qn, void 0 === o && (o = {}), function (e, i) { n.forEach(function (r) { var t = o[r] || r; t in e || (e[t] = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; var n = (n = this[i])[r].apply(n, t); return n === this[i] ? this : n }) }) })], t.prototype, "moveable", void 0), t }(Zt)), Na = function (e) { function t(t) { t = e.call(this, t) || this; return t.state = {}, t.state = t.props, t } return u(t, e), t.prototype.render = function () { return t = C(Fa, c({ ref: M(this, "moveable") }, this.state)), e = this.state.parentElement, C(Kt, { element: t, container: e }); var t, e }, t }(Yt), Ia = t, ja = qn, Ya = Ra, a = le, Xa = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return u(e, t), e }(function (i) { function t(t, e) { void 0 === e && (e = {}); var n = i.call(this) || this, e = (n.tempElement = document.createElement("div"), c({}, e)), r = {}, t = (Ya.forEach(function (e) { r["on ".concat(e).replace(/[\s-_]([a-z])/g, function (t, e) { return e.toUpperCase() })] = function (t) { return n.trigger(e, t) } }), ee(C(Na, c({ ref: M(n, "innerMoveable"), parentElement: t }, e, r)), n.tempElement), e.target); return w(t) && 1 < t.length && n.updateRect(), n } u(t, i); var e = t.prototype; return e.setState = function (t, e) { this.innerMoveable.setState(t, e) }, e.forceUpdate = function (t) { this.innerMoveable.forceUpdate(t) }, e.dragStart = function (t) { this.innerMoveable.$_timer && this.forceUpdate(), this.getMoveable().dragStart(t) }, e.destroy = function () { ee(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null }, e.getMoveable = function () { return this.innerMoveable.moveable }, function (t, e, n, r) { var i, o = arguments.length, a = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, e, n, r); else for (var s = t.length - 1; 0 <= s; s--)(i = t[s]) && (a = (o < 3 ? i(a) : 3 < o ? i(e, n, a) : i(e, n)) || a); return 3 < o && a && Object.defineProperty(e, n, a), a }([l(ja, function (t, r) { t[r] || (t[r] = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; var n = this.getMoveable(); if (n && n[r]) return n[r].apply(n, t) }) }), l(Ia, function (t, n) { Object.defineProperty(t, n, { get: function () { return this.getMoveable().props[n] }, set: function (t) { var e; this.setState(((e = {})[n] = t, e)) }, enumerable: !0, configurable: !0 }) })], t) }($e)); var Wa, qa = { __proto__: null, default: Xa, PROPERTIES: Ia, METHODS: ja, EVENTS: Ya, PROPS_MAP: a, getElementInfo: function (t, e, n) { return Ea(t, t = e, e = void 0 === (e = n) ? t : e, !0) }, makeAble: Cn }; for (Wa in qa) Xa[Wa] = qa[Wa]; return Xa });